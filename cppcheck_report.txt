command lines/bash/alias.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/alias.c:476:19: style: The scope of the variable 'j' can be reduced. [variableScope]
  register int i, j, start;
                  ^
command lines/bash/alias.c:476:22: style: The scope of the variable 'start' can be reduced. [variableScope]
  register int i, j, start;
                     ^
command lines/bash/alias.c:478:17: style: The scope of the variable 'tl' can be reduced. [variableScope]
  int line_len, tl, real_start, expand_next, expand_this_token;
                ^
command lines/bash/alias.c:478:21: style: The scope of the variable 'real_start' can be reduced. [variableScope]
  int line_len, tl, real_start, expand_next, expand_this_token;
                    ^
command lines/bash/alias.c:478:46: style: The scope of the variable 'expand_this_token' can be reduced. [variableScope]
  int line_len, tl, real_start, expand_next, expand_this_token;
                                             ^
command lines/bash/array.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 66 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/error.h:36:26: error: There is an unknown macro here somewhere. Configuration is required. If __P is a macro then please configure it. [unknownMacro]
extern void report_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
                         ^
command lines/bash/arrayfunc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 69 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/assoc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 62 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/bashhist.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 95 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/bashline.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 115 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/bracecomp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 61 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/braces.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 72 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/braces.c:500:28: style: The scope of the variable 'rhs_l' can be reduced. [variableScope]
  int lhs_t, rhs_t, lhs_l, rhs_l, width;
                           ^
command lines/bash/braces.c:503:24: style: The scope of the variable 'oep' can be reduced. [variableScope]
  char **result, *ep, *oep;
                       ^
command lines/bash/braces.c:265:1: style: Label 'add_tack' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
add_tack:
^
command lines/bash/braces.c:116:10: style: Unused variable: j [unusedVariable]
  int i, j, c, c1;
         ^
command lines/bash/braces.c:116:16: style: Unused variable: c1 [unusedVariable]
  int i, j, c, c1;
               ^
command lines/bash/builtins/bashgetopt.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 62 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/common.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 109 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/evalfile.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 103 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/evalstring.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 107 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/gen-helpfiles.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/gen-helpfiles.c:156:9: style: The scope of the variable 'helpfile' can be reduced. [variableScope]
  char *helpfile, *bname, *fname;
        ^
command lines/bash/builtins/gen-helpfiles.c:156:28: style: The scope of the variable 'fname' can be reduced. [variableScope]
  char *helpfile, *bname, *fname;
                           ^
command lines/bash/builtins/gen-helpfiles.c:157:9: style: The scope of the variable 'helpfp' can be reduced. [variableScope]
  FILE *helpfp;
        ^
command lines/bash/builtins/gen-helpfiles.c:156:20: style: Unused variable: bname [unusedVariable]
  char *helpfile, *bname, *fname;
                   ^
command lines/bash/builtins/getopt.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 62 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/builtins/mkbuiltins.c:743:11: error: Allocation with xmalloc, strcpy doesn't release it. [leakNoVarFunctionCall]
  return (savestring (new));
          ^
command lines/bash/builtins/mkbuiltins.c:1078:25: error: Allocation with xmalloc, strcpy doesn't release it. [leakNoVarFunctionCall]
    builtin->function ? savestring (builtin->function) : (char *)NULL;
                        ^
command lines/bash/builtins/mkbuiltins.c:1080:25: error: Allocation with xmalloc, strcpy doesn't release it. [leakNoVarFunctionCall]
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;
                        ^
command lines/bash/builtins/mkbuiltins.c:649:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  register int i;
               ^
command lines/bash/builtins/mkbuiltins.c:672:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  register int i;
               ^
command lines/bash/builtins/mkbuiltins.c:673:26: style: The scope of the variable 'builtin' can be reduced. [variableScope]
  register BUILTIN_DESC *builtin;
                         ^
command lines/bash/builtins/mkbuiltins.c:1168:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  register int i;
               ^
command lines/bash/builtins/mkbuiltins.c:1195:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  register int i;
               ^
command lines/bash/builtins/mkbuiltins.c:1212:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  register int i;
               ^
command lines/bash/builtins/mkbuiltins.c:1217:30: style: The scope of the variable 'builtin' can be reduced. [variableScope]
      register BUILTIN_DESC *builtin;
                             ^
command lines/bash/builtins/mkbuiltins.c:1318:26: style: The scope of the variable 'builtin' can be reduced. [variableScope]
  register BUILTIN_DESC *builtin;
                         ^
command lines/bash/builtins/mkbuiltins.c:1319:9: style: The scope of the variable 'dname' can be reduced. [variableScope]
  char *dname;
        ^
command lines/bash/builtins/mkbuiltins.c:1357:17: style: The scope of the variable 'builtin' can be reduced. [variableScope]
  BUILTIN_DESC *builtin;
                ^
command lines/bash/builtins/mkbuiltins.c:1570:9: style: The scope of the variable 'helpfile' can be reduced. [variableScope]
  char *helpfile, *bname;
        ^
command lines/bash/builtins/mkbuiltins.c:1570:20: style: The scope of the variable 'bname' can be reduced. [variableScope]
  char *helpfile, *bname;
                   ^
command lines/bash/builtins/mkbuiltins.c:1571:9: style: The scope of the variable 'helpfp' can be reduced. [variableScope]
  FILE *helpfp;
        ^
command lines/bash/builtins/mkbuiltins.c:1573:17: style: The scope of the variable 'builtin' can be reduced. [variableScope]
  BUILTIN_DESC *builtin;
                ^
command lines/bash/builtins/mkbuiltins.c:248:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   strcpy (error_directory, argv[arg_index]);
^
command lines/bash/builtins/mkbuiltins.c:402:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    copy->array[i] = savestring (array->array[i]);
^
command lines/bash/builtins/mkbuiltins.c:743:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  return (savestring (new));
^
command lines/bash/builtins/mkbuiltins.c:1072:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  new->name = savestring (builtin->name);
^
command lines/bash/builtins/mkbuiltins.c:1073:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  new->shortdoc = savestring (builtin->shortdoc);
^
command lines/bash/builtins/mkbuiltins.c:1078:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    builtin->function ? savestring (builtin->function) : (char *)NULL;
^
command lines/bash/builtins/mkbuiltins.c:1080:0: information: Skipping configuration '__STDC__;strcpy' since the value of 'strcpy' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    builtin->docname  ? savestring (builtin->docname)  : (char *)NULL;
^
command lines/bash/builtins/psize.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 19 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/copy_cmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 62 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/dispose_cmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 68 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/error.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 90 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/eval.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 91 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/examples/loadables/basename.c:39:13: style: The scope of the variable 'sufflen' can be reduced. [variableScope]
  int slen, sufflen, off;
            ^
command lines/bash/examples/loadables/basename.c:39:22: style: The scope of the variable 'off' can be reduced. [variableScope]
  int slen, sufflen, off;
                     ^
command lines/bash/examples/loadables/cat.c:43:9: style: The scope of the variable 'w' can be reduced. [variableScope]
 int n, w, e;
        ^
command lines/bash/examples/loadables/fdflags.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/examples/loadables/fdflags.c:263:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/fdflags.c:245:12: style: The scope of the variable 'maxfd' can be reduced. [variableScope]
  int opt, maxfd, i, num, verbose, setflag;
           ^
command lines/bash/examples/loadables/fdflags.c:245:19: style: The scope of the variable 'i' can be reduced. [variableScope]
  int opt, maxfd, i, num, verbose, setflag;
                  ^
command lines/bash/examples/loadables/fdflags.c:100:7: style: Unused variable: allflags [unusedVariable]
  int allflags;
      ^
command lines/bash/examples/loadables/fdflags.c:227:0: information: Skipping configuration 'F_MAXFD' since the value of 'F_MAXFD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  maxfd = fcntl (0, F_MAXFD);
^
command lines/bash/examples/loadables/fdflags.c:63:0: information: Skipping configuration 'O_ALT_IO' since the value of 'O_ALT_IO' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "altio", O_ALT_IO },
^
command lines/bash/examples/loadables/fdflags.c:42:0: information: Skipping configuration 'O_APPEND' since the value of 'O_APPEND' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "append", O_APPEND  },
^
command lines/bash/examples/loadables/fdflags.c:45:0: information: Skipping configuration 'O_ASYNC' since the value of 'O_ASYNC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "async", O_ASYNC  },
^
command lines/bash/examples/loadables/fdflags.c:75:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "cloexec", O_CLOEXEC },
^
command lines/bash/examples/loadables/fdflags.c:117:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    f |= O_CLOEXEC;
^
command lines/bash/examples/loadables/fdflags.c:202:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if ((pos & O_CLOEXEC) && (f & O_CLOEXEC) == 0)
^
command lines/bash/examples/loadables/fdflags.c:204:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if ((neg & O_CLOEXEC) && (f & O_CLOEXEC))
^
command lines/bash/examples/loadables/fdflags.c:209:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  pos &= ~O_CLOEXEC;
^
command lines/bash/examples/loadables/fdflags.c:210:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  neg &= ~O_CLOEXEC;
^
command lines/bash/examples/loadables/fdflags.c:211:0: information: Skipping configuration 'O_CLOEXEC' since the value of 'O_CLOEXEC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  f &= ~O_CLOEXEC;
^
command lines/bash/examples/loadables/fdflags.c:66:0: information: Skipping configuration 'O_DIRECT' since the value of 'O_DIRECT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "direct", O_DIRECT },
^
command lines/bash/examples/loadables/fdflags.c:57:0: information: Skipping configuration 'O_DSYNC' since the value of 'O_DSYNC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "dsync", O_DSYNC  },
^
command lines/bash/examples/loadables/fdflags.c:54:0: information: Skipping configuration 'O_FSYNC' since the value of 'O_FSYNC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "fsync", O_FSYNC  },
^
command lines/bash/examples/loadables/fdflags.c:69:0: information: Skipping configuration 'O_NOATIME' since the value of 'O_NOATIME' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  { "noatime", O_NOATIME },
^
command lines/bash/examples/loadables/finfo.c:105:6: style: Unused variable: mode [unusedVariable]
 int mode, flags, opt;
     ^
command lines/bash/examples/loadables/finfo.c:313:6: style: Unused variable: p [unusedVariable]
 int p;
     ^
command lines/bash/examples/loadables/finfo.c:314:8: style: Unused variable: b [unusedVariable]
 char *b;
       ^
command lines/bash/examples/loadables/finfo.c:393:14: style: Unused variable: l [unusedVariable]
  WORD_LIST *l;
             ^
command lines/bash/examples/loadables/finfo.c:495:2: portability: %d in format string (no. 2) requires 'int' but the argument type is 'size_t {aka unsigned long}'. [invalidPrintfArgType_sint]
 fprintf(stderr, "%s: cannot malloc %d bytes\n", prog, s);
 ^
command lines/bash/examples/loadables/finfo.c:473:14: style: The scope of the variable 'ebuf' can be reduced. [variableScope]
 static char ebuf[40];
             ^
command lines/bash/examples/loadables/finfo.c:256:0: information: Skipping configuration 'S_ISLNK' since the value of 'S_ISLNK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (S_ISLNK(mode))
^
command lines/bash/examples/loadables/finfo.c:261:0: information: Skipping configuration 'S_ISWHT' since the value of 'S_ISWHT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (S_ISWHT(mode))
^
command lines/bash/examples/loadables/finfo.c:280:0: information: Skipping configuration 'makedev' since the value of 'makedev' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 d = makedev (ma, mi);
^
command lines/bash/examples/loadables/head.c:120:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/head.c:53:14: style: The scope of the variable 'wd' can be reduced. [variableScope]
  WORD_DESC *wd;
             ^
command lines/bash/examples/loadables/head.c:54:9: style: The scope of the variable 'arg' can be reduced. [variableScope]
  char *arg;
        ^
command lines/bash/examples/loadables/head.c:76:7: style: The scope of the variable 'ch' can be reduced. [variableScope]
  int ch;
      ^
command lines/bash/examples/loadables/head.c:100:9: style: The scope of the variable 'fp' can be reduced. [variableScope]
  FILE *fp;
        ^
command lines/bash/examples/loadables/head.c:102:9: style: Unused variable: t [unusedVariable]
  char *t;
        ^
command lines/bash/examples/loadables/head.c:84:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       builtin_error ("write error: %s", strerror (errno));
^
command lines/bash/examples/loadables/head.c:136:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   builtin_error ("%s: %s", l->word->word, strerror (errno));
^
command lines/bash/examples/loadables/id.c:94:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/ln.c:79:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/ln.c:161:20: style: The scope of the variable 'p' can be reduced. [variableScope]
  char *dst_path, *p;
                   ^
command lines/bash/examples/loadables/ln.c:169:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   builtin_error ("%s: %s", src, strerror (errno));
^
command lines/bash/examples/loadables/ln.c:174:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   errno = EISDIR;
^
command lines/bash/examples/loadables/ln.c:175:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   builtin_error ("%s: %s", src, strerror (errno));
^
command lines/bash/examples/loadables/ln.c:199:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      builtin_error ("%s: cannot unlink: %s", dst, strerror (errno));
^
command lines/bash/examples/loadables/ln.c:207:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      builtin_error ("cannot link %s to %s: %s", dst, src, strerror (errno));
^
command lines/bash/examples/loadables/logname.c:50:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      builtin_error ("cannot find username: %s", strerror (errno));
^
command lines/bash/examples/loadables/mkdir.c:96:12: style: Condition 'mode' is always true [knownConditionTrueFalse]
  else if (mode)
           ^
command lines/bash/examples/loadables/mkdir.c:85:12: note: Assuming that condition 'mode==NULL' is not redundant
  if (mode == NULL)
           ^
command lines/bash/examples/loadables/mkdir.c:96:12: note: Condition 'mode' is always true
  else if (mode)
           ^
command lines/bash/examples/loadables/mkdir.c:72:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/mkdir.c:163:10: style: Variable 'oumask' is assigned a value that is never used. [unreadVariable]
  oumask = umask (0);
         ^
command lines/bash/examples/loadables/mkdir.c:126:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
          builtin_error ("cannot create directory `%s': %s", l->word->word, strerror (errno));
^
command lines/bash/examples/loadables/mkdir.c:156:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
          builtin_error ("%s: %s", path, strerror (errno));
^
command lines/bash/examples/loadables/mkdir.c:180:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
^
command lines/bash/examples/loadables/mkdir.c:187:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       builtin_error ("cannot chmod directory `%s': %s", npath, strerror (errno));
^
command lines/bash/examples/loadables/mkdir.c:209:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      builtin_error ("cannot create directory `%s': %s", npath, strerror (errno));
^
command lines/bash/examples/loadables/pathchk.c:115:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/pathchk.c:217:0: information: Skipping configuration 'EINTR' since the value of 'EINTR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  while (ret < 0 && errno == EINTR);
^
command lines/bash/examples/loadables/pathchk.c:344:0: information: Skipping configuration 'NAME_MAX;_POSIX_VERSION' since the value of 'NAME_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
^
command lines/bash/examples/loadables/pathchk.c:369:0: information: Skipping configuration 'PATH_MAX;_POSIX_VERSION' since the value of 'PATH_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
^
command lines/bash/examples/loadables/pathchk.c:344:0: information: Skipping configuration '_POSIX_NAME_MAX' since the value of '_POSIX_NAME_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      name_max = portability ? _POSIX_NAME_MAX : NAME_MAX_FOR (parent);
^
command lines/bash/examples/loadables/pathchk.c:346:0: information: Skipping configuration '_POSIX_NAME_MAX' since the value of '_POSIX_NAME_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 name_max = _POSIX_NAME_MAX;
^
command lines/bash/examples/loadables/pathchk.c:369:0: information: Skipping configuration '_POSIX_PATH_MAX' since the value of '_POSIX_PATH_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  path_max = portability ? _POSIX_PATH_MAX : PATH_MAX_FOR (parent);
^
command lines/bash/examples/loadables/pathchk.c:371:0: information: Skipping configuration '_POSIX_PATH_MAX' since the value of '_POSIX_PATH_MAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    path_max = _POSIX_PATH_MAX;
^
command lines/bash/examples/loadables/pathchk.c:247:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      if (errno == EACCES)
^
command lines/bash/examples/loadables/pathchk.c:250:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 builtin_error ("%s: %s", path, strerror (errno));
^
command lines/bash/examples/loadables/print.c:125:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/print.c:178:9: style: The scope of the variable 'ostr' can be reduced. [variableScope]
  char *ostr;
        ^
command lines/bash/examples/loadables/print.c:80:21: style: Unused variable: arg [unusedVariable]
  char **v, *pfmt, *arg;
                    ^
command lines/bash/examples/loadables/printenv.c:40:19: style: The scope of the variable 'envp' can be reduced. [variableScope]
  register char **envp;
                  ^
command lines/bash/examples/loadables/push.c:60:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  list = loptend;
  ^
command lines/bash/examples/loadables/realpath.c:89:3: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
  CASE_HELPOPT;
  ^
command lines/bash/examples/loadables/realpath.c:68:8: style: The scope of the variable 'r' can be reduced. [variableScope]
 char *r, realbuf[PATH_MAX], *p;
       ^
command lines/bash/examples/loadables/realpath.c:68:31: style: The scope of the variable 'p' can be reduced. [variableScope]
 char *r, realbuf[PATH_MAX], *p;
                              ^
command lines/bash/examples/loadables/rm.c:138:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/rm.c:117:15: style: Unused variable: name [unusedVariable]
  const char *name;
              ^
command lines/bash/examples/loadables/rm.c:90:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    builtin_error ("%s: %s", dirname, strerror (errno));
^
command lines/bash/examples/loadables/rm.c:104:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if ((errno == EISDIR || errno == EPERM) && recursive && file_isdir (fname))
^
command lines/bash/examples/loadables/rm.c:109:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  builtin_error ("%s: %s", fname, strerror (errno));
^
command lines/bash/examples/loadables/rmdir.c:48:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 builtin_error ("%s: %s", l->word->word, strerror (errno));
^
command lines/bash/examples/loadables/seq.c:93:9: style: Assignment 'ret=0.0' is redundant with condition 'ret==-0.0'. [duplicateConditionalAssign]
    ret = 0.0;
        ^
command lines/bash/examples/loadables/seq.c:92:11: note: Condition 'ret==-0.0'
  if (ret == -0.0)
          ^
command lines/bash/examples/loadables/seq.c:93:9: note: Assignment 'ret=0.0' is redundant
    ret = 0.0;
        ^
command lines/bash/examples/loadables/seq.c:361:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/stat.c:365:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/stat.c:327:9: style: The scope of the variable 'key' can be reduced. [variableScope]
  char *key, *value;
        ^
command lines/bash/examples/loadables/stat.c:327:15: style: The scope of the variable 'value' can be reduced. [variableScope]
  char *key, *value;
              ^
command lines/bash/examples/loadables/stat.c:328:14: style: The scope of the variable 'v' can be reduced. [variableScope]
  SHELL_VAR *v;
             ^
command lines/bash/examples/loadables/stat.c:334:9: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
      v = bind_assoc_variable (var, vname, key, value, ASS_FORCE);
        ^
command lines/bash/examples/loadables/stat.c:235:0: information: Skipping configuration 'S_ISDOOR' since the value of 'S_ISDOOR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (S_ISDOOR (mode))
^
command lines/bash/examples/loadables/stat.c:247:0: information: Skipping configuration 'S_ISMPC' since the value of 'S_ISMPC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (S_ISMPC (mode))
^
command lines/bash/examples/loadables/stat.c:243:0: information: Skipping configuration 'S_ISNWK' since the value of 'S_ISNWK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (S_ISNWK(mode))
^
command lines/bash/examples/loadables/stat.c:239:0: information: Skipping configuration 'S_ISWHT' since the value of 'S_ISWHT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (S_ISWHT(mode))
^
command lines/bash/examples/loadables/strftime.c:43:18: style: The scope of the variable 'tsize' can be reduced. [variableScope]
  size_t tbsize, tsize;
                 ^
command lines/bash/examples/loadables/tee.c:87:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/tee.c:67:34: style: The scope of the variable 'fd' can be reduced. [variableScope]
  int opt, append, nointr, rval, fd, fflags;
                                 ^
command lines/bash/examples/loadables/tee.c:72:9: style: Unused variable: t [unusedVariable]
  char *t;
        ^
command lines/bash/examples/loadables/tee.c:113:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
          builtin_error ("%s: cannot open: %s", list->word->word, strerror (errno));
^
command lines/bash/examples/loadables/tee.c:135:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  builtin_error ("%s: write error: %s", fl->fname, strerror (errno));
^
command lines/bash/examples/loadables/tee.c:144:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    builtin_error ("read error: %s", strerror (errno));
^
command lines/bash/examples/loadables/tee.c:153:0: information: Skipping configuration 'errno' since the value of 'errno' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   builtin_error ("%s: close_error: %s", fl->fname, strerror (errno));
^
command lines/bash/examples/loadables/template.c:40:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  list = loptend;
  ^
command lines/bash/examples/loadables/tty.c:55:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  list = loptend;
  ^
command lines/bash/examples/loadables/tty.c:49:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/uname.c:98:2: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 CASE_HELPOPT;
 ^
command lines/bash/examples/loadables/uname.c:127:3: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
  uprint (FLAG_SYSNAME, uninfo.sysname);
  ^
command lines/bash/examples/loadables/uname.c:70:12: style: Unused variable: r [unusedVariable]
  int opt, r;
           ^
command lines/bash/execute_cmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 158 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/findcmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 80 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/flags.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 70 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/hashcmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 68 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/input.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 86 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/input.c:402:0: information: Skipping configuration 'BUFFERED_INPUT;SEEK_CUR' since the value of 'SEEK_CUR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  size = (fd_is_seekable (fd)) ? min (sb.st_size, MAX_INPUT_BUFFER_SIZE) : 1;
^
command lines/bash/input.c:501:0: information: Skipping configuration 'BUFFERED_INPUT;SEEK_CUR' since the value of 'SEEK_CUR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      o = lseek (bp->b_fd, 0, SEEK_CUR);
^
command lines/bash/input.c:503:0: information: Skipping configuration 'BUFFERED_INPUT;SEEK_CUR' since the value of 'SEEK_CUR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      if (nr > 0 && nr < lseek (bp->b_fd, 0, SEEK_CUR) - o)
^
command lines/bash/input.c:562:0: information: Skipping configuration 'BUFFERED_INPUT;SEEK_CUR' since the value of 'SEEK_CUR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    lseek (bp->b_fd, -chars_left, SEEK_CUR);
^
command lines/bash/jobs.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 129 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/list.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 56 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/locale.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 81 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/mailcheck.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 75 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/make_cmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 97 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/mksyntax.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/mksyntax.c:169:17: style: The scope of the variable 'uc' can be reduced. [variableScope]
  unsigned char uc;
                ^
command lines/bash/mksyntax.c:190:9: style: The scope of the variable 'fstr' can be reduced. [variableScope]
  char *fstr;
        ^
command lines/bash/mksyntax.c:204:17: style: The scope of the variable 'uc' can be reduced. [variableScope]
  unsigned char uc;
                ^
command lines/bash/mksyntax.c:259:22: style: The scope of the variable 'i' can be reduced. [variableScope]
  int xflags, first, i;
                     ^
command lines/bash/mksyntax.c:211:0: information: Skipping configuration 'HAVE_ISBLANK;isblank' since the value of 'isblank' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      if (isblank (uc))
^
command lines/bash/nojobs.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 98 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/pathexp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 78 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/pcomplete.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 106 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/pcomplib.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 68 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/print_cmd.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 85 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/redir.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 96 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/shell.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 136 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/sig.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 123 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/siglist.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 70 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/stringlib.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 67 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/support/bashversion.c:111:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  argv += optind;
  ^
command lines/bash/support/man2html.c:813:14: warning: Either the condition 'obp>10000' is redundant or the array 'outbuffer[10001]' is accessed at index 10001, which is out of bounds. [arrayIndexOutOfBoundsCond]
    outbuffer[obp] = '\0';
             ^
command lines/bash/support/man2html.c:812:26: note: Assuming that condition 'obp>10000' is not redundant
   if (*c == '\n' || obp > HUGE_STR_MAX) {
                         ^
command lines/bash/support/man2html.c:813:14: note: Array index out of bounds
    outbuffer[obp] = '\0';
             ^
command lines/bash/support/man2html.c:2699:14: error: Array 'wordlist[100]' accessed at index wordlist[*][-1], which is out of bounds. [negativeIndex]
     wordlist[i][-1] = ' ';
             ^
command lines/bash/support/man2html.c:2899:15: error: Array 'wordlist[100]' accessed at index wordlist[*][-1], which is out of bounds. [negativeIndex]
      wordlist[i][-1] = '\0';
              ^
command lines/bash/support/man2html.c:2938:13: error: Array 'wordlist[100]' accessed at index wordlist[*][-1], which is out of bounds. [negativeIndex]
    wordlist[1][-1] = '\0';
            ^
command lines/bash/support/man2html.c:3679:14: error: Array 'wordlist[100]' accessed at index wordlist[*][-1], which is out of bounds. [negativeIndex]
     wordlist[i][-1] = '\0';
             ^
command lines/bash/support/man2html.c:787:8: style: Condition '!no_newline_output' is always false [knownConditionTrueFalse]
   if (!no_newline_output)
       ^
command lines/bash/support/man2html.c:785:23: note: Assignment 'no_newline_output=1', assigned value is 1
  no_newline_output = 1;
                      ^
command lines/bash/support/man2html.c:787:8: note: Condition '!no_newline_output' is always false
   if (!no_newline_output)
       ^
command lines/bash/support/man2html.c:793:7: style: Condition '!no_newline_output' is always false [knownConditionTrueFalse]
  if (!no_newline_output)
      ^
command lines/bash/support/man2html.c:785:23: note: Assignment 'no_newline_output=1', assigned value is 1
  no_newline_output = 1;
                      ^
command lines/bash/support/man2html.c:793:7: note: Condition '!no_newline_output' is always false
  if (!no_newline_output)
      ^
command lines/bash/support/man2html.c:2139:67: warning: Either the condition 'if(c)' is redundant or there is possible null pointer dereference: c. [nullPointerRedundantCheck]
 sprintf(manidx + mip, "<DT><A HREF=\"#%s\">%s</A><DD>\n", label, c);
                                                                  ^
command lines/bash/support/man2html.c:2140:5: note: Assuming that condition 'if(c)' is not redundant
 if (c)
    ^
command lines/bash/support/man2html.c:2139:67: note: Null pointer dereference
 sprintf(manidx + mip, "<DT><A HREF=\"#%s\">%s</A><DD>\n", label, c);
                                                                  ^
command lines/bash/support/man2html.c:2645:7: style: Variable '*c' is reassigned a value before the old one has been used. [redundantAssignment]
   *c = '\n';
      ^
command lines/bash/support/man2html.c:2643:7: note: *c is assigned
   *c = '\0';
      ^
command lines/bash/support/man2html.c:2645:7: note: *c is overwritten
   *c = '\n';
      ^
command lines/bash/support/man2html.c:3980:14: style: Variable '*(end-2)' is reassigned a value before the old one has been used. [redundantAssignment]
  *(end - 2) = *(end - 1);
             ^
command lines/bash/support/man2html.c:3978:14: note: *(end-2) is assigned
  *(end - 2) = '\n';
             ^
command lines/bash/support/man2html.c:3980:14: note: *(end-2) is overwritten
  *(end - 2) = *(end - 1);
             ^
command lines/bash/support/man2html.c:2401:4: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
   c = skip_till_newline(c);
   ^
command lines/bash/support/man2html.c:1236:18: style: The scope of the variable 'tr2' can be reduced. [variableScope]
 TABLEROW *tr1, *tr2;
                 ^
command lines/bash/support/man2html.c:1440:55: style: The scope of the variable 'linesize' can be reduced. [variableScope]
 int     center = 0, expand = 0, box = 0, border = 0, linesize = 1;
                                                      ^
command lines/bash/support/man2html.c:1441:13: style: The scope of the variable 'j' can be reduced. [variableScope]
 int     i, j, maxcol = 0, finished = 0;
            ^
command lines/bash/support/man2html.c:2309:14: style: Local variable 'h' shadows outer variable [shadowVariable]
     char   *h;
             ^
command lines/bash/support/man2html.c:2202:10: note: Shadowed declaration
 char   *h;
         ^
command lines/bash/support/man2html.c:2309:14: note: Shadow variable
     char   *h;
             ^
command lines/bash/support/man2html.c:2323:15: style: Local variable 'h' shadows outer variable [shadowVariable]
      char   *h = NULL;
              ^
command lines/bash/support/man2html.c:2202:10: note: Shadowed declaration
 char   *h;
         ^
command lines/bash/support/man2html.c:2323:15: note: Shadow variable
      char   *h = NULL;
              ^
command lines/bash/support/man2html.c:3681:14: style: Local variable 'h' shadows outer variable [shadowVariable]
     char   *h = NULL;
             ^
command lines/bash/support/man2html.c:2202:10: note: Shadowed declaration
 char   *h;
         ^
command lines/bash/support/man2html.c:3681:14: note: Shadow variable
     char   *h = NULL;
             ^
command lines/bash/support/man2html.c:3099:16: error: Uninitialized variable: list_options [uninitvar]
    if (strstr(list_options, "-bullet")) { /* HTML Unnumbered List */
               ^
command lines/bash/support/man2html.c:3232:16: error: Uninitialized variable: bd_options [uninitvar]
    if (strstr(bd_options, "-offset indent")) {
               ^
command lines/bash/support/man2html.c:508:10: style: Unused variable: i [unusedVariable]
 int     i;
         ^
command lines/bash/support/man2html.c:989:9: style: Variable 'b[1]' is assigned a value that is never used. [unreadVariable]
   b[1] = '\0';
        ^
command lines/bash/support/man2html.c:1439:10: style: Unused variable: t [unusedVariable]
 char   *t, *h, *g;
         ^
command lines/bash/support/man2html.c:1444:37: style: Unused variable: ftable [unusedVariable]
 TABLEROW *layout = NULL, *currow, *ftable;
                                    ^
command lines/bash/support/man2html.c:1774:51: style: Variable 'opex' is assigned a value that is never used. [unreadVariable]
 int     value = 0, value2, j = 0, sign = 1, opex = 0;
                                                  ^
command lines/bash/support/man2html.c:2808:7: style: Variable 'sl' is assigned a value that is never used. [unreadVariable]
   sl = fill_words(c + j, wordlist, &words);
      ^
command lines/bash/support/man2html.c:2540:13: style: Unused variable: f [unusedVariable]
    FILE   *f;
            ^
command lines/bash/support/man2html.c:3943:2: style: Variable 'ibp' is assigned a value that is never used. [unreadVariable]
 FLUSHIBP;
 ^
command lines/bash/support/man2html.c:3763:10: style: Unused variable: i [unusedVariable]
 int     i;
         ^
command lines/bash/support/man2html.c:3822:12: style: Unused variable: mx [unusedVariable]
   int     mx;
           ^
command lines/bash/support/man2html.c:3992:10: style: Unused variable: f [unusedVariable]
 FILE   *f;
         ^
command lines/bash/support/man2html.c:3994:10: style: Unused variable: l [unusedVariable]
 int     l, i;
         ^
command lines/bash/support/man2html.c:3996:14: style: Unused variable: fullname [unusedVariable]
 char   *h, *fullname;
             ^
command lines/bash/support/mksignames.c:51:16: style: Unused variable: i [unusedVariable]
  register int i;
               ^
command lines/bash/support/mksignames.c:64:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  for (i = 0; i <= LASTSIG; i++)
^
command lines/bash/support/signames.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 69 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/support/signames.c:103:0: information: Skipping configuration 'BUILDTOOL;SIGRTMAX;SIGRTMIN' since the value of 'SIGRTMAX' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  rtmax = SIGRTMAX;
^
command lines/bash/support/signames.c:98:0: information: Skipping configuration 'BUILDTOOL;SIGRTMAX;SIGRTMIN' since the value of 'SIGRTMIN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  rtmin = SIGRTMIN;
^
command lines/bash/support/signames.c:47:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
char *signal_names[2 * (LASTSIG)];
^
command lines/bash/support/signames.c:390:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  for (i = 0; i < NSIG; i++)
^
command lines/bash/support/signames.c:398:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[NSIG] = "DEBUG";
^
command lines/bash/support/signames.c:399:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[NSIG+1] = "ERR";
^
command lines/bash/support/signames.c:400:0: information: Skipping configuration 'NSIG' since the value of 'NSIG' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[NSIG+2] = "RETURN";
^
command lines/bash/support/signames.c:282:0: information: Skipping configuration 'SIGABRT' since the value of 'SIGABRT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGABRT] = "SIGABRT";
^
command lines/bash/support/signames.c:314:0: information: Skipping configuration 'SIGALRM' since the value of 'SIGALRM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGALRM] = "SIGALRM";
^
command lines/bash/support/signames.c:167:0: information: Skipping configuration 'SIGALRM1' since the value of 'SIGALRM1' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGALRM1] = "SIGALRM1";
^
command lines/bash/support/signames.c:298:0: information: Skipping configuration 'SIGBUS' since the value of 'SIGBUS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGBUS] = "SIGBUS";
^
command lines/bash/support/signames.c:208:0: information: Skipping configuration 'SIGCANCEL' since the value of 'SIGCANCEL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGCANCEL] = "SIGCANCEL";
^
command lines/bash/support/signames.c:338:0: information: Skipping configuration 'SIGCHLD' since the value of 'SIGCHLD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGCHLD] = "SIGCHLD";
^
command lines/bash/support/signames.c:230:0: information: Skipping configuration 'SIGCLD' since the value of 'SIGCLD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  signal_names[SIGCLD] = "SIGCLD";
^
command lines/bash/test.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 82 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/unwind_prot.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/bash/error.h:33:31: error: There is an unknown macro here somewhere. Configuration is required. If __P is a macro then please configure it. [unknownMacro]
extern void programming_error __P((const char *, ...))  __attribute__((__format__ (printf, 1, 2)));
                              ^
command lines/bash/xmalloc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 22 configurations. Use --force to check all configurations. [toomanyconfigs]

^
command lines/platypusPrompt/dfc.c:16:3: error: printf format string requires 1 parameter but only 0 are given. [wrongPrintfScanfArgNum]
  printf("Wut? You said: %s. What does that mean\?\?\?\? \n");
  ^
command lines/platypusPrompt/dfc.c:6:2: warning: scanf() without field width limits can crash with huge input data. [invalidscanf]
 scanf("%s", input);
 ^
command lines/platypusPrompt/dfc.c:7:11: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 if(input == "dfc" || "Dfc" || "DFC") {
          ^
command lines/platypusPrompt/dfc.c:11:16: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 else if(input == "dcf" || "Dcf" || "DCF"){
               ^
command lines/platypusPrompt/dfc.c:7:23: warning: Conversion of string literal "Dfc" to bool always evaluates to true. [incorrectStringBooleanError]
 if(input == "dfc" || "Dfc" || "DFC") {
                      ^
command lines/platypusPrompt/dfc.c:7:32: warning: Conversion of string literal "DFC" to bool always evaluates to true. [incorrectStringBooleanError]
 if(input == "dfc" || "Dfc" || "DFC") {
                               ^
command lines/platypusPrompt/dfc.c:11:28: warning: Conversion of string literal "Dcf" to bool always evaluates to true. [incorrectStringBooleanError]
 else if(input == "dcf" || "Dcf" || "DCF"){
                           ^
command lines/platypusPrompt/dfc.c:11:37: warning: Conversion of string literal "DCF" to bool always evaluates to true. [incorrectStringBooleanError]
 else if(input == "dcf" || "Dcf" || "DCF"){
                                    ^
libraries/cli/cprompt.h:21:5: warning: scanf() without field width limits can crash with huge input data. [invalidscanf]
    scanf("%s", input);
    ^
command lines/platypusPrompt/eastereggs/atomickittylitter.c:11:15: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
    if (input == "kittylitter"){
              ^
command lines/platypusPrompt/eastereggs/kittylitterdownfall.c:5:12: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 if (input == "downtolitter" || "kittylitterdownfall"){
           ^
command lines/platypusPrompt/eastereggs/kittylitterdownfall.c:5:33: warning: Conversion of string literal "kittylitterdownfall" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "downtolitter" || "kittylitterdownfall"){
                                ^
command lines/platypusPrompt/hello.c:4:15: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
    if (input == "hello" || "Hello" || "HeLlO"){
              ^
command lines/platypusPrompt/hello.c:4:29: warning: Conversion of string literal "Hello" to bool always evaluates to true. [incorrectStringBooleanError]
    if (input == "hello" || "Hello" || "HeLlO"){
                            ^
command lines/platypusPrompt/hello.c:4:40: warning: Conversion of string literal "HeLlO" to bool always evaluates to true. [incorrectStringBooleanError]
    if (input == "hello" || "Hello" || "HeLlO"){
                                       ^
command lines/platypusPrompt/help.c:7:1: error: syntax error: keyword 'if' is not allowed in global scope [syntaxError]
if (input == "help" || "HELP" || "Help" || "HeLp" || "hELP" || "hElP" || "help!" || "Help!" || "HELP!" || "hELP!" || "HeLp!" || "hElP"){
^
command lines/platypusPrompt/platypus-os-command.c:20:12: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
           ^
command lines/platypusPrompt/platypus-os-command.c:26:13: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
            ^
command lines/platypusPrompt/platypus-os-command.c:20:31: warning: Conversion of string literal "Platypus OS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                              ^
command lines/platypusPrompt/platypus-os-command.c:20:48: warning: Conversion of string literal "PlatypusOS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                               ^
command lines/platypusPrompt/platypus-os-command.c:20:64: warning: Conversion of string literal "PLATYPUSOS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                               ^
command lines/platypusPrompt/platypus-os-command.c:20:80: warning: Conversion of string literal "PlAtYpUsOs" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                               ^
command lines/platypusPrompt/platypus-os-command.c:20:96: warning: Conversion of string literal "pLaTyPuS oS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                                               ^
command lines/platypusPrompt/platypus-os-command.c:20:113: warning: Conversion of string literal "pLATYPUS os" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                                                                ^
command lines/platypusPrompt/platypus-os-command.c:20:130: warning: Conversion of string literal "pLATYPUSos" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                                                                                 ^
command lines/platypusPrompt/platypus-os-command.c:20:146: warning: Conversion of string literal "Platypus-OS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                                                                                                 ^
command lines/platypusPrompt/platypus-os-command.c:20:163: warning: Conversion of string literal "platypus-OS" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "platypusOS" || "Platypus OS" || "PlatypusOS" || "PLATYPUSOS" || "PlAtYpUsOs" || "pLaTyPuS oS" || "pLATYPUS os" || "pLATYPUSos" || "Platypus-OS" || "platypus-OS"){     /* it's good to have  flexibility, but there's only so much you can provide. Other flexibility is appreciated.*/
                                                                                                                                                                  ^
command lines/platypusPrompt/platypus-os-command.c:26:35: warning: Conversion of string literal "Platypus OS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                  ^
command lines/platypusPrompt/platypus-os-command.c:26:55: warning: Conversion of string literal "PlatypusOS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                      ^
command lines/platypusPrompt/platypus-os-command.c:26:74: warning: Conversion of string literal "PLATYPUSOS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                         ^
command lines/platypusPrompt/platypus-os-command.c:26:93: warning: Conversion of string literal "PlAtYpUsOs -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                            ^
command lines/platypusPrompt/platypus-os-command.c:26:112: warning: Conversion of string literal "pLaTyPuS oS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                                               ^
command lines/platypusPrompt/platypus-os-command.c:26:132: warning: Conversion of string literal "pLATYPUS os -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                                                                   ^
command lines/platypusPrompt/platypus-os-command.c:26:152: warning: Conversion of string literal "pLATYPUSos -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                                                                                       ^
command lines/platypusPrompt/platypus-os-command.c:26:171: warning: Conversion of string literal "Platypus-OS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                                                                                                          ^
command lines/platypusPrompt/platypus-os-command.c:26:191: warning: Conversion of string literal "platypus-OS -v" to bool always evaluates to true. [incorrectStringBooleanError]
  if (input == "platypusOS -v" || "Platypus OS -v" || "PlatypusOS -v" || "PLATYPUSOS -v" || "PlAtYpUsOs -v" || "pLaTyPuS oS -v" || "pLATYPUS os -v" || "pLATYPUSos -v" || "Platypus-OS -v" || "platypus-OS -v"){
                                                                                                                                                                                              ^
command lines/platypusPrompt/tools/hacking/earlynmap/nmap.c:346:8: error: No pair for character ("). Can't process file. File is either invalid or unicode, which is currently not supported. [syntaxError]
printf("%s [options] [hostname[/mask] . . .]
       ^
command lines/platypusPrompt/tools/network/ping.c:121:10: warning:inconclusive: Possible null pointer dereference: sk2 [nullPointer]
       (!sk2->sk_reuse || !sk->sk_reuse))
         ^
command lines/platypusPrompt/tools/network/ping.c:82:21: note: Assignment 'sk2=NULL', assigned value is 0
 struct sock *sk2 = NULL;
                    ^
command lines/platypusPrompt/tools/network/ping.c:121:10: note: Null pointer dereference
       (!sk2->sk_reuse || !sk->sk_reuse))
         ^
command lines/platypusPrompt/tools/productivity/calculator/calc.c:9:12: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 if (input == "calc" || "calculator"){
           ^
command lines/platypusPrompt/tools/productivity/calculator/calc.c:9:25: warning: Conversion of string literal "calculator" to bool always evaluates to true. [incorrectStringBooleanError]
 if (input == "calc" || "calculator"){
                        ^
desktop tools/games/knavalbattle/src/ai/smartai.cpp:313:73: style:inconclusive: Function 'notify' argument 3 names different: declaration 'hit' definition 'info'. [funcArgNamesDifferent]
void SmartAI::notify(Sea::Player player, const Coord& c, const HitInfo& info)
                                                                        ^
desktop tools/games/knavalbattle/src/ai/smartai.h:41:68: note: Function 'notify' argument 3 names different: declaration 'hit' definition 'info'.
    void notify(Sea::Player player, const Coord& c, const HitInfo& hit) override;
                                                                   ^
desktop tools/games/knavalbattle/src/ai/smartai.cpp:313:73: note: Function 'notify' argument 3 names different: declaration 'hit' definition 'info'.
void SmartAI::notify(Sea::Player player, const Coord& c, const HitInfo& info)
                                                                        ^
desktop tools/games/knavalbattle/src/hitinfo.h:30:5: style: Struct 'HitInfo' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    HitInfo(Type type)
    ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid < Element >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid < Element >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid < bool >' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid < bool >' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:29:5: style: Class 'Grid < Element >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Grid(const Coord& size);
    ^
desktop tools/games/knavalbattle/src/grid.h:29:5: style: Class 'Grid < bool >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Grid(const Coord& size);
    ^
desktop tools/games/knavalbattle/src/battlefield.cpp:280:43: style:inconclusive: Function 'isNearShip' argument 1 names different: declaration 'c' definition 'pos'. [funcArgNamesDifferent]
bool BattleField::isNearShip(const Coord& pos) const
                                          ^
desktop tools/games/knavalbattle/src/battlefield.h:57:34: note: Function 'isNearShip' argument 1 names different: declaration 'c' definition 'pos'.
    bool isNearShip(const Coord& c) const;
                                 ^
desktop tools/games/knavalbattle/src/battlefield.cpp:280:43: note: Function 'isNearShip' argument 1 names different: declaration 'c' definition 'pos'.
bool BattleField::isNearShip(const Coord& pos) const
                                          ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:23:18: warning: Member variable 'BattleFieldView::m_player' is not initialized in the constructor. [uninitMemberVar]
BattleFieldView::BattleFieldView(QWidget* parent, KBSRenderer* renderer, const QString& bgID, int gridSize)
                 ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:23:18: warning: Member variable 'BattleFieldView::m_status' is not initialized in the constructor. [uninitMemberVar]
BattleFieldView::BattleFieldView(QWidget* parent, KBSRenderer* renderer, const QString& bgID, int gridSize)
                 ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid' does not have a copy constructor which is recommended since it has dynamic memory/resource allocation(s). [noCopyConstructor]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:46:5: warning: Class 'Grid' does not have a operator= which is recommended since it has dynamic memory/resource allocation(s). [noOperatorEq]
    m_grid = new T[m_size.x * m_size.y];
    ^
desktop tools/games/knavalbattle/src/grid.h:29:5: style: Class 'Grid' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Grid(const Coord& size);
    ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:84:13: style: Same expression used in consecutive assignments of 'width' and 'height'. [duplicateAssignExpression]
        int width   = spacing * m_gridSize;
            ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:85:13: note: Same expression used in consecutive assignments of 'width' and 'height'.
        int height  = spacing * m_gridSize;
            ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:84:13: note: Same expression used in consecutive assignments of 'width' and 'height'.
        int width   = spacing * m_gridSize;
            ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:193:57: style:inconclusive: Function 'addSprite' argument 2 names different: declaration 'ship' definition 'sprite'. [funcArgNamesDifferent]
void BattleFieldView::addSprite(const Coord& c, Sprite* sprite)
                                                        ^
desktop tools/games/knavalbattle/src/battlefieldview.h:77:44: note: Function 'addSprite' argument 2 names different: declaration 'ship' definition 'sprite'.
    void addSprite(const Coord& c, Sprite* ship);
                                           ^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:193:57: note: Function 'addSprite' argument 2 names different: declaration 'ship' definition 'sprite'.
void BattleFieldView::addSprite(const Coord& c, Sprite* sprite)
                                                        ^
desktop tools/games/knavalbattle/src/coord.h:39:1: error: There is an unknown macro here somewhere. Configuration is required. If Q_DECLARE_METATYPE is a macro then please configure it. [unknownMacro]
Q_DECLARE_METATYPE(Coord)
^
desktop tools/games/knavalbattle/src/chatwidget.cpp:57:52: style:inconclusive: Function 'eventFilter' argument 2 names different: declaration 'e' definition 'event'. [funcArgNamesDifferent]
bool ChatWidget::eventFilter(QObject* obj, QEvent* event)
                                                   ^
desktop tools/games/knavalbattle/src/chatwidget.h:42:40: note: Function 'eventFilter' argument 2 names different: declaration 'e' definition 'event'.
    bool eventFilter(QObject*, QEvent* e) override;
                                       ^
desktop tools/games/knavalbattle/src/chatwidget.cpp:57:52: note: Function 'eventFilter' argument 2 names different: declaration 'e' definition 'event'.
bool ChatWidget::eventFilter(QObject* obj, QEvent* event)
                                                   ^
desktop tools/games/knavalbattle/src/chatwidget.cpp:85:62: style:inconclusive: Function 'display' argument 2 names different: declaration 'message' definition 'text'. [funcArgNamesDifferent]
void ChatWidget::display(const QString& nick, const QString& text)
                                                             ^
desktop tools/games/knavalbattle/src/chatwidget.h:39:54: note: Function 'display' argument 2 names different: declaration 'message' definition 'text'.
    void display(const QString& nick, const QString& message);
                                                     ^
desktop tools/games/knavalbattle/src/chatwidget.cpp:85:62: note: Function 'display' argument 2 names different: declaration 'message' definition 'text'.
void ChatWidget::display(const QString& nick, const QString& text)
                                                             ^
desktop tools/games/knavalbattle/src/chatwidget.cpp:90:41: style:inconclusive: Function 'display' argument 1 names different: declaration 'message' definition 'text'. [funcArgNamesDifferent]
void ChatWidget::display(const QString& text)
                                        ^
desktop tools/games/knavalbattle/src/chatwidget.h:40:33: note: Function 'display' argument 1 names different: declaration 'message' definition 'text'.
    void display(const QString& message);
                                ^
desktop tools/games/knavalbattle/src/chatwidget.cpp:90:41: note: Function 'display' argument 1 names different: declaration 'message' definition 'text'.
void ChatWidget::display(const QString& text)
                                        ^
desktop tools/games/knavalbattle/src/controller.cpp:22:99: style:inconclusive: Function 'Controller' argument 3 names different: declaration 'battleConfiguration' definition 'battleShipsConfiguration'. [funcArgNamesDifferent]
Controller::Controller(QObject* parent, AudioPlayer* audioPlayer, const BattleShipsConfiguration& battleShipsConfiguration)
                                                                                                  ^
desktop tools/games/knavalbattle/src/controller.h:48:104: note: Function 'Controller' argument 3 names different: declaration 'battleConfiguration' definition 'battleShipsConfiguration'.
    explicit Controller(QObject* parent, AudioPlayer* audioPlayer = 0, const BattleShipsConfiguration& battleConfiguration = BattleShipsConfiguration::defaultSingleShipsConfiguration(true));
                                                                                                       ^
desktop tools/games/knavalbattle/src/controller.cpp:22:99: note: Function 'Controller' argument 3 names different: declaration 'battleConfiguration' definition 'battleShipsConfiguration'.
Controller::Controller(QObject* parent, AudioPlayer* audioPlayer, const BattleShipsConfiguration& battleShipsConfiguration)
                                                                                                  ^
desktop tools/games/knavalbattle/src/entity.cpp:26:37: style:inconclusive: Function 'setNick' argument 1 names different: declaration 'nick' definition 'nickname'. [funcArgNamesDifferent]
void Entity::setNick(const QString& nickname)
                                    ^
desktop tools/games/knavalbattle/src/entity.h:64:41: note: Function 'setNick' argument 1 names different: declaration 'nick' definition 'nickname'.
    virtual void setNick(const QString& nick);
                                        ^
desktop tools/games/knavalbattle/src/entity.cpp:26:37: note: Function 'setNick' argument 1 names different: declaration 'nick' definition 'nickname'.
void Entity::setNick(const QString& nickname)
                                    ^
desktop tools/games/knavalbattle/src/kbsrenderer.cpp:39:16: style: The statement 'if (m_size!=sz) m_size=sz' is logically equivalent to 'm_size=sz'. [duplicateConditionalAssign]
    if (m_size != sz) {
               ^
desktop tools/games/knavalbattle/src/kbsrenderer.cpp:40:16: note: Assignment 'm_size=sz'
        m_size = sz;
               ^
desktop tools/games/knavalbattle/src/kbsrenderer.cpp:39:16: note: Condition 'm_size!=sz' is redundant
    if (m_size != sz) {
               ^
desktop tools/games/knavalbattle/src/kbsrenderer.cpp:57:42: style:inconclusive: Function 'toReal' argument 1 names different: declaration 'p' definition 'c'. [funcArgNamesDifferent]
QPointF KBSRenderer::toReal(const Coord& c) const
                                         ^
desktop tools/games/knavalbattle/src/kbsrenderer.h:42:33: note: Function 'toReal' argument 1 names different: declaration 'p' definition 'c'.
    QPointF toReal(const Coord& p) const;
                                ^
desktop tools/games/knavalbattle/src/kbsrenderer.cpp:57:42: note: Function 'toReal' argument 1 names different: declaration 'p' definition 'c'.
QPointF KBSRenderer::toReal(const Coord& c) const
                                         ^
desktop tools/games/knavalbattle/src/message.cpp:73:55: style:inconclusive: Function 'NotificationMessage' argument 1 names different: declaration 'm_move' definition 'move'. [funcArgNamesDifferent]
NotificationMessage::NotificationMessage(const Coord& move,
                                                      ^
desktop tools/games/knavalbattle/src/message.h:103:38: note: Function 'NotificationMessage' argument 1 names different: declaration 'm_move' definition 'move'.
    NotificationMessage(const Coord& m_move, bool hit, bool death,
                                     ^
desktop tools/games/knavalbattle/src/message.cpp:73:55: note: Function 'NotificationMessage' argument 1 names different: declaration 'm_move' definition 'move'.
NotificationMessage::NotificationMessage(const Coord& move,
                                                      ^
desktop tools/games/knavalbattle/src/message.cpp:89:41: style:inconclusive: Function 'ChatMessage' argument 1 names different: declaration 'nick' definition 'nickname'. [funcArgNamesDifferent]
ChatMessage::ChatMessage(const QString& nickname, const QString& chat)
                                        ^
desktop tools/games/knavalbattle/src/message.h:158:41: note: Function 'ChatMessage' argument 1 names different: declaration 'nick' definition 'nickname'.
    explicit ChatMessage(const QString& nick, const QString& chat);
                                        ^
desktop tools/games/knavalbattle/src/message.cpp:89:41: note: Function 'ChatMessage' argument 1 names different: declaration 'nick' definition 'nickname'.
ChatMessage::ChatMessage(const QString& nickname, const QString& chat)
                                        ^
desktop tools/games/knavalbattle/src/networkentity.cpp:22:88: style:inconclusive: Function 'NetworkEntity' argument 4 names different: declaration 'device' definition 'protocol'. [funcArgNamesDifferent]
NetworkEntity::NetworkEntity(Sea::Player player, Sea* sea, SeaView* seaview, Protocol* protocol, bool client)
                                                                                       ^
desktop tools/games/knavalbattle/src/networkentity.h:30:77: note: Function 'NetworkEntity' argument 4 names different: declaration 'device' definition 'protocol'.
    NetworkEntity(Sea::Player player, Sea* sea, SeaView* seaview, Protocol* device, bool client);
                                                                            ^
desktop tools/games/knavalbattle/src/networkentity.cpp:22:88: note: Function 'NetworkEntity' argument 4 names different: declaration 'device' definition 'protocol'.
NetworkEntity::NetworkEntity(Sea::Player player, Sea* sea, SeaView* seaview, Protocol* protocol, bool client)
                                                                                       ^
desktop tools/games/knavalbattle/src/networkentity.cpp:47:45: style:inconclusive: Function 'notifyShips' argument 1 names different: declaration 'winner' definition 'player'. [funcArgNamesDifferent]
void NetworkEntity::notifyShips(Sea::Player player)
                                            ^
desktop tools/games/knavalbattle/src/networkentity.h:40:34: note: Function 'notifyShips' argument 1 names different: declaration 'winner' definition 'player'.
    void notifyShips(Sea::Player winner) override;
                                 ^
desktop tools/games/knavalbattle/src/networkentity.cpp:47:45: note: Function 'notifyShips' argument 1 names different: declaration 'winner' definition 'player'.
void NetworkEntity::notifyShips(Sea::Player player)
                                            ^
desktop tools/games/knavalbattle/src/playerentity.cpp:201:59: style:inconclusive: Function 'notifyNick' argument 2 names different: declaration 'text' definition 'nickname'. [funcArgNamesDifferent]
void PlayerEntity::notifyNick(Sea::Player, const QString& nickname)
                                                          ^
desktop tools/games/knavalbattle/src/playerentity.h:40:56: note: Function 'notifyNick' argument 2 names different: declaration 'text' definition 'nickname'.
    void notifyNick(Sea::Player player, const QString& text) override;
                                                       ^
desktop tools/games/knavalbattle/src/playerentity.cpp:201:59: note: Function 'notifyNick' argument 2 names different: declaration 'text' definition 'nickname'.
void PlayerEntity::notifyNick(Sea::Player, const QString& nickname)
                                                          ^
desktop tools/games/knavalbattle/src/sea.cpp:93:14: style: Variable 'e' can be declared with const [constVariable]
    Element& e = otherField()->get(pos);
             ^
desktop tools/games/knavalbattle/src/ships.cpp:55:69: style: Parameter 'ships' can be declared with const [constParameter]
BattleShipsConfiguration& BattleShipsConfiguration::addShips(Ships& ships)
                                                                    ^
fs/hpfs/hpfs_fn.h:109:47: portability: '(void*)de' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  return le32_to_cpu(*(__le32 *) ((void *) de + le16_to_cpu(de->length) - 4));
                                              ^
fs/hpfs/hpfs_fn.h:124:25: portability: '(void*)dnode' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  return (void *) dnode + le32_to_cpu(dnode->first_free);
                        ^
fs/hpfs/hpfs_fn.h:132:22: portability: '(void*)de' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  return (void *) de + le16_to_cpu(de->length);
                     ^
fs/hpfs/anode.c:342:8: style: The scope of the variable 'data' can be reduced. [variableScope]
 char *data;
       ^
fs/hpfs/anode.c:344:11: style: The scope of the variable 'l' can be reduced. [variableScope]
 unsigned l;
          ^
fs/hpfs/anode.c:365:8: style: The scope of the variable 'data' can be reduced. [variableScope]
 char *data;
       ^
fs/hpfs/anode.c:367:11: style: The scope of the variable 'l' can be reduced. [variableScope]
 unsigned l;
          ^
fs/hpfs/buffer.c:223:40: portability: 'qbh->data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);
                                       ^
fs/hpfs/buffer.c:224:40: portability: 'qbh->data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);
                                       ^
fs/hpfs/buffer.c:225:40: portability: 'qbh->data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);
                                       ^
fs/hpfs/buffer.c:226:40: portability: 'qbh->data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);
                                       ^
fs/hpfs/dnode.c:591:34: portability: '(void*)de' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   *(dnode_secno *) ((void *) de + le16_to_cpu(de->length) - 4) = down;
                                 ^
fs/hpfs/dnode.c:671:31: portability: '(void*)del' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    *(__le32 *) ((void *) del + le16_to_cpu(del->length) - 4) = cpu_to_le32(down);
                              ^
fs/hpfs/dnode.c:687:33: portability: '(void*)de_prev' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  *(__le32 *) ((void *) de_prev + le16_to_cpu(de_prev->length) - 4) = cpu_to_le32(ndown);
                                ^
fs/hpfs/ea.c:270:9: style: Local variable 'data' shadows outer argument [shadowArgument]
  char *data;
        ^
fs/hpfs/ea.c:191:16: note: Shadowed declaration
   const char *data, int size)
               ^
fs/hpfs/ea.c:270:9: note: Shadow variable
  char *data;
        ^
fs/hpfs/inode.c:50:8: style: The scope of the variable 'ea' can be reduced. [variableScope]
 void *ea;
       ^
fs/hpfs/namei.c:554:7: style: Local variable 'r' shadows outer variable [shadowVariable]
  int r;
      ^
fs/hpfs/namei.c:524:6: note: Shadowed declaration
 int r;
     ^
fs/hpfs/namei.c:554:7: note: Shadow variable
  int r;
      ^
fs/ntfs/ntfs.h:144:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  x >>= 1;
  ^
fs/ntfs/aops.c:83:17: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   memset(kaddr + bh_offset(bh) + ofs, 0,
                ^
fs/ntfs/ntfs.h:144:5: style: Variable 'x' is assigned a value that is never used. [unreadVariable]
  x >>= 1;
    ^
fs/ntfs/aops.c:1716:29: style: The scope of the variable 'bh_ofs' can be reduced. [variableScope]
 unsigned int end, bh_size, bh_ofs;
                            ^
fs/ntfs/attrib.c:696:52: style:inconclusive: Function 'load_attribute_list' argument 2 names different: declaration 'rl' definition 'runlist'. [funcArgNamesDifferent]
int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,
                                                   ^
fs/ntfs/attrib.h:64:59: note: Function 'load_attribute_list' argument 2 names different: declaration 'rl' definition 'runlist'.
extern int load_attribute_list(ntfs_volume *vol, runlist *rl, u8 *al_start,
                                                          ^
fs/ntfs/attrib.c:696:52: note: Function 'load_attribute_list' argument 2 names different: declaration 'rl' definition 'runlist'.
int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,
                                                   ^
fs/ntfs/attrib.c:701:18: warning: Either the condition '!al' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
 u8 *al_end = al + initialized_size;
                 ^
fs/ntfs/attrib.c:711:26: note: Assuming that condition '!al' is not redundant
 if (!vol || !runlist || !al || size <= 0 || initialized_size < 0 ||
                         ^
fs/ntfs/attrib.c:701:18: note: Null pointer addition
 u8 *al_end = al + initialized_size;
                 ^
fs/ntfs/attrib.c:1803:31: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 flush_dcache_mft_record_page(ctx->ntfs_ino);
                              ^
fs/ntfs/attrib.c:1806:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/attrib.c:1803:31: note: Null pointer dereference
 flush_dcache_mft_record_page(ctx->ntfs_ino);
                              ^
fs/ntfs/attrib.c:1804:24: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 mark_mft_record_dirty(ctx->ntfs_ino);
                       ^
fs/ntfs/attrib.c:1806:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/attrib.c:1804:24: note: Null pointer dereference
 mark_mft_record_dirty(ctx->ntfs_ino);
                       ^
fs/ntfs/attrib.c:2199:9: warning: Either the condition '!rl' is redundant or there is possible null pointer dereference: rl. [nullPointerRedundantCheck]
 while (rl->lcn < 0 && rl > ni->runlist.rl)
        ^
fs/ntfs/attrib.c:2165:15: note: Assuming that condition '!rl' is not redundant
 if (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||
              ^
fs/ntfs/attrib.c:2199:9: note: Null pointer dereference
 while (rl->lcn < 0 && rl > ni->runlist.rl)
        ^
fs/ntfs/compress.c:198:7: style: The scope of the variable 'i' can be reduced. [variableScope]
  int i;
      ^
fs/ntfs/compress.c:187:2: style: Same expression on both sides of '-'. [duplicateExpression]
 ntfs_debug("Beginning sub-block at offset = 0x%zx in the cb.",
 ^
fs/ntfs/compress.c:163:11: note: 'cb' is assigned value 'cb_start' here.
 u8 *cb = cb_start; /* Current position in cb. */
          ^
fs/ntfs/compress.c:187:2: note: Same expression on both sides of '-'.
 ntfs_debug("Beginning sub-block at offset = 0x%zx in the cb.",
 ^
fs/ntfs/file.c:290:6: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 m = ctx->mrec;
     ^
fs/ntfs/file.c:297:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/file.c:290:6: note: Null pointer dereference
 m = ctx->mrec;
     ^
fs/ntfs/file.c:291:6: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 a = ctx->attr;
     ^
fs/ntfs/file.c:297:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/file.c:291:6: note: Null pointer dereference
 a = ctx->attr;
     ^
fs/ntfs/file.c:295:31: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 flush_dcache_mft_record_page(ctx->ntfs_ino);
                              ^
fs/ntfs/file.c:297:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/file.c:295:31: note: Null pointer dereference
 flush_dcache_mft_record_page(ctx->ntfs_ino);
                              ^
fs/ntfs/file.c:296:24: warning: Either the condition 'if(ctx)' is redundant or there is possible null pointer dereference: ctx. [nullPointerRedundantCheck]
 mark_mft_record_dirty(ctx->ntfs_ino);
                       ^
fs/ntfs/file.c:297:5: note: Assuming that condition 'if(ctx)' is not redundant
 if (ctx)
    ^
fs/ntfs/file.c:296:24: note: Null pointer dereference
 mark_mft_record_dirty(ctx->ntfs_ino);
                       ^
fs/ntfs/file.c:206:5: style: Variable 'm' is reassigned a value before the old one has been used. [redundantAssignment]
  m = NULL;
    ^
fs/ntfs/file.c:193:5: note: m is assigned
  m = ctx->mrec;
    ^
fs/ntfs/file.c:206:5: note: m is overwritten
  m = NULL;
    ^
fs/ntfs/file.c:1151:25: style: Variable 'status.runlist_merged' is reassigned a value before the old one has been used. [redundantAssignment]
  status.runlist_merged = 0;
                        ^
fs/ntfs/file.c:1003:25: note: status.runlist_merged is assigned
  status.runlist_merged = 1;
                        ^
fs/ntfs/file.c:1151:25: note: status.runlist_merged is overwritten
  status.runlist_merged = 0;
                        ^
fs/ntfs/file.c:1152:26: style: Variable 'status.mft_attr_mapped' is reassigned a value before the old one has been used. [redundantAssignment]
  status.mft_attr_mapped = 0;
                         ^
fs/ntfs/file.c:1022:26: note: status.mft_attr_mapped is assigned
  status.mft_attr_mapped = 1;
                         ^
fs/ntfs/file.c:1152:26: note: status.mft_attr_mapped is overwritten
  status.mft_attr_mapped = 0;
                         ^
fs/ntfs/file.c:1153:21: style: Variable 'status.mp_rebuilt' is reassigned a value before the old one has been used. [redundantAssignment]
  status.mp_rebuilt = 0;
                    ^
fs/ntfs/file.c:1094:21: note: status.mp_rebuilt is assigned
  status.mp_rebuilt = 1;
                    ^
fs/ntfs/file.c:1153:21: note: status.mp_rebuilt is overwritten
  status.mp_rebuilt = 0;
                    ^
fs/ntfs/inode.c:1241:30: style: Redundant condition: ni->type==AT_DATA. 'ni->type!=AT_DATA || (ni->type==AT_DATA && ni->name_len)' is equivalent to 'ni->type!=AT_DATA || ni->name_len' [redundantCondition]
   if ((ni->type != AT_DATA) || (ni->type == AT_DATA &&
                             ^
fs/ntfs/inode.c:1849:22: style: Local variable 'es' shadows outer variable [shadowVariable]
  static const char *es = "  Not allowed.  $MFT is corrupt.  "
                     ^
fs/ntfs/inode.c:2317:20: note: Shadowed declaration
static const char *es = "  Leaving inconsistent metadata.  Unmount and run "
                   ^
fs/ntfs/inode.c:1849:22: note: Shadow variable
  static const char *es = "  Not allowed.  $MFT is corrupt.  "
                     ^
fs/ntfs/mft.c:1134:15: style: The scope of the variable 'page_ofs' can be reduced. [variableScope]
 unsigned int page_ofs, size;
              ^
fs/ntfs/mft.c:1134:25: style: The scope of the variable 'size' can be reduced. [variableScope]
 unsigned int page_ofs, size;
                        ^
fs/ntfs/runlist.c:1761:11: style: Variable 'old_size' is assigned a value that is never used. [unreadVariable]
  old_size++;
          ^
fs/ntfs/runlist.c:1866:11: style: Variable 'old_size' is assigned a value that is never used. [unreadVariable]
 old_size += 2;
          ^
fs/ntfs/super.c:3133:6: style: Condition 'err' is always false [knownConditionTrueFalse]
 if (err) {
     ^
fs/ntfs/super.c:3132:19: note: Assignment 'err=ntfs_sysctl(1)', assigned value is 0
 err = ntfs_sysctl(1);
                  ^
fs/ntfs/super.c:3133:6: note: Condition 'err' is always false
 if (err) {
     ^
fs/ntfs/super.c:2449:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
fs/ntfs/super.c:2529:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
fs/ufs/balloc.c:328:22: style: The scope of the variable 'bh' can be reduced. [variableScope]
 struct buffer_head *bh;
                     ^
fs/ufs/balloc.c:766:17: style: The scope of the variable 'cp' can be reduced. [variableScope]
 unsigned char *cp;
                ^
fs/ufs/balloc.c:811:16: style: The scope of the variable 'want' can be reduced. [variableScope]
 unsigned pos, want, blockmap, mask, end;
               ^
fs/ufs/balloc.c:811:22: style: The scope of the variable 'blockmap' can be reduced. [variableScope]
 unsigned pos, want, blockmap, mask, end;
                     ^
fs/ufs/cylinder.c:133:11: style: The scope of the variable 'cg' can be reduced. [variableScope]
 unsigned cg, i, j;
          ^
fs/ufs/ialloc.c:133:22: style: The scope of the variable 'bh' can be reduced. [variableScope]
 struct buffer_head *bh;
                     ^
fs/ufs/inode.c:53:17: style: int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information. [truncLongCastAssignment]
  double_blocks = (1 << (ptrs_bits * 2));
                ^
fs/ufs/super.c:648:27: style: The scope of the variable 'ubh' can be reduced. [variableScope]
 struct ufs_buffer_head * ubh;
                          ^
fs/ufs/super.c:732:16: style: The scope of the variable 'delay' can be reduced. [variableScope]
 unsigned long delay;
               ^
fs/ufs/super.c:771:9: portability: Shifting signed 64-bit value by 63 bits is implementation-defined behaviour. See condition at line 767. [shiftTooManyBitsSigned]
   (1LL << (3*bits));
        ^
fs/ufs/super.c:767:11: note: Assuming that condition 'bits>21' is not redundant
 if (bits > 21)
          ^
fs/ufs/super.c:771:9: note: Shift
   (1LL << (3*bits));
        ^
kernel/panic.c:494:11: style: Condition 'spin_counter' is always true [knownConditionTrueFalse]
   while (spin_counter) {
          ^
kernel/panic.c:483:7: note: Assuming that condition '!spin_counter' is not redundant
  if (!spin_counter) {
      ^
kernel/panic.c:494:11: note: Condition 'spin_counter' is always true
   while (spin_counter) {
          ^
kernel/selfdestruct.c:8:12: warning: String literal compared with variable 'input'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
 if (input == "selfdestruct"){
           ^
kernel/selfdestruct.c:12:12: warning: String literal compared with variable 'sure'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
  if (sure == "y" || "Y" || "n" || "N"){
           ^
kernel/selfdestruct.c:16:18: warning: String literal compared with variable 'extrasure'. Did you intend to use strcmp() instead? [literalWithCharPtrCompare]
   if (extrasure == "Y" || "y" || "N" || "n"){
                 ^
kernel/selfdestruct.c:12:22: warning: Conversion of string literal "Y" to bool always evaluates to true. [incorrectStringBooleanError]
  if (sure == "y" || "Y" || "n" || "N"){
                     ^
kernel/selfdestruct.c:12:29: warning: Conversion of string literal "n" to bool always evaluates to true. [incorrectStringBooleanError]
  if (sure == "y" || "Y" || "n" || "N"){
                            ^
kernel/selfdestruct.c:12:36: warning: Conversion of string literal "N" to bool always evaluates to true. [incorrectStringBooleanError]
  if (sure == "y" || "Y" || "n" || "N"){
                                   ^
kernel/selfdestruct.c:16:28: warning: Conversion of string literal "y" to bool always evaluates to true. [incorrectStringBooleanError]
   if (extrasure == "Y" || "y" || "N" || "n"){
                           ^
kernel/selfdestruct.c:16:35: warning: Conversion of string literal "N" to bool always evaluates to true. [incorrectStringBooleanError]
   if (extrasure == "Y" || "y" || "N" || "n"){
                                  ^
kernel/selfdestruct.c:16:42: warning: Conversion of string literal "n" to bool always evaluates to true. [incorrectStringBooleanError]
   if (extrasure == "Y" || "y" || "N" || "n"){
                                         ^
memory/backing-dev.c:757:27: style: The scope of the variable 'bdi' can be reduced. [variableScope]
 struct backing_dev_info *bdi;
                          ^
memory/backing-dev.c:615:24: style: The scope of the variable 'wb' can be reduced. [variableScope]
 struct bdi_writeback *wb;
                       ^
memory/balloon_compaction.c:179:16: style: The scope of the variable 'flags' can be reduced. [variableScope]
 unsigned long flags;
               ^
memory/balloon_compaction.c:96:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION' since the value of 'CONFIG_BALLOON_COMPACTION' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_BALLOON_COMPACTION) &&
^
memory/cleancache.c:147:8: style: The scope of the variable 'fhfn' can be reduced. [variableScope]
 int (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);
       ^
memory/cleancache.c:148:6: style: The scope of the variable 'len' can be reduced. [variableScope]
 int len = 0, maxlen = CLEANCACHE_KEY_MAX;
     ^
memory/cleancache.c:148:10: style: Variable 'len' is assigned a value that is never used. [unreadVariable]
 int len = 0, maxlen = CLEANCACHE_KEY_MAX;
         ^
memory/cma.c:203:3: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  snprintf(cma->name, CMA_MAX_NAME,  "cma%d\n", cma_area_count);
  ^
memory/cma.c:416:30: style: The scope of the variable 'bitmap_no' can be reduced. [variableScope]
 unsigned long bitmap_maxno, bitmap_no, bitmap_count;
                             ^
memory/cma.c:417:9: style: The scope of the variable 'i' can be reduced. [variableScope]
 size_t i;
        ^
memory/cma.c:374:16: style: The scope of the variable 'next_zero_bit' can be reduced. [variableScope]
 unsigned long next_zero_bit, next_set_bit, nr_zero;
               ^
memory/cma.c:374:31: style: The scope of the variable 'next_set_bit' can be reduced. [variableScope]
 unsigned long next_zero_bit, next_set_bit, nr_zero;
                              ^
memory/cma.c:374:45: style: The scope of the variable 'nr_zero' can be reduced. [variableScope]
 unsigned long next_zero_bit, next_set_bit, nr_zero;
                                            ^
memory/cma.c:376:16: style: The scope of the variable 'nr_part' can be reduced. [variableScope]
 unsigned long nr_part, nr_total = 0;
               ^
memory/cma_debug.c:53:16: style: The scope of the variable 'start' can be reduced. [variableScope]
 unsigned long start, end = 0;
               ^
memory/compaction.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 14 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/compaction.c:89:18: style: The scope of the variable 'order' can be reduced. [variableScope]
 unsigned int i, order, nr_pages;
                 ^
memory/compaction.c:89:25: style: The scope of the variable 'nr_pages' can be reduced. [variableScope]
 unsigned int i, order, nr_pages;
                        ^
memory/compaction.c:1818:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/compaction.c:2168:6: style: The scope of the variable 'fragindex' can be reduced. [variableScope]
 int fragindex;
     ^
memory/compaction.c:2712:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/compaction.c:1151:70: style:inconclusive: Function 'isolate_migratepages_range' argument 2 names different: declaration 'low_pfn' definition 'start_pfn'. [funcArgNamesDifferent]
isolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,
                                                                     ^
memory/internal.h:266:21: note: Function 'isolate_migratepages_range' argument 2 names different: declaration 'low_pfn' definition 'start_pfn'.
      unsigned long low_pfn, unsigned long end_pfn);
                    ^
memory/compaction.c:1151:70: note: Function 'isolate_migratepages_range' argument 2 names different: declaration 'low_pfn' definition 'start_pfn'.
isolate_migratepages_range(struct compact_control *cc, unsigned long start_pfn,
                                                                     ^
memory/compaction.c:599:23: style: Local variable 'order' shadows outer variable [shadowVariable]
   const unsigned int order = compound_order(page);
                      ^
memory/compaction.c:565:15: note: Shadowed declaration
 unsigned int order;
              ^
memory/compaction.c:599:23: note: Shadow variable
   const unsigned int order = compound_order(page);
                      ^
memory/compaction.c:2917:22: style: Local variable 'kcompactd' shadows outer function [shadowFunction]
 struct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;
                     ^
memory/compaction.c:2837:12: note: Shadowed declaration
static int kcompactd(void *p)
           ^
memory/compaction.c:2917:22: note: Shadow variable
 struct task_struct *kcompactd = NODE_DATA(nid)->kcompactd;
                     ^
memory/debug.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/debug_vm_pgtable.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 14 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/debug_vm_pgtable.c:89:6: style: Redundant initialization for 'pte'. The initialized value is overwritten before it is read. [redundantInitialization]
 pte = pfn_pte(pfn, prot);
     ^
memory/debug_vm_pgtable.c:80:12: note: pte is initialized
 pte_t pte = pfn_pte(pfn, prot);
           ^
memory/debug_vm_pgtable.c:89:6: note: pte is overwritten
 pte = pfn_pte(pfn, prot);
     ^
memory/debug_vm_pgtable.c:170:6: style: Redundant initialization for 'pmd'. The initialized value is overwritten before it is read. [redundantInitialization]
 pmd = pfn_pmd(pfn, prot);
     ^
memory/debug_vm_pgtable.c:159:12: note: pmd is initialized
 pmd_t pmd = pfn_pmd(pfn, prot);
           ^
memory/debug_vm_pgtable.c:170:6: note: pmd is overwritten
 pmd = pfn_pmd(pfn, prot);
     ^
memory/dmapool.c:214:24: portability: 'page->vaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  *(int *)(page->vaddr + offset) = next;
                       ^
memory/dmapool.c:343:38: portability: 'page->vaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 page->offset = *(int *)(page->vaddr + offset);
                                     ^
memory/dmapool.c:344:18: portability: 'page->vaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 retval = offset + page->vaddr;
                 ^
memory/dmapool.c:441:34: portability: 'page->vaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    chain = *(int *)(page->vaddr + chain);
                                 ^
memory/early_ioremap.c:188:20: error: Array 'prev_size[0]' accessed at index -1, which is out of bounds. [negativeIndex]
 if (WARN(prev_size[slot] != size,
                   ^
memory/early_ioremap.c:176:10: note: Assignment 'slot=-1', assigned value is -1
 slot = -1;
         ^
memory/early_ioremap.c:184:10: note: Assuming condition is false
 if (WARN(slot < 0, "early_iounmap(%p, %08lx) not found slot\n",
         ^
memory/early_ioremap.c:188:20: note: Negative array index
 if (WARN(prev_size[slot] != size,
                   ^
memory/early_ioremap.c:190:31: error:inconclusive: Array 'prev_size[0]' accessed at index -1, which is out of bounds. [negativeIndex]
   addr, size, slot, prev_size[slot]))
                              ^
memory/early_ioremap.c:176:10: note: Assignment 'slot=-1', assigned value is -1
 slot = -1;
         ^
memory/early_ioremap.c:184:10: note: Assuming condition is false
 if (WARN(slot < 0, "early_iounmap(%p, %08lx) not found slot\n",
         ^
memory/early_ioremap.c:190:31: note: Negative array index
   addr, size, slot, prev_size[slot]))
                              ^
memory/early_ioremap.c:256:16: style: The scope of the variable 'slop' can be reduced. [variableScope]
 unsigned long slop, clen;
               ^
memory/early_ioremap.c:256:22: style: The scope of the variable 'clen' can be reduced. [variableScope]
 unsigned long slop, clen;
                     ^
memory/early_ioremap.c:257:8: style: The scope of the variable 'p' can be reduced. [variableScope]
 char *p;
       ^
memory/early_ioremap.c:267:8: portability: 'dest' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  dest += clen;
       ^
memory/early_ioremap.c:236:0: information: Skipping configuration 'CONFIG_MMU;FIXMAP_PAGE_RO' since the value of 'FIXMAP_PAGE_RO' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
           FIXMAP_PAGE_RO);
^
memory/filemap.c:510:6: style: The scope of the variable 'nr_pages' can be reduced. [variableScope]
 int nr_pages;
     ^
memory/filemap.c:3249:7: style: The scope of the variable 'pathname' can be reduced. [variableScope]
 char pathname[128];
      ^
memory/filemap.c:3250:8: style: The scope of the variable 'path' can be reduced. [variableScope]
 char *path;
       ^
memory/filemap.c:1326:37: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  return wait->flags & WQ_FLAG_DONE ? 0 : -EINTR;
                                    ^
memory/filemap.c:1328:37: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 return wait->flags & WQ_FLAG_WOKEN ? 0 : -EINTR;
                                    ^
memory/filemap.c:964:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
memory/filemap.c:965:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/frame_vector.c:213:41: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 if (WARN_ON_ONCE(nr_frames > INT_MAX / sizeof(void *) / 2))
                                        ^
memory/frontswap.c:407:13: warning:inconclusive: Possible null pointer dereference: si [nullPointer]
  *swapid = si->type;
            ^
memory/frontswap.c:386:32: note: Assignment 'si=NULL', assigned value is 0
 struct swap_info_struct *si = NULL;
                               ^
memory/frontswap.c:401:35: note: Assuming condition is false
  if (security_vm_enough_memory_mm(current->mm, pages)) {
                                  ^
memory/frontswap.c:407:13: note: Null pointer dereference
  *swapid = si->type;
            ^
memory/frontswap.c:387:6: style: The scope of the variable 'si_frontswap_pages' can be reduced. [variableScope]
 int si_frontswap_pages;
     ^
memory/gup.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 14 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/gup.c:27:22: style: struct member 'follow_page_context::pgmap' is never used. [unusedStructMember]
 struct dev_pagemap *pgmap;
                     ^
memory/gup.c:28:15: style: struct member 'follow_page_context::page_mask' is never used. [unusedStructMember]
 unsigned int page_mask;
              ^
memory/gup.c:2526:0: information: Skipping configuration 'CONFIG_ARCH_HAS_HUGEPD;CONFIG_HAVE_FAST_GUP' since the value of 'CONFIG_HAVE_FAST_GUP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_HAVE_FAST_GUP) ||
^
memory/gup.c:2526:0: information: Skipping configuration 'CONFIG_ARCH_HAS_PTE_DEVMAP;CONFIG_TRANSPARENT_HUGEPAGE;CONFIG_HAVE_FAST_GUP' since the value of 'CONFIG_HAVE_FAST_GUP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_HAVE_FAST_GUP) ||
^
memory/gup.c:2526:0: information: Skipping configuration 'CONFIG_ARCH_HAS_PTE_SPECIAL;CONFIG_HAVE_FAST_GUP' since the value of 'CONFIG_HAVE_FAST_GUP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_HAVE_FAST_GUP) ||
^
memory/gup.c:2526:0: information: Skipping configuration 'CONFIG_HAVE_FAST_GUP' since the value of 'CONFIG_HAVE_FAST_GUP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_HAVE_FAST_GUP) ||
^
memory/gup.c:637:14: style: The scope of the variable 'ptl' can be reduced. [variableScope]
 spinlock_t *ptl;
             ^
memory/gup.c:677:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/gup.c:1369:48: style:inconclusive: Function 'populate_vma_page_range' argument 4 names different: declaration 'nonblocking' definition 'locked'. [funcArgNamesDifferent]
  unsigned long start, unsigned long end, int *locked)
                                               ^
memory/internal.h:342:48: note: Function 'populate_vma_page_range' argument 4 names different: declaration 'nonblocking' definition 'locked'.
  unsigned long start, unsigned long end, int *nonblocking);
                                               ^
memory/gup.c:1369:48: note: Function 'populate_vma_page_range' argument 4 names different: declaration 'nonblocking' definition 'locked'.
  unsigned long start, unsigned long end, int *locked)
                                               ^
memory/gup_test.c:42:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/gup_test.c:64:15: style: The scope of the variable 'index_to_dump' can be reduced. [variableScope]
 unsigned int index_to_dump;
              ^
memory/highmem.c:384:18: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    memset(kaddr + start1, 0, this_end - start1);
                 ^
memory/highmem.c:396:18: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    memset(kaddr + start2, 0, this_end - start2);
                 ^
memory/huge_memory.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/huge_memory.c:1748:24: style: The scope of the variable 'new_ptl' can be reduced. [variableScope]
 spinlock_t *old_ptl, *new_ptl;
                       ^
memory/huge_memory.c:1751:7: style: The scope of the variable 'force_flush' can be reduced. [variableScope]
 bool force_flush = false;
      ^
memory/huge_memory.c:2353:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
memory/huge_memory.c:1820:15: style: Local variable 'entry' shadows outer variable [shadowVariable]
  swp_entry_t entry = pmd_to_swp_entry(*pmd);
              ^
memory/huge_memory.c:1804:8: note: Shadowed declaration
 pmd_t entry;
       ^
memory/huge_memory.c:1820:15: note: Shadow variable
  swp_entry_t entry = pmd_to_swp_entry(*pmd);
              ^
memory/hugetlb.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/hugetlb.c:3370:21: style: Redundant condition: mpol_allowed. '!A || (A && B)' is equivalent to '!A || B' [redundantCondition]
  if (!mpol_allowed ||
                    ^
memory/hugetlb.c:350:7: warning:inconclusive: Possible null pointer dereference: rg [nullPointer]
  if (rg->from < f) {
      ^
memory/hugetlb.c:339:27: note: Assignment 'rg=NULL', assigned value is 0
 struct file_region *rg = NULL, *trg = NULL, *nrg = NULL;
                          ^
memory/hugetlb.c:350:7: note: Null pointer dereference
  if (rg->from < f) {
      ^
memory/hugetlb.c:362:7: warning:inconclusive: Possible null pointer dereference: rg [nullPointer]
  if (rg->from > t)
      ^
memory/hugetlb.c:339:27: note: Assignment 'rg=NULL', assigned value is 0
 struct file_region *rg = NULL, *trg = NULL, *nrg = NULL;
                          ^
memory/hugetlb.c:350:16: note: Assuming condition is false
  if (rg->from < f) {
               ^
memory/hugetlb.c:362:7: note: Null pointer dereference
  if (rg->from > t)
      ^
memory/hugetlb.c:1466:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/hugetlb.c:1805:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/hugetlb.c:2959:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
memory/hugetlb.c:3616:7: style: The scope of the variable 'gbl_reserve' can be reduced. [variableScope]
 long gbl_reserve;
      ^
memory/hugetlb.c:3737:9: style: The scope of the variable 'src_pte' can be reduced. [variableScope]
 pte_t *src_pte, *dst_pte, entry, dst_entry;
        ^
memory/hugetlb.c:3851:9: style: The scope of the variable 'ptep' can be reduced. [variableScope]
 pte_t *ptep;
        ^
memory/hugetlb.c:4940:9: style: The scope of the variable 'ptep' can be reduced. [variableScope]
 pte_t *ptep;
        ^
memory/hugetlb.c:5627:16: style: The scope of the variable 'size' can be reduced. [variableScope]
 unsigned long size, reserved, per_node;
               ^
memory/hugetlb.c:2641:0: information: Skipping configuration 'CONFIG_ARCH_HAS_GIGANTIC_PAGE;CONFIG_CMA;CONFIG_CONTIG_ALLOC' since the value of 'CONFIG_CONTIG_ALLOC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (hstate_is_gigantic(h) && !IS_ENABLED(CONFIG_CONTIG_ALLOC)) {
^
memory/hugetlb.c:2641:0: information: Skipping configuration 'CONFIG_ARCH_HAS_GIGANTIC_PAGE;CONFIG_CONTIG_ALLOC' since the value of 'CONFIG_CONTIG_ALLOC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (hstate_is_gigantic(h) && !IS_ENABLED(CONFIG_CONTIG_ALLOC)) {
^
memory/hugetlb_cgroup.c:202:6: style: The scope of the variable 'idx' can be reduced. [variableScope]
 int idx;
     ^
memory/ioremap.c:88:6: style: Condition '!ioremap_pmd_enabled()' is always true [knownConditionTrueFalse]
 if (!ioremap_pmd_enabled())
     ^
memory/ioremap.c:134:6: style: Condition '!ioremap_pud_enabled()' is always true [knownConditionTrueFalse]
 if (!ioremap_pud_enabled())
     ^
memory/ioremap.c:180:6: style: Condition '!ioremap_p4d_enabled()' is always true [knownConditionTrueFalse]
 if (!ioremap_p4d_enabled())
     ^
memory/kasan/common.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 19 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/common.c:308:29: style: Same value in both branches of ternary operator. [duplicateValueTernary]
 return init ? random_tag() : get_tag(object);
                            ^
memory/kasan/common.c:315:27: style: The scope of the variable 'alloc_meta' can be reduced. [variableScope]
 struct kasan_alloc_meta *alloc_meta;
                          ^
memory/kasan/common.c:417:50: portability: 'object' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 redzone_start = round_up((unsigned long)(object + size),
                                                 ^
memory/kasan/common.c:461:47: portability: 'ptr' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 redzone_start = round_up((unsigned long)(ptr + size),
                                              ^
memory/kasan/common.c:175:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
^
memory/kasan/common.c:280:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_KASAN_GENERIC))
^
memory/kasan/common.c:359:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine))
^
memory/kasan/common.c:175:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
^
memory/kasan/common.c:280:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_KASAN_GENERIC))
^
memory/kasan/common.c:359:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine))
^
memory/kasan/common.c:175:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_SLAB;CONFIG_SLUB' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_KASAN_GENERIC)) {
^
memory/kasan/common.c:280:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_SLAB;CONFIG_SLUB' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_KASAN_GENERIC))
^
memory/kasan/common.c:359:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_SLAB;CONFIG_SLUB' since the value of 'CONFIG_KASAN_GENERIC' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine))
^
memory/kasan/kasan.h:323:43: style: Condition 'ptr_tag!=mem_tag' is always true [knownConditionTrueFalse]
  (ptr_tag != KASAN_TAG_KERNEL && ptr_tag != mem_tag);
                                          ^
memory/kasan/kasan.h:319:15: note: Assignment 'ptr_tag=0', assigned value is 0
 u8 ptr_tag = get_tag(addr);
              ^
memory/kasan/kasan.h:323:43: note: Condition 'ptr_tag!=mem_tag' is always true
  (ptr_tag != KASAN_TAG_KERNEL && ptr_tag != mem_tag);
                                          ^
memory/kasan/common.c:297:34: style: Same value in both branches of ternary operator. [duplicateValueTernary]
  return init ? KASAN_TAG_KERNEL : random_tag();
                                 ^
memory/kasan/generic.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/generic.c:97:16: style: The scope of the variable 'ret' can be reduced. [variableScope]
 unsigned long ret;
               ^
memory/kasan/generic.c:108:9: portability: 'start' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  start += prefix;
        ^
memory/kasan/generic.c:115:9: portability: 'start' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  start += 8;
        ^
memory/kasan/generic.c:128:37: portability: '(void*)addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   kasan_mem_to_shadow((void *)addr + size - 1) + 1);
                                    ^
memory/kasan/generic.c:128:44: portability: '(void*)addr+size' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   kasan_mem_to_shadow((void *)addr + size - 1) + 1);
                                           ^
memory/kasan/generic.c:212:27: portability: 'global->beg' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 poison_range(global->beg + aligned_size,
                          ^
memory/kasan/init.c:162:11: style: The scope of the variable 'p' can be reduced. [variableScope]
   pmd_t *p;
          ^
memory/kasan/init.c:203:11: style: The scope of the variable 'p' can be reduced. [variableScope]
   pud_t *p;
          ^
memory/kasan/init.c:265:11: style: The scope of the variable 'p' can be reduced. [variableScope]
   p4d_t *p;
          ^
memory/kasan/init.c:284:9: style: The scope of the variable 'pte' can be reduced. [variableScope]
 pte_t *pte;
        ^
memory/kasan/init.c:299:9: style: The scope of the variable 'pmd' can be reduced. [variableScope]
 pmd_t *pmd;
        ^
memory/kasan/init.c:314:9: style: The scope of the variable 'pud' can be reduced. [variableScope]
 pud_t *pud;
        ^
memory/kasan/init.c:329:9: style: The scope of the variable 'p4d' can be reduced. [variableScope]
 p4d_t *p4d;
        ^
memory/kasan/init.c:443:9: style: The scope of the variable 'pgd' can be reduced. [variableScope]
 pgd_t *pgd;
        ^
memory/kasan/init.c:481:28: portability: 'shadow_start' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 shadow_end = shadow_start + (size >> KASAN_SHADOW_SCALE_SHIFT);
                           ^
memory/kasan/quarantine.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/quarantine.c:137:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_SLAB;CONFIG_SLUB' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/quarantine.c:148:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_SLAB;CONFIG_SLUB' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/quarantine.c:137:0: information: Skipping configuration 'CONFIG_SLAB' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/quarantine.c:148:0: information: Skipping configuration 'CONFIG_SLAB' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/quarantine.c:137:0: information: Skipping configuration 'CONFIG_SLAB;CONFIG_SLUB_DEBUG' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/quarantine.c:148:0: information: Skipping configuration 'CONFIG_SLAB;CONFIG_SLUB_DEBUG' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SLAB))
^
memory/kasan/report.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 19 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/report.c:222:45: portability: '(void*)&init_thread_union.stack' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  (addr <= (void *)&init_thread_union.stack +
                                            ^
memory/kasan/report.c:255:38: portability: 'row' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (row <= addr) && (addr < row + META_MEM_BYTES_PER_ROW);
                                     ^
memory/kasan/report.c:305:7: portability: 'row' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  row += META_MEM_BYTES_PER_ROW;
      ^
memory/kasan/report.c:280:4: portability: '(void*)round_down((unsigned long)addr,(16*1)*(1UL<<KASAN_SHADOW_SCALE_SHIFT))' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   - META_ROWS_AROUND_ADDR * META_MEM_BYTES_PER_ROW;
   ^
memory/kasan/report_generic.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 19 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/report_generic.c:118:44: warning: Invalid test for overflow 'info->access_addr+info->access_size<info->access_addr'. Condition is always false unless there is overflow, and overflow is undefined behaviour. [invalidTestForOverflow]
 if (info->access_addr + info->access_size < info->access_addr)
                                           ^
memory/kasan/report_generic.c:37:18: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 while (p < addr + size && !(*(u8 *)kasan_mem_to_shadow(p)))
                 ^
memory/kasan/report_generic.c:38:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += KASAN_GRANULE_SIZE;
    ^
memory/kasan/report_generic.c:118:24: portability: 'info->access_addr' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (info->access_addr + info->access_size < info->access_addr)
                       ^
memory/kasan/report_hw_tags.c:33:34: portability: 'row' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  buffer[i] = hw_get_mem_tag(row + i * KASAN_GRANULE_SIZE);
                                 ^
memory/kasan/report_sw_tags.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/report_sw_tags.c:69:44: warning: Invalid test for overflow 'info->access_addr+info->access_size<info->access_addr'. Condition is always false unless there is overflow, and overflow is undefined behaviour. [invalidTestForOverflow]
 if (info->access_addr + info->access_size < info->access_addr)
                                           ^
memory/kasan/report_sw_tags.c:69:24: portability: 'info->access_addr' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (info->access_addr + info->access_size < info->access_addr)
                       ^
memory/kasan/report_sw_tags.c:79:16: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 void *end = p + size;
               ^
memory/kasan/report_sw_tags.c:82:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += KASAN_GRANULE_SIZE;
    ^
memory/kasan/report_sw_tags.c:35:27: style: The scope of the variable 'alloc_meta' can be reduced. [variableScope]
 struct kasan_alloc_meta *alloc_meta;
                          ^
memory/kasan/report_sw_tags.c:36:21: style: The scope of the variable 'cache' can be reduced. [variableScope]
 struct kmem_cache *cache;
                    ^
memory/kasan/report_sw_tags.c:39:8: style: The scope of the variable 'object' can be reduced. [variableScope]
 void *object;
       ^
memory/kasan/report_sw_tags.c:41:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
memory/kasan/shadow.c:88:43: portability: 'address' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 shadow_end = kasan_mem_to_shadow(address + size);
                                          ^
memory/kasan/shadow.c:107:50: portability: 'address' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  u8 *shadow = (u8 *)kasan_mem_to_shadow(address + size);
                                                 ^
memory/kasan/shadow.c:109:0: information: Skipping configuration 'CONFIG_KASAN_GENERIC;CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_SW_TAGS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
^
memory/kasan/shadow.c:109:0: information: Skipping configuration 'CONFIG_KASAN_HW_TAGS;CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_SW_TAGS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
^
memory/kasan/shadow.c:109:0: information: Skipping configuration 'CONFIG_KASAN_SW_TAGS' since the value of 'CONFIG_KASAN_SW_TAGS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_KASAN_SW_TAGS))
^
memory/kasan/shadow.c:434:16: style: The scope of the variable 'size' can be reduced. [variableScope]
 unsigned long size;
               ^
memory/kasan/shadow.c:265:63: portability: '(void*)addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 shadow_end = (unsigned long)kasan_mem_to_shadow((void *)addr + size);
                                                              ^
memory/kasan/sw_tags.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/kasan/sw_tags.c:111:50: portability: 'untagged_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 shadow_last = kasan_mem_to_shadow(untagged_addr + size - 1);
                                                 ^
memory/kasan/sw_tags.c:111:57: portability: 'untagged_addr+size' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 shadow_last = kasan_mem_to_shadow(untagged_addr + size - 1);
                                                        ^
memory/khugepaged.c:2125:0: information: Skipping configuration 'CONFIG_SHMEM' since the value of 'CONFIG_SHMEM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   if (IS_ENABLED(CONFIG_SHMEM) && vma->vm_file) {
^
memory/kmemleak.c:909:15: style: The scope of the variable 'cpu' can be reduced. [variableScope]
 unsigned int cpu;
              ^
memory/kmemleak.c:992:15: style: The scope of the variable 'cpu' can be reduced. [variableScope]
 unsigned int cpu;
              ^
memory/kmemleak.c:1236:16: style: The scope of the variable 'untagged_ptr' can be reduced. [variableScope]
 unsigned long untagged_ptr;
               ^
memory/kmemleak.c:1234:28: portability: '_end' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 unsigned long *end = _end - (BYTES_PER_POINTER - 1);
                           ^
memory/kmemleak.c:1342:21: portability: 'start' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   next = min(start + MAX_SCAN_SIZE, end);
                    ^
memory/kmemleak.c:1478:29: portability: 'stack' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    scan_block(stack, stack + THREAD_SIZE, NULL);
                            ^
memory/kmemleak.c:1308:20: portability: 'start' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  next = min(start + MAX_SCAN_SIZE, end);
                   ^
memory/ksm.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 17 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/ksm.c:1618:30: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  VM_BUG_ON(!stable_node_dup ^ !!stable_node_any);
                             ^
memory/ksm.c:1853:30: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  VM_BUG_ON(!stable_node_dup ^ !!stable_node_any);
                             ^
memory/ksm.c:1392:8: style: Condition '!found' is always true [knownConditionTrueFalse]
   if (!found ||
       ^
memory/ksm.c:1360:36: note: Assignment 'found=NULL', assigned value is 0
 struct stable_node *dup, *found = NULL, *stable_node = *_stable_node;
                                   ^
memory/ksm.c:1388:7: note: Assuming condition is false
  if (!_tree_page)
      ^
memory/ksm.c:1392:8: note: Condition '!found' is always true
   if (!found ||
       ^
memory/ksm.c:1394:9: style: Condition 'found' is always false [knownConditionTrueFalse]
    if (found)
        ^
memory/ksm.c:1360:36: note: Assignment 'found=NULL', assigned value is 0
 struct stable_node *dup, *found = NULL, *stable_node = *_stable_node;
                                   ^
memory/ksm.c:1388:7: note: Assuming condition is false
  if (!_tree_page)
      ^
memory/ksm.c:1394:9: note: Condition 'found' is always false
    if (found)
        ^
memory/ksm.c:588:36: style: Same value in both branches of ternary operator. [duplicateValueTernary]
 return ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));
                                   ^
memory/ksm.c:472:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/ksm.c:2258:17: style: The scope of the variable 'page' can be reduced. [variableScope]
   struct page *page;
                ^
memory/ksm.c:2390:20: style: The scope of the variable 'rmap_item' can be reduced. [variableScope]
 struct rmap_item *rmap_item;
                   ^
memory/ksm.c:2625:26: style: The scope of the variable 'vma' can be reduced. [variableScope]
  struct vm_area_struct *vma;
                         ^
memory/ksm.c:594:22: style: Local variable 'chain' shadows outer function [shadowFunction]
 struct stable_node *chain = alloc_stable_node();
                     ^
memory/ksm.c:1530:37: note: Shadowed declaration
static __always_inline struct page *chain(struct stable_node **s_n_d,
                                    ^
memory/ksm.c:594:22: note: Shadow variable
 struct stable_node *chain = alloc_stable_node();
                     ^
memory/ksm.c:1558:36: style: Local variable 'stable_node_dup' shadows outer function [shadowFunction]
 struct stable_node *stable_node, *stable_node_dup, *stable_node_any;
                                   ^
memory/ksm.c:1355:21: note: Shadowed declaration
static struct page *stable_node_dup(struct stable_node **_stable_node_dup,
                    ^
memory/ksm.c:1558:36: note: Shadow variable
 struct stable_node *stable_node, *stable_node_dup, *stable_node_any;
                                   ^
memory/ksm.c:1811:36: style: Local variable 'stable_node_dup' shadows outer function [shadowFunction]
 struct stable_node *stable_node, *stable_node_dup, *stable_node_any;
                                   ^
memory/ksm.c:1355:21: note: Shadowed declaration
static struct page *stable_node_dup(struct stable_node **_stable_node_dup,
                    ^
memory/ksm.c:1811:36: note: Shadow variable
 struct stable_node *stable_node, *stable_node_dup, *stable_node_any;
                                   ^
memory/ksm.c:2258:17: style: Local variable 'page' shadows outer argument [shadowArgument]
   struct page *page;
                ^
memory/ksm.c:2225:64: note: Shadowed declaration
static struct rmap_item *scan_get_next_rmap_item(struct page **page)
                                                               ^
memory/ksm.c:2258:17: note: Shadow variable
   struct page *page;
                ^
memory/ksm.c:588:9: style: Condition 'ksm_merge_across_nodes' is always true [knownConditionTrueFalse]
 return ksm_merge_across_nodes ? 0 : NUMA(pfn_to_nid(kpfn));
        ^
memory/ksm.c:1965:14: style: Condition '!ksm_merge_across_nodes' is always false [knownConditionTrueFalse]
  } else if (!ksm_merge_across_nodes &&
             ^
memory/ksm.c:2256:7: style: Condition '!ksm_merge_across_nodes' is always false [knownConditionTrueFalse]
  if (!ksm_merge_across_nodes) {
      ^
memory/ksm.c:2750:18: style: The scope of the variable 'node' can be reduced. [variableScope]
 struct rb_node *node;
                 ^
memory/ksm.c:2954:20: style: Local variable 'buf' shadows outer argument [shadowArgument]
   struct rb_root *buf;
                   ^
memory/ksm.c:2937:20: note: Shadowed declaration
       const char *buf, size_t count)
                   ^
memory/ksm.c:2954:20: note: Shadow variable
   struct rb_root *buf;
                   ^
memory/list_lru.c:143:23: style: The scope of the variable 'l' can be reduced. [variableScope]
 struct list_lru_one *l;
                      ^
memory/list_lru.c:293:6: style: The scope of the variable 'memcg_idx' can be reduced. [variableScope]
 int memcg_idx;
     ^
memory/list_lru.c:307:20: style: Checking if unsigned expression '*nr_to_walk' is less than zero. [unsignedLessThanZero]
   if (*nr_to_walk <= 0)
                   ^
memory/maccess.c:185:60: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  ret = __get_user(*dst++, (const char __user __force *)src++);
                                                           ^
memory/maccess.c:37:1: style: Label 'Efault' is not used. [unusedLabel]
Efault:
^
memory/maccess.c:60:1: style: Label 'Efault' is not used. [unusedLabel]
Efault:
^
memory/maccess.c:84:1: style: Label 'Efault' is not used. [unusedLabel]
Efault:
^
memory/maccess.c:31:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u64, Efault);
 ^
memory/maccess.c:31:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u64, Efault);
 ^
memory/maccess.c:32:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u32, Efault);
 ^
memory/maccess.c:32:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u32, Efault);
 ^
memory/maccess.c:33:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u16, Efault);
 ^
memory/maccess.c:33:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u16, Efault);
 ^
memory/maccess.c:34:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u8, Efault);
 ^
memory/maccess.c:34:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_from_kernel_nofault_loop(dst, src, size, u8, Efault);
 ^
memory/maccess.c:54:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u64, Efault);
 ^
memory/maccess.c:54:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u64, Efault);
 ^
memory/maccess.c:55:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u32, Efault);
 ^
memory/maccess.c:55:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u32, Efault);
 ^
memory/maccess.c:56:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u16, Efault);
 ^
memory/maccess.c:56:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u16, Efault);
 ^
memory/maccess.c:57:2: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u8, Efault);
 ^
memory/maccess.c:57:2: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 copy_to_kernel_nofault_loop(dst, src, size, u8, Efault);
 ^
memory/maccess.c:78:6: portability: 'src' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  src++;
     ^
memory/madvise.c:188:9: style: The scope of the variable 'orig_pte' can be reduced. [variableScope]
 pte_t *orig_pte;
        ^
memory/memblock.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 13 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/memblock.c:1994:7: style: Condition 'prev_end' is always false [knownConditionTrueFalse]
  if (prev_end && prev_end < start)
      ^
memory/memblock.c:1963:39: note: Assignment 'prev_end=0', assigned value is 0
 unsigned long start, end, prev_end = 0;
                                      ^
memory/memblock.c:1966:46: note: Assuming condition is false
 if (!IS_ENABLED(CONFIG_HAVE_ARCH_PFN_VALID) ||
                                             ^
memory/memblock.c:1994:7: note: Condition 'prev_end' is always false
  if (prev_end && prev_end < start)
      ^
memory/memblock.c:2013:6: style: The scope of the variable 'order' can be reduced. [variableScope]
 int order;
     ^
memory/memcontrol.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 28 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/memcontrol.c:2732:6: style: Condition '!do_memsw_account()' is always true [knownConditionTrueFalse]
 if (!do_memsw_account() ||
     ^
memory/memcontrol.c:4072:40: style: Condition '!do_memsw_account()' is always true [knownConditionTrueFalse]
  if (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())
                                       ^
memory/memcontrol.c:4106:40: style: Condition '!do_memsw_account()' is always true [knownConditionTrueFalse]
  if (memcg1_stats[i] == MEMCG_SWAP && !do_memsw_account())
                                       ^
memory/memcontrol.c:1214:9: style: Variable 'memcg' is reassigned a value before the old one has been used. [redundantAssignment]
  memcg = NULL;
        ^
memory/memcontrol.c:1206:9: note: memcg is assigned
  memcg = mem_cgroup_from_css(css);
        ^
memory/memcontrol.c:1214:9: note: memcg is overwritten
  memcg = NULL;
        ^
memory/memcontrol.c:5354:8: style: Redundant initialization for 'error'. The initialized value is overwritten before it is read. [redundantInitialization]
 error = memcg_online_kmem(memcg);
       ^
memory/memcontrol.c:5324:13: note: error is initialized
 long error = -ENOMEM;
            ^
memory/memcontrol.c:5354:8: note: error is overwritten
 error = memcg_online_kmem(memcg);
       ^
memory/memcontrol.c:440:30: style: The scope of the variable 'pn' can be reduced. [variableScope]
 struct mem_cgroup_per_node *pn;
                             ^
memory/memcontrol.c:441:29: style: The scope of the variable 'map' can be reduced. [variableScope]
 struct memcg_shrinker_map *map;
                            ^
memory/memcontrol.c:604:30: style: The scope of the variable 'mz_node' can be reduced. [variableScope]
 struct mem_cgroup_per_node *mz_node;
                             ^
memory/memcontrol.c:670:16: style: The scope of the variable 'excess' can be reduced. [variableScope]
 unsigned long excess;
               ^
memory/memcontrol.c:671:30: style: The scope of the variable 'mz' can be reduced. [variableScope]
 struct mem_cgroup_per_node *mz;
                             ^
memory/memcontrol.c:707:35: style: The scope of the variable 'mctz' can be reduced. [variableScope]
 struct mem_cgroup_tree_per_node *mctz;
                                  ^
memory/memcontrol.c:708:30: style: The scope of the variable 'mz' can be reduced. [variableScope]
 struct mem_cgroup_per_node *mz;
                             ^
memory/memcontrol.c:873:17: style: The scope of the variable 'lruvec' can be reduced. [variableScope]
 struct lruvec *lruvec;
                ^
memory/memcontrol.c:3368:7: style: The scope of the variable 'limits_invariant' can be reduced. [variableScope]
 bool limits_invariant;
      ^
memory/memcontrol.c:3422:16: style: The scope of the variable 'reclaimed' can be reduced. [variableScope]
 unsigned long reclaimed;
               ^
memory/memcontrol.c:3425:16: style: The scope of the variable 'excess' can be reduced. [variableScope]
 unsigned long excess;
               ^
memory/memcontrol.c:429:27: portability: '(void*)new->map' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memset((void *)new->map + old_size, 0, size - old_size);
                          ^
memory/memcontrol.c:3410:7: error: Uninitialized variable: ret [uninitvar]
 if (!ret && enlarge)
      ^
memory/memcontrol.c:3413:9: error: Uninitialized variable: ret [uninitvar]
 return ret;
        ^
memory/memcontrol.c:189:16: style: struct member 'move_charge_struct::precharge' is never used. [unusedStructMember]
 unsigned long precharge;
               ^
memory/memcontrol.c:190:16: style: struct member 'move_charge_struct::moved_charge' is never used. [unusedStructMember]
 unsigned long moved_charge;
               ^
memory/memcontrol.c:191:16: style: struct member 'move_charge_struct::moved_swap' is never used. [unusedStructMember]
 unsigned long moved_swap;
               ^
memory/memcontrol.c:2038:14: style: Variable 'owait.memcg' is assigned a value that is never used. [unreadVariable]
 owait.memcg = memcg;
             ^
memory/memcontrol.c:4130:31: style: The scope of the variable 'mz' can be reduced. [variableScope]
  struct mem_cgroup_per_node *mz;
                              ^
memory/memcontrol.c:3223:21: style: The scope of the variable 'memcg' can be reduced. [variableScope]
 struct mem_cgroup *memcg;
                    ^
memory/memcontrol.c:3718:30: style: The scope of the variable 'child' can be reduced. [variableScope]
 struct mem_cgroup *parent, *child;
                             ^
memory/memory-failure.c:1615:6: style: The scope of the variable 'gotten' can be reduced. [variableScope]
 int gotten;
     ^
memory/memory.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/memory.c:512:23: style: The scope of the variable 'nr_unshown' can be reduced. [variableScope]
 static unsigned long nr_unshown;
                      ^
memory/memory.c:1853:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret, i;
     ^
memory/memory.c:2196:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
memory/memory.c:2219:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
memory/memory.c:2241:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
memory/memory.c:390:67: style:inconclusive: Function 'free_pgtables' argument 2 names different: declaration 'start_vma' definition 'vma'. [funcArgNamesDifferent]
void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,
                                                                  ^
memory/internal.h:39:67: note: Function 'free_pgtables' argument 2 names different: declaration 'start_vma' definition 'vma'.
void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *start_vma,
                                                                  ^
memory/memory.c:390:67: note: Function 'free_pgtables' argument 2 names different: declaration 'start_vma' definition 'vma'.
void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,
                                                                  ^
memory/memory.c:4911:15: portability: 'maddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
        maddr + offset, buf, bytes);
              ^
memory/memory.c:4915:22: portability: 'maddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
          buf, maddr + offset, bytes);
                     ^
memory/memory.c:4921:7: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  buf += bytes;
      ^
memory/memory.c:5174:19: style: The scope of the variable 'rc' can be reduced. [variableScope]
 unsigned long i, rc = 0;
                  ^
memory/memory.c:5183:31: portability: 'src' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    (const void __user *)(src + i * PAGE_SIZE),
                              ^
memory/memory.c:5174:22: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 unsigned long i, rc = 0;
                     ^
memory/memory_hotplug.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 17 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/memory_hotplug.c:274:0: information: Skipping configuration 'CONFIG_HAVE_BOOTMEM_INFO_NODE;CONFIG_MEMORY_HOTPLUG_SPARSE;CONFIG_SPARSEMEM_VMEMMAP' since the value of 'CONFIG_SPARSEMEM_VMEMMAP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP))
^
memory/memory_hotplug.c:1819:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
memory/mempolicy.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 14 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/mempolicy.c:138:26: style: The scope of the variable 'dist' can be reduced. [variableScope]
 int min_dist = INT_MAX, dist, n, min_node;
                         ^
memory/mempolicy.c:526:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
memory/mempolicy.c:1375:16: style: The scope of the variable 'k' can be reduced. [variableScope]
 unsigned long k;
               ^
memory/mempolicy.c:1428:14: style: Local variable 'nodes' shadows outer argument [shadowArgument]
 nodes_addr(*nodes)[nlongs-1] &= endmask;
             ^
memory/mempolicy.c:1372:34: note: Shadowed declaration
static int get_nodes(nodemask_t *nodes, const unsigned long __user *nmask,
                                 ^
memory/mempolicy.c:1428:14: note: Shadow variable
 nodes_addr(*nodes)[nlongs-1] &= endmask;
             ^
memory/mempolicy.c:2584:20: style: Local variable 'mpol_new' shadows outer function [shadowFunction]
 struct mempolicy *mpol_new = NULL;
                   ^
memory/mempolicy.c:268:26: note: Shadowed declaration
static struct mempolicy *mpol_new(unsigned short mode, unsigned short flags,
                         ^
memory/mempolicy.c:2584:20: note: Shadow variable
 struct mempolicy *mpol_new = NULL;
                   ^
memory/mempolicy.c:2785:13: style: Local variable 'interleave_nodes' shadows outer function [shadowFunction]
 nodemask_t interleave_nodes;
            ^
memory/mempolicy.c:1898:17: note: Shadowed declaration
static unsigned interleave_nodes(struct mempolicy *policy)
                ^
memory/mempolicy.c:2785:13: note: Shadow variable
 nodemask_t interleave_nodes;
            ^
memory/mempool.c:452:16: style: The scope of the variable 'flags' can be reduced. [variableScope]
 unsigned long flags;
               ^
memory/mempool.c:37:34: portability: 'element' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  pr_cont("%x ", *(u8 *)(element + i));
                                 ^
memory/memtest.c:103:15: style: The scope of the variable 'idx' can be reduced. [variableScope]
 unsigned int idx = 0;
              ^
memory/memtest.c:103:19: style: Variable 'idx' is assigned a value that is never used. [unreadVariable]
 unsigned int idx = 0;
                  ^
memory/migrate.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/migrate.c:953:7: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
   rc = migrate_page(mapping, newpage, page, mode);
      ^
memory/migrate.c:943:9: note: rc is initialized
 int rc = -EAGAIN;
        ^
memory/migrate.c:953:7: note: rc is overwritten
   rc = migrate_page(mapping, newpage, page, mode);
      ^
memory/migrate.c:2000:29: warning:inconclusive: Found suspicious operator '*' [constStatement]
 const void __user * __user *pages;
                            ^
memory/mincore.c:195:17: style: Local variable 'pages' shadows outer argument [shadowArgument]
  unsigned long pages = DIV_ROUND_UP(end - addr, PAGE_SIZE);
                ^
memory/mincore.c:184:58: note: Shadowed declaration
static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)
                                                         ^
memory/mincore.c:195:17: note: Shadow variable
  unsigned long pages = DIV_ROUND_UP(end - addr, PAGE_SIZE);
                ^
memory/mlock.c:562:29: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 unsigned long nstart, end, tmp;
                            ^
memory/mm_init.c:36:16: style: The scope of the variable 'zone' can be reduced. [variableScope]
  struct zone *zone;
               ^
memory/mm_init.c:38:20: style: The scope of the variable 'zonelist' can be reduced. [variableScope]
  struct zonelist *zonelist;
                   ^
memory/mm_init.c:39:10: style: The scope of the variable 'listid' can be reduced. [variableScope]
  int i, listid, zoneid;
         ^
memory/mm_init.c:39:18: style: The scope of the variable 'zoneid' can be reduced. [variableScope]
  int i, listid, zoneid;
                 ^
memory/mmap.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/mmap.c:2263:6: style: Condition 'error' is always false [knownConditionTrueFalse]
 if (error)
     ^
memory/mmap.c:2262:24: note: Assignment 'error=0', assigned value is 0
 unsigned long error = arch_mmap_check(addr, len, flags);
                       ^
memory/mmap.c:2263:6: note: Condition 'error' is always false
 if (error)
     ^
memory/mmap.c:291:21: style: The scope of the variable 'prev_end' can be reduced. [variableScope]
 unsigned long gap, prev_end;
                    ^
memory/mmap.c:1355:16: style: The scope of the variable 'locked' can be reduced. [variableScope]
 unsigned long locked, lock_limit;
               ^
memory/mmap.c:1355:24: style: The scope of the variable 'lock_limit' can be reduced. [variableScope]
 unsigned long locked, lock_limit;
                       ^
memory/mmap.c:2168:25: style: The scope of the variable 'vma' can be reduced. [variableScope]
 struct vm_area_struct *vma, *prev;
                        ^
memory/mmap.c:2207:25: style: The scope of the variable 'vma' can be reduced. [variableScope]
 struct vm_area_struct *vma, *prev;
                        ^
memory/mmap.c:3065:59: style:inconclusive: Function 'do_brk_flags' argument 2 names different: declaration 'request' definition 'len'. [funcArgNamesDifferent]
static int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)
                                                          ^
memory/mmap.c:188:59: note: Function 'do_brk_flags' argument 2 names different: declaration 'request' definition 'len'.
static int do_brk_flags(unsigned long addr, unsigned long request, unsigned long flags,
                                                          ^
memory/mmap.c:3065:59: note: Function 'do_brk_flags' argument 2 names different: declaration 'request' definition 'len'.
static int do_brk_flags(unsigned long addr, unsigned long len, unsigned long flags, struct list_head *uf)
                                                          ^
memory/mmap.c:3022:34: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 prot |= vma->vm_flags & VM_READ ? PROT_READ : 0;
                                 ^
memory/mmap.c:3023:35: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 prot |= vma->vm_flags & VM_WRITE ? PROT_WRITE : 0;
                                  ^
memory/mmap.c:3024:34: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 prot |= vma->vm_flags & VM_EXEC ? PROT_EXEC : 0;
                                 ^
memory/mmap.c:399:26: style: The scope of the variable 'avc' can be reduced. [variableScope]
  struct anon_vma_chain *avc;
                         ^
memory/mmu_notifier.c:273:7: style: The scope of the variable 'ret' can be reduced. [variableScope]
 bool ret;
      ^
memory/mmu_notifier.c:517:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
memory/mmu_notifier.c:978:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
memory/mmu_notifier.c:1001:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
memory/mprotect.c:548:8: style: Redundant initialization for 'error'. The initialized value is overwritten before it is read. [redundantInitialization]
 error = -EINVAL;
       ^
memory/mprotect.c:517:12: note: error is initialized
 int error = -EINVAL;
           ^
memory/mprotect.c:548:8: note: error is overwritten
 error = -EINVAL;
       ^
memory/mremap.c:462:0: information: Skipping configuration 'CONFIG_HAVE_MOVE_PMD' since the value of 'CONFIG_HAVE_MOVE_PMD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  } else if (IS_ENABLED(CONFIG_HAVE_MOVE_PMD) &&
^
memory/mremap.c:432:0: information: Skipping configuration 'CONFIG_HAVE_MOVE_PUD' since the value of 'CONFIG_HAVE_MOVE_PUD' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_HAVE_MOVE_PUD) && extent == PUD_SIZE) {
^
memory/nommu.c:899:4: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
   prot |= PROT_EXEC;
   ^
memory/nommu.c:468:20: style: The scope of the variable 'pregion' can be reduced. [variableScope]
 struct vm_region *pregion;
                   ^
memory/nommu.c:565:25: style: The scope of the variable 'pvma' can be reduced. [variableScope]
 struct vm_area_struct *pvma, *prev;
                        ^
memory/nommu.c:1044:16: portability: 'base' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   memset(base + ret, 0, len - ret);
               ^
memory/nommu.c:1651:39: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 vma->vm_start = (unsigned long)(addr + (pgoff << PAGE_SHIFT));
                                      ^
memory/nommu.c:881:11: style: Variable 'prot' is assigned a value that is never used. [unreadVariable]
     prot |= PROT_EXEC;
          ^
memory/nommu.c:899:9: style: Variable 'prot' is assigned a value that is never used. [unreadVariable]
   prot |= PROT_EXEC;
        ^
memory/nommu.c:435:20: style: The scope of the variable 'region' can be reduced. [variableScope]
 struct vm_region *region, *last;
                   ^
memory/oom_kill.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 18 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/oom_kill.c:460:0: information: Skipping configuration 'CONFIG_CMA;CONFIG_COMPACTION' since the value of 'CONFIG_COMPACTION' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)
^
memory/oom_kill.c:269:0: information: Skipping configuration 'CONFIG_NUMA' since the value of 'CONFIG_NUMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_NUMA))
^
memory/page-writeback.c:2664:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret = 0;
     ^
memory/page-writeback.c:1376:0: information: Skipping configuration 'CONFIG_CGROUP_WRITEBACK' since the value of 'CONFIG_CGROUP_WRITEBACK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_CGROUP_WRITEBACK) && mdtc) {
^
memory/page_alloc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 44 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/page_alloc.c:3882:7: style: Condition 'no_fallback' is always false [knownConditionTrueFalse]
  if (no_fallback && nr_online_nodes > 1 &&
      ^
memory/page_alloc.c:3842:28: note: Assignment 'no_fallback=alloc_flags&0x0', assigned value is 0
 no_fallback = alloc_flags & ALLOC_NOFRAGMENT;
                           ^
memory/page_alloc.c:3850:33: note: Assuming condition is false
   (alloc_flags & ALLOC_CPUSET) &&
                                ^
memory/page_alloc.c:3882:7: note: Condition 'no_fallback' is always false
  if (no_fallback && nr_online_nodes > 1 &&
      ^
memory/page_alloc.c:525:16: style: The scope of the variable 'old_word' can be reduced. [variableScope]
 unsigned long old_word, word;
               ^
memory/page_alloc.c:2332:20: style: The scope of the variable 'area' can be reduced. [variableScope]
 struct free_area *area;
                   ^
memory/page_alloc.c:2333:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/page_alloc.c:2624:6: style: The scope of the variable 'fallback_mt' can be reduced. [variableScope]
 int fallback_mt;
     ^
memory/page_alloc.c:3262:23: style: The scope of the variable 'pfn' can be reduced. [variableScope]
 unsigned long flags, pfn;
                      ^
memory/page_alloc.c:3317:16: style: The scope of the variable 'watermark' can be reduced. [variableScope]
 unsigned long watermark;
               ^
memory/page_alloc.c:5711:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/page_alloc.c:6096:33: style: The scope of the variable 'r' can be reduced. [variableScope]
 static struct memblock_region *r;
                                ^
memory/page_alloc.c:6416:26: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct per_cpu_pageset *p;
                         ^
memory/page_alloc.c:6684:17: style: The scope of the variable 'start_pfn' can be reduced. [variableScope]
  unsigned long start_pfn, end_pfn;
                ^
memory/page_alloc.c:6684:28: style: The scope of the variable 'end_pfn' can be reduced. [variableScope]
  unsigned long start_pfn, end_pfn;
                           ^
memory/page_alloc.c:8827:6: style: The scope of the variable 'cpu' can be reduced. [variableScope]
 int cpu;
     ^
memory/page_alloc.c:8828:26: style: The scope of the variable 'pset' can be reduced. [variableScope]
 struct per_cpu_pageset *pset;
                         ^
memory/page_alloc.c:2542:6: style: Local variable 'free_pages' shadows outer function [shadowFunction]
 int free_pages, movable_pages, alike_pages;
     ^
memory/page_alloc.c:5089:6: note: Shadowed declaration
void free_pages(unsigned long addr, unsigned int order)
     ^
memory/page_alloc.c:2542:6: note: Shadow variable
 int free_pages, movable_pages, alike_pages;
     ^
memory/page_alloc.c:3275:17: style: Local variable 'pfn' shadows outer variable [shadowVariable]
  unsigned long pfn = page_private(page);
                ^
memory/page_alloc.c:3262:23: note: Shadowed declaration
 unsigned long flags, pfn;
                      ^
memory/page_alloc.c:3275:17: note: Shadow variable
  unsigned long pfn = page_private(page);
                ^
memory/page_alloc.c:3351:8: style: Local variable 'mt' shadows outer variable [shadowVariable]
   int mt = get_pageblock_migratetype(page);
       ^
memory/page_alloc.c:3319:6: note: Shadowed declaration
 int mt;
     ^
memory/page_alloc.c:3351:8: note: Shadow variable
   int mt = get_pageblock_migratetype(page);
       ^
memory/page_alloc.c:3709:7: style: Local variable 'free_pages' shadows outer function [shadowFunction]
 long free_pages;
      ^
memory/page_alloc.c:5089:6: note: Shadowed declaration
void free_pages(unsigned long addr, unsigned int order)
     ^
memory/page_alloc.c:3709:7: note: Shadow variable
 long free_pages;
      ^
memory/page_alloc.c:3748:7: style: Local variable 'free_pages' shadows outer function [shadowFunction]
 long free_pages = zone_page_state(z, NR_FREE_PAGES);
      ^
memory/page_alloc.c:5089:6: note: Shadowed declaration
void free_pages(unsigned long addr, unsigned int order)
     ^
memory/page_alloc.c:3748:7: note: Shadow variable
 long free_pages = zone_page_state(z, NR_FREE_PAGES);
      ^
memory/page_alloc.c:7669:35: portability: 'pos' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 for (pos = start; pos < end; pos += PAGE_SIZE, pages++) {
                                  ^
memory/page_alloc.c:2867:0: information: Skipping configuration 'CONFIG_CMA' since the value of 'CONFIG_CMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_CMA)) {
^
memory/page_alloc.c:3475:0: information: Skipping configuration 'CONFIG_CMA' since the value of 'CONFIG_CMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (!IS_ENABLED(CONFIG_CMA) || alloc_flags & ALLOC_CMA ||
^
memory/page_alloc.c:2867:0: information: Skipping configuration 'CONFIG_CMA;CONFIG_COMPACTION' since the value of 'CONFIG_CMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_CMA)) {
^
memory/page_alloc.c:3475:0: information: Skipping configuration 'CONFIG_CMA;CONFIG_COMPACTION' since the value of 'CONFIG_CMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (!IS_ENABLED(CONFIG_CMA) || alloc_flags & ALLOC_CMA ||
^
memory/page_alloc.c:8476:15: style: The scope of the variable 'nr_reclaimed' can be reduced. [variableScope]
 unsigned int nr_reclaimed;
              ^
memory/page_alloc.c:8689:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/page_alloc.c:8743:21: style: The scope of the variable 'pfn' can be reduced. [variableScope]
 unsigned long ret, pfn, flags;
                    ^
memory/page_alloc.c:1163:0: information: Skipping configuration 'CONFIG_DEBUG_VM' since the value of 'CONFIG_DEBUG_VM' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_DEBUG_VM)) {
^
memory/page_ext.c:111:14: portability: 'base' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return base + page_ext_size * index;
             ^
memory/page_ext.c:258:35: portability: '(void*)base' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 section->page_ext = (void *)base - page_ext_size * pfn;
                                  ^
memory/page_idle.c:119:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/page_idle.c:121:6: style: The scope of the variable 'bit' can be reduced. [variableScope]
 int bit;
     ^
memory/page_idle.c:166:6: style: The scope of the variable 'bit' can be reduced. [variableScope]
 int bit;
     ^
memory/page_isolation.c:225:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/page_isolation.c:209:16: style: Local variable 'page' shadows outer variable [shadowVariable]
  struct page *page = pfn_to_online_page(pfn);
               ^
memory/page_isolation.c:188:15: note: Shadowed declaration
 struct page *page;
              ^
memory/page_isolation.c:209:16: note: Shadow variable
  struct page *page = pfn_to_online_page(pfn);
               ^
memory/page_owner.c:150:21: style: The scope of the variable 'page_owner' can be reduced. [variableScope]
 struct page_owner *page_owner;
                    ^
memory/page_owner.c:169:21: style: The scope of the variable 'page_owner' can be reduced. [variableScope]
 struct page_owner *page_owner;
                    ^
memory/page_owner.c:216:21: style: The scope of the variable 'page_owner' can be reduced. [variableScope]
 struct page_owner *page_owner;
                    ^
memory/page_owner.c:263:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
memory/page_owner.c:103:26: portability: '(void*)page_ext' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (void *)page_ext + page_owner_ops.offset;
                         ^
memory/pagewalk.c:525:16: style: The scope of the variable 'start_addr' can be reduced. [variableScope]
 unsigned long start_addr, end_addr;
               ^
memory/pagewalk.c:525:28: style: The scope of the variable 'end_addr' can be reduced. [variableScope]
 unsigned long start_addr, end_addr;
                           ^
memory/pagewalk.c:253:9: style: The scope of the variable 'pte' can be reduced. [variableScope]
 pte_t *pte;
        ^
memory/percpu-vm.c:33:23: warning: Either the condition '!pages' is redundant or there is possible null pointer dereference: pages. [nullPointerRedundantCheck]
 static struct page **pages;
                      ^
memory/percpu-vm.c:38:6: note: Assuming that condition '!pages' is not redundant
 if (!pages)
     ^
memory/percpu-vm.c:33:23: note: Null pointer dereference
 static struct page **pages;
                      ^
memory/percpu.c:770:44: style: The scope of the variable 'block' can be reduced. [variableScope]
 struct pcpu_block_md *s_block, *e_block, *block;
                                           ^
memory/percpu.c:916:44: style: The scope of the variable 'block' can be reduced. [variableScope]
 struct pcpu_block_md *s_block, *e_block, *block;
                                           ^
memory/percpu.c:2196:15: style: The scope of the variable 'cpu' can be reduced. [variableScope]
 unsigned int cpu;
              ^
memory/percpu.c:220:32: portability: 'chunk->base_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 start_addr = chunk->base_addr + chunk->start_offset;
                               ^
memory/percpu.c:221:30: portability: 'chunk->base_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 end_addr = chunk->base_addr + chunk->nr_pages * PAGE_SIZE -
                             ^
memory/percpu.c:1577:7: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 addr += pcpu_unit_offsets[raw_smp_processor_id()];
      ^
memory/percpu.c:1839:49: portability: '(void*)pcpu_chunk_addr(chunk,cpu,0)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
                                                ^
memory/percpu.c:1841:8: portability: 'chunk->base_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 ptr = __addr_to_pcpu_ptr(chunk->base_addr + off);
       ^
memory/percpu.c:2217:38: portability: 'start' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (addr >= start && addr < start + pcpu_unit_size) {
                                     ^
memory/percpu.c:2266:6: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 ptr += base_size;
     ^
memory/percpu.c:2405:9: style: Unused variable: static_size [unusedVariable]
 size_t static_size, dyn_size;
        ^
memory/percpu.c:2405:22: style: Unused variable: dyn_size [unusedVariable]
 size_t static_size, dyn_size;
                     ^
memory/percpu.c:2406:21: style: Unused variable: chunk [unusedVariable]
 struct pcpu_chunk *chunk;
                    ^
memory/percpu.c:2413:6: style: Unused variable: map_size [unusedVariable]
 int map_size;
     ^
memory/percpu.c:2414:16: style: Unused variable: tmp_addr [unusedVariable]
 unsigned long tmp_addr;
               ^
memory/percpu.c:2416:23: style: Unused variable: type [unusedVariable]
 enum pcpu_chunk_type type;
                      ^
memory/percpu.c:2138:33: portability: 'start' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (va >= start && va < start + static_size) {
                                ^
memory/percpu.c:2909:42: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  for (i = 0; i < gi->nr_units; i++, ptr += ai->unit_size) {
                                         ^
memory/percpu.c:2917:16: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   free_fn(ptr + size_sum, ai->unit_size - size_sum);
               ^
memory/readahead.c:275:43: style:inconclusive: Function 'force_page_cache_ra' argument 3 names different: declaration 'nr' definition 'nr_to_read'. [funcArgNamesDifferent]
  struct file_ra_state *ra, unsigned long nr_to_read)
                                          ^
memory/internal.h:55:17: note: Function 'force_page_cache_ra' argument 3 names different: declaration 'nr' definition 'nr_to_read'.
  unsigned long nr);
                ^
memory/readahead.c:275:43: note: Function 'force_page_cache_ra' argument 3 names different: declaration 'nr' definition 'nr_to_read'.
  struct file_ra_state *ra, unsigned long nr_to_read)
                                          ^
memory/rmap.c:1242:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, nr = 1;
     ^
memory/rmap.c:1283:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, nr;
     ^
memory/rmap.c:1023:31: portability: '(void*)anon_vma' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 anon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;
                              ^
memory/rmap.c:1063:31: portability: '(void*)anon_vma' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 anon_vma = (void *) anon_vma + PAGE_MAPPING_ANON;
                              ^
memory/rmap.c:801:0: information: Skipping configuration 'CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  } else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {
^
memory/rmap.c:1292:0: information: Skipping configuration 'CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
^
memory/shmem.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 21 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/shmem.c:3505:0: information: Skipping configuration 'CONFIG_NUMA;CONFIG_TMPFS;CONFIG_SHMEM' since the value of 'CONFIG_NUMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_NUMA)) {
^
memory/shmem.c:657:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:1033:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {
^
memory/shmem.c:1128:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {
^
memory/shmem.c:1580:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
^
memory/shmem.c:2139:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
^
memory/shmem.c:2284:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:3499:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      !(IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:4282:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TMPFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:657:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:1033:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    else if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {
^
memory/shmem.c:1128:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE)) {
^
memory/shmem.c:1580:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
^
memory/shmem.c:2139:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE))
^
memory/shmem.c:2284:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/shmem.c:4282:0: information: Skipping configuration 'CONFIG_SHMEM;CONFIG_SYSFS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_TRANSPARENT_HUGEPAGE' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_TRANSPARENT_HUGEPAGE) &&
^
memory/slab.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 26 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/slab.c:3309:7: warning: Redundant assignment of 'objp' to itself. [selfAssignment]
 objp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);
      ^
memory/slab.c:3442:7: warning: Redundant assignment of 'objp' to itself. [selfAssignment]
 objp = cache_free_debugcheck(cachep, objp, caller);
      ^
memory/slab.c:3502:8: warning: Redundant assignment of 'p[i]' to itself. [selfAssignment]
  p[i] = cache_alloc_debugcheck_after(s, flags, p[i], caller);
       ^
memory/slab.c:3860:12: style: Same expression on both sides of '&&' because 'limit' and 'shared' represent the same value. [knownConditionTrueFalse]
 if (limit && shared && batchcount)
           ^
memory/slab.c:3852:14: note: 'limit' is assigned value '0' here.
 int limit = 0;
             ^
memory/slab.c:3853:15: note: 'shared' is assigned value '0' here.
 int shared = 0;
              ^
memory/slab.c:3860:12: note: Same expression on both sides of '&&' because 'limit' and 'shared' represent the same value.
 if (limit && shared && batchcount)
           ^
memory/slab.c:3860:22: style: Same expression on both sides of '&&' because 'batchcount' and 'shared' represent the same value. [knownConditionTrueFalse]
 if (limit && shared && batchcount)
                     ^
memory/slab.c:3854:19: note: 'batchcount' is assigned value '0' here.
 int batchcount = 0;
                  ^
memory/slab.c:3853:15: note: 'shared' is assigned value '0' here.
 int shared = 0;
              ^
memory/slab.c:3860:22: note: Same expression on both sides of '&&' because 'batchcount' and 'shared' represent the same value.
 if (limit && shared && batchcount)
                     ^
memory/slab.c:2264:26: style: The scope of the variable 'n' can be reduced. [variableScope]
 struct kmem_cache_node *n;
                         ^
memory/slab.c:2487:8: style: The scope of the variable 'objp' can be reduced. [variableScope]
 void *objp;
       ^
memory/slab.c:3324:8: style:inconclusive: Function 'free_block' argument 3 names different: declaration 'len' definition 'nr_objects'. [funcArgNamesDifferent]
   int nr_objects, int node, struct list_head *list)
       ^
memory/slab.c:211:69: note: Function 'free_block' argument 3 names different: declaration 'len' definition 'nr_objects'.
static void free_block(struct kmem_cache *cachep, void **objpp, int len,
                                                                    ^
memory/slab.c:3324:8: note: Function 'free_block' argument 3 names different: declaration 'len' definition 'nr_objects'.
   int nr_objects, int node, struct list_head *list)
       ^
memory/slab.c:3435:39: style:inconclusive: Function '___cache_free' argument 1 names different: declaration 'cache' definition 'cachep'. [funcArgNamesDifferent]
void ___cache_free(struct kmem_cache *cachep, void *objp,
                                      ^
memory/slab.h:583:39: note: Function '___cache_free' argument 1 names different: declaration 'cache' definition 'cachep'.
void ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr);
                                      ^
memory/slab.c:3435:39: note: Function '___cache_free' argument 1 names different: declaration 'cache' definition 'cachep'.
void ___cache_free(struct kmem_cache *cachep, void *objp,
                                      ^
memory/slab.c:3435:53: style:inconclusive: Function '___cache_free' argument 2 names different: declaration 'x' definition 'objp'. [funcArgNamesDifferent]
void ___cache_free(struct kmem_cache *cachep, void *objp,
                                                    ^
memory/slab.h:583:52: note: Function '___cache_free' argument 2 names different: declaration 'x' definition 'objp'.
void ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr);
                                                   ^
memory/slab.c:3435:53: note: Function '___cache_free' argument 2 names different: declaration 'x' definition 'objp'.
void ___cache_free(struct kmem_cache *cachep, void *objp,
                                                    ^
memory/slab.c:3436:17: style:inconclusive: Function '___cache_free' argument 3 names different: declaration 'addr' definition 'caller'. [funcArgNamesDifferent]
  unsigned long caller)
                ^
memory/slab.h:583:69: note: Function '___cache_free' argument 3 names different: declaration 'addr' definition 'caller'.
void ___cache_free(struct kmem_cache *cache, void *x, unsigned long addr);
                                                                    ^
memory/slab.c:3436:17: note: Function '___cache_free' argument 3 names different: declaration 'addr' definition 'caller'.
  unsigned long caller)
                ^
memory/slab.c:3953:44: style:inconclusive: Function 'cache_reap' argument 1 names different: declaration 'unused' definition 'w'. [funcArgNamesDifferent]
static void cache_reap(struct work_struct *w)
                                           ^
memory/slab.c:215:44: note: Function 'cache_reap' argument 1 names different: declaration 'unused' definition 'w'.
static void cache_reap(struct work_struct *unused);
                                           ^
memory/slab.c:3953:44: note: Function 'cache_reap' argument 1 names different: declaration 'unused' definition 'w'.
static void cache_reap(struct work_struct *w)
                                           ^
memory/slab.c:4010:38: style:inconclusive: Function 'get_slabinfo' argument 1 names different: declaration 's' definition 'cachep'. [funcArgNamesDifferent]
void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)
                                     ^
memory/slab.h:193:38: note: Function 'get_slabinfo' argument 1 names different: declaration 's' definition 'cachep'.
void get_slabinfo(struct kmem_cache *s, struct slabinfo *sinfo);
                                     ^
memory/slab.c:4010:38: note: Function 'get_slabinfo' argument 1 names different: declaration 's' definition 'cachep'.
void get_slabinfo(struct kmem_cache *cachep, struct slabinfo *sinfo)
                                     ^
memory/slab.c:4047:65: style:inconclusive: Function 'slabinfo_show_stats' argument 2 names different: declaration 's' definition 'cachep'. [funcArgNamesDifferent]
void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)
                                                                ^
memory/slab.h:194:65: note: Function 'slabinfo_show_stats' argument 2 names different: declaration 's' definition 'cachep'.
void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *s);
                                                                ^
memory/slab.c:4047:65: note: Function 'slabinfo_show_stats' argument 2 names different: declaration 's' definition 'cachep'.
void slabinfo_show_stats(struct seq_file *m, struct kmem_cache *cachep)
                                                                ^
memory/slab.c:3334:16: style: Local variable 'page' shadows outer variable [shadowVariable]
  struct page *page;
               ^
memory/slab.c:3328:15: note: Shadowed declaration
 struct page *page;
              ^
memory/slab.c:3334:16: note: Shadow variable
  struct page *page;
               ^
memory/slab.c:2300:21: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 page->s_mem = addr + colour_off;
                    ^
memory/slab.c:2311:19: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  freelist = addr + (PAGE_SIZE << cachep->gfporder) -
                  ^
memory/slab.c:2496:64: portability: 'index_to_obj(cachep,page,cachep->num-1)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  page->freelist = index_to_obj(cachep, page, cachep->num - 1) +
                                                               ^
memory/slab.c:2544:25: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  page->freelist = objp + obj_offset(cachep);
                        ^
memory/slab.c:2749:8: style: The scope of the variable 'objp' can be reduced. [variableScope]
 void *objp;
       ^
memory/slab.c:335:37: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (unsigned long long*) (objp + obj_offset(cachep) -
                                    ^
memory/slab.c:335:58: portability: 'objp+obj_offset(cachep)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (unsigned long long*) (objp + obj_offset(cachep) -
                                                         ^
memory/slab.c:343:38: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  return (unsigned long long *)(objp + cachep->size -
                                     ^
memory/slab.c:346:38: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (unsigned long long *) (objp + cachep->size -
                                     ^
memory/slab.c:353:24: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (void **)(objp + cachep->size - BYTES_PER_WORD);
                       ^
memory/slab.c:1453:26: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *(unsigned char *)(addr + size - 1) = POISON_END;
                         ^
memory/slab.c:1453:33: portability: 'addr+size' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *(unsigned char *)(addr + size - 1) = POISON_END;
                                ^
memory/slab.c:2351:15: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
         objp + obj_offset(cachep));
              ^
memory/slab.c:2352:22: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   cachep->ctor(objp + obj_offset(cachep));
                     ^
memory/slab.c:2354:18: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    cachep, objp + obj_offset(cachep));
                 ^
memory/slab.c:2715:7: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 objp -= obj_offset(cachep);
      ^
memory/slab.c:2752:15: portability: 'next' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  objp = next - obj_offset(cachep);
              ^
memory/slab.c:3017:7: portability: 'objp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 objp += obj_offset(cachep);
      ^
memory/slab.c:1208:0: information: Skipping configuration 'CONFIG_MEMORY_HOTPLUG;CONFIG_NUMA' since the value of 'CONFIG_NUMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_NUMA) || num_possible_nodes() == 1)
^
memory/slab.c:1208:0: information: Skipping configuration 'CONFIG_MEMORY_HOTPLUG;CONFIG_NUMA;CONFIG_SMP' since the value of 'CONFIG_NUMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_NUMA) || num_possible_nodes() == 1)
^
memory/slab.c:1208:0: information: Skipping configuration 'CONFIG_NUMA' since the value of 'CONFIG_NUMA' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_NUMA) || num_possible_nodes() == 1)
^
memory/slab_common.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 26 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/slab_common.c:224:0: information: Skipping configuration 'CONFIG_DEBUG_SLAB;CONFIG_SLAB;CONFIG_SLUB_DEBUG' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_SLAB) && align &&
^
memory/slab_common.c:224:0: information: Skipping configuration 'CONFIG_MEMCG_KMEM;CONFIG_SLAB;CONFIG_SLUB_DEBUG' since the value of 'CONFIG_SLAB' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_SLAB) && align &&
^
memory/slob.c:471:16: style: The scope of the variable 'm' can be reduced. [variableScope]
 unsigned int *m;
               ^
memory/slob.c:497:19: portability: '(void*)m' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  ret = (void *)m + minalign;
                  ^
memory/slob.c:550:44: portability: 'block' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  unsigned int *m = (unsigned int *)(block - align);
                                           ^
memory/slob.c:578:29: portability: 'block' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 m = (unsigned int *)(block - align);
                            ^
memory/slob.c:653:29: portability: '(void*)slob_rcu' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 void *b = (void *)slob_rcu - (slob_rcu->size - sizeof(struct slob_rcu));
                            ^
memory/slob.c:663:16: portability: 'b' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  slob_rcu = b + (c->size - sizeof(struct slob_rcu));
               ^
memory/slub.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 42 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/slub.c:1802:2: warning: Either the condition '!page' is redundant or there is possible null pointer dereference: page. [nullPointerRedundantCheck]
 page->inuse = page->objects;
 ^
memory/slub.c:1808:6: note: Assuming that condition '!page' is not redundant
 if (!page)
     ^
memory/slub.c:1802:2: note: Null pointer dereference
 page->inuse = page->objects;
 ^
memory/slub.c:1803:2: warning: Either the condition '!page' is redundant or there is possible null pointer dereference: page. [nullPointerRedundantCheck]
 page->frozen = 1;
 ^
memory/slub.c:1808:6: note: Assuming that condition '!page' is not redundant
 if (!page)
     ^
memory/slub.c:1803:2: note: Null pointer dereference
 page->frozen = 1;
 ^
memory/slub.c:3556:26: style: The scope of the variable 'n' can be reduced. [variableScope]
 struct kmem_cache_node *n;
                         ^
memory/slub.c:3896:26: style: The scope of the variable 'n' can be reduced. [variableScope]
 struct kmem_cache_node *n;
                         ^
memory/slub.c:3910:26: style: The scope of the variable 'n' can be reduced. [variableScope]
 struct kmem_cache_node *n;
                         ^
memory/slub.c:4216:26: style: The scope of the variable 'n' can be reduced. [variableScope]
 struct kmem_cache_node *n;
                         ^
memory/slub.c:133:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += s->red_left_pad;
    ^
memory/slub.c:279:40: portability: 'object' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return freelist_dereference(s, object + s->offset);
                                       ^
memory/slub.c:284:18: portability: 'object' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 prefetch(object + s->offset);
                 ^
memory/slub.c:1794:13: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   next = p + s->size;
            ^
memory/slub.c:1834:3: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  for_each_object(p, s, page_address(page),
  ^
memory/slub.c:207:16: style: struct member 'track::addr' is never used. [unusedStructMember]
 unsigned long addr; /* Called from address */
               ^
memory/slub.c:211:6: style: struct member 'track::cpu' is never used. [unusedStructMember]
 int cpu;  /* Was running on cpu */
     ^
memory/slub.c:212:6: style: struct member 'track::pid' is never used. [unusedStructMember]
 int pid;  /* Pid context */
     ^
memory/slub.c:213:16: style: struct member 'track::when' is never used. [unusedStructMember]
 unsigned long when; /* When did the operation occur */
               ^
memory/slub.c:1924:13: style: Variable 'new.inuse' is assigned a value that is never used. [unreadVariable]
  new.inuse = page->objects;
            ^
memory/slub.c:5568:4: warning: Either the condition '!name' is redundant or there is possible null pointer dereference: p++. [nullPointerRedundantCheck]
 *p++ = ':';
   ^
memory/slub.c:5566:9: note: Assuming that condition '!name' is not redundant
 BUG_ON(!name);
        ^
memory/slub.c:5564:12: note: Assignment 'p=name', assigned value is 0
 char *p = name;
           ^
memory/slub.c:5568:4: note: Null pointer dereference
 *p++ = ':';
   ^
memory/slub.c:5568:4: warning: Either the condition '!name' is redundant or there is pointer arithmetic with NULL pointer. [nullPointerArithmeticRedundantCheck]
 *p++ = ':';
   ^
memory/slub.c:5566:9: note: Assuming that condition '!name' is not redundant
 BUG_ON(!name);
        ^
memory/slub.c:5564:12: note: Assignment 'p=name', assigned value is 0
 char *p = name;
           ^
memory/slub.c:5568:4: note: Null pointer addition
 *p++ = ':';
   ^
memory/slub.c:4916:8: style: Local variable 'node' shadows outer variable [shadowVariable]
   int node;
       ^
memory/slub.c:4901:6: note: Shadowed declaration
 int node;
     ^
memory/slub.c:4916:8: note: Shadow variable
   int node;
       ^
memory/sparse-vmemmap.c:223:9: style: The scope of the variable 'pgd' can be reduced. [variableScope]
 pgd_t *pgd;
        ^
memory/sparse-vmemmap.c:224:9: style: The scope of the variable 'p4d' can be reduced. [variableScope]
 p4d_t *p4d;
        ^
memory/sparse-vmemmap.c:225:9: style: The scope of the variable 'pud' can be reduced. [variableScope]
 pud_t *pud;
        ^
memory/sparse-vmemmap.c:226:9: style: The scope of the variable 'pmd' can be reduced. [variableScope]
 pmd_t *pmd;
        ^
memory/sparse-vmemmap.c:227:9: style: The scope of the variable 'pte' can be reduced. [variableScope]
 pte_t *pte;
        ^
memory/sparse.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/sparse.c:503:11: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (ptr + size > sparsemap_buf_end)
          ^
memory/sparse.c:509:24: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   sparsemap_buf = ptr + size;
                       ^
memory/sparse.c:555:26: portability: '(void*)usage' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  usage = (void *) usage + mem_section_usage_size();
                         ^
memory/sparse.c:145:2: style: int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information. [truncLongCastReturn]
 return (nid << SECTION_NID_SHIFT);
 ^
memory/sparse.c:736:16: style: The scope of the variable 'maps_section_nr' can be reduced. [variableScope]
 unsigned long maps_section_nr, removing_section_nr, i;
               ^
memory/sparse.c:736:33: style: The scope of the variable 'removing_section_nr' can be reduced. [variableScope]
 unsigned long maps_section_nr, removing_section_nr, i;
                                ^
memory/sparse.c:737:16: style: The scope of the variable 'magic' can be reduced. [variableScope]
 unsigned long magic, nr_pages;
               ^
memory/swap.c:362:17: style: The scope of the variable 'lruvec' can be reduced. [variableScope]
 struct lruvec *lruvec;
                ^
memory/swap_cgroup.c:206:16: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned long i, length;
               ^
memory/swap_state.c:196:9: style: Local variable 'entry' shadows outer argument [shadowArgument]
  void *entry = xas_store(&xas, shadow);
        ^
memory/swap_state.c:184:16: note: Shadowed declaration
   swp_entry_t entry, void *shadow)
               ^
memory/swap_state.c:196:9: note: Shadow variable
  void *entry = xas_store(&xas, shadow);
        ^
memory/swapfile.c:879:7: warning: Either the condition 'if(n_ret)' is redundant or the array 'slots[0]' is accessed at index -1, which is out of bounds. [negativeIndex]
 slots[n_ret++] = swp_entry(si->type, offset);
      ^
memory/swapfile.c:889:6: note: Assuming that condition 'if(n_ret)' is not redundant
  if (n_ret)
     ^
memory/swapfile.c:879:8: note: n_ret is incremented', new value is -1
 slots[n_ret++] = swp_entry(si->type, offset);
       ^
memory/swapfile.c:879:7: note: Negative array index
 slots[n_ret++] = swp_entry(si->type, offset);
      ^
memory/swapfile.c:3196:12: warning: Either the condition 'if(swap_file)' is redundant or there is possible null pointer dereference: swap_file. [nullPointerRedundantCheck]
 mapping = swap_file->f_mapping;
           ^
memory/swapfile.c:3395:5: note: Assuming that condition 'if(swap_file)' is not redundant
 if (swap_file)
    ^
memory/swapfile.c:3196:12: note: Null pointer dereference
 mapping = swap_file->f_mapping;
           ^
memory/swapfile.c:3356:30: warning: Either the condition 'if(name)' is redundant or there is possible null pointer dereference: name. [nullPointerRedundantCheck]
  p->pages<<(PAGE_SHIFT-10), name->name, p->prio,
                             ^
memory/swapfile.c:3402:5: note: Assuming that condition 'if(name)' is not redundant
 if (name)
    ^
memory/swapfile.c:3356:30: note: Null pointer dereference
  p->pages<<(PAGE_SHIFT-10), name->name, p->prio,
                             ^
memory/swapfile.c:3493:13: warning: Either the condition 'if(p)' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
 WRITE_ONCE(p->swap_map[offset], count | has_cache);
            ^
memory/swapfile.c:3497:5: note: Assuming that condition 'if(p)' is not redundant
 if (p)
    ^
memory/swapfile.c:3493:13: note: Null pointer dereference
 WRITE_ONCE(p->swap_map[offset], count | has_cache);
            ^
memory/swapfile.c:206:22: style: The scope of the variable 'se' can be reduced. [variableScope]
 struct swap_extent *se;
                     ^
memory/swapfile.c:470:35: style: The scope of the variable 'ci' can be reduced. [variableScope]
 struct swap_cluster_info *info, *ci;
                                  ^
memory/swapfile.c:471:15: style: The scope of the variable 'idx' can be reduced. [variableScope]
 unsigned int idx;
              ^
memory/swapfile.c:1374:18: style: The scope of the variable 'free_entries' can be reduced. [variableScope]
 unsigned int i, free_entries = 0;
                 ^
memory/swapfile.c:1375:16: style: The scope of the variable 'val' can be reduced. [variableScope]
 unsigned char val;
               ^
memory/swapfile.c:1475:28: style: The scope of the variable 'ci' can be reduced. [variableScope]
 struct swap_cluster_info *ci;
                           ^
memory/swapfile.c:1477:16: style: The scope of the variable 'offset' can be reduced. [variableScope]
 unsigned long offset;
               ^
memory/swapfile.c:1777:16: style: The scope of the variable 'count' can be reduced. [variableScope]
 unsigned char count;
               ^
memory/swapfile.c:2129:16: style: The scope of the variable 'count' can be reduced. [variableScope]
 unsigned char count;
               ^
memory/swapfile.c:2919:6: style: The scope of the variable 'error' can be reduced. [variableScope]
 int error;
     ^
memory/swapfile.c:2981:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
memory/swapfile.c:3060:15: style: The scope of the variable 'j' can be reduced. [variableScope]
 unsigned int j, k;
              ^
memory/swapfile.c:1043:26: style: Argument 'n_goal>1&&size==256' to function WARN_ON_ONCE is always 0. It does not matter what value 'n_goal' has. [knownArgument]
 WARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);
                         ^
memory/swapfile.c:1036:23: note: Assignment 'size=1', assigned value is 1
 unsigned long size = swap_entry_size(entry_size);
                      ^
memory/swapfile.c:1043:26: note: Argument 'n_goal>1&&size==256' to function WARN_ON_ONCE is always 0. It does not matter what value 'n_goal' has.
 WARN_ON_ONCE(n_goal > 1 && size == SWAPFILE_CLUSTER);
                         ^
memory/swapfile.c:327:0: information: Skipping configuration 'CONFIG_THP_SWAP' since the value of 'CONFIG_THP_SWAP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_THP_SWAP))
^
memory/swapfile.c:984:0: information: Skipping configuration 'CONFIG_THP_SWAP' since the value of 'CONFIG_THP_SWAP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_THP_SWAP)) {
^
memory/swapfile.c:1612:0: information: Skipping configuration 'CONFIG_THP_SWAP' since the value of 'CONFIG_THP_SWAP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page)))
^
memory/swapfile.c:1636:0: information: Skipping configuration 'CONFIG_THP_SWAP' since the value of 'CONFIG_THP_SWAP' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (!IS_ENABLED(CONFIG_THP_SWAP) || likely(!PageTransCompound(page))) {
^
memory/swapfile.c:2859:0: information: Skipping configuration 'MAX_SWAPFILES_CHECK' since the value of 'MAX_SWAPFILES_CHECK' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 MAX_SWAPFILES_CHECK();
^
memory/usercopy.c:37:38: portability: 'stack' is of type 'const void * const'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 const void * const stackend = stack + THREAD_SIZE;
                                     ^
memory/usercopy.c:41:10: portability: 'obj' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (obj + len <= stack || stackend <= obj)
         ^
memory/usercopy.c:49:36: portability: 'obj' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (obj < stack || stackend < obj + len)
                                   ^
memory/usercopy.c:164:24: portability: 'ptr' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 const void *end = ptr + n - 1;
                       ^
memory/usercopy.c:164:28: portability: 'ptr+n' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 const void *end = ptr + n - 1;
                           ^
memory/usercopy.c:211:11: portability: 'ptr' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 for (ptr += PAGE_SIZE; ptr <= end; ptr += PAGE_SIZE) {
          ^
memory/util.c:450:27: style: The scope of the variable 'limit' can be reduced. [variableScope]
 unsigned long locked_vm, limit;
                          ^
memory/vmalloc.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 16 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/vmalloc.c:2924:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  addr += n;
  ^
memory/vmalloc.c:2925:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  count -= n;
  ^
memory/vmalloc.c:3002:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  buf += n;
  ^
memory/vmalloc.c:3003:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  addr += n;
  ^
memory/vmalloc.c:3004:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  count -= n;
  ^
memory/vmalloc.c:90:6: style: The scope of the variable 'cleared' can be reduced. [variableScope]
 int cleared;
     ^
memory/vmalloc.c:115:6: style: The scope of the variable 'cleared' can be reduced. [variableScope]
 int cleared;
     ^
memory/vmalloc.c:138:6: style: The scope of the variable 'cleared' can be reduced. [variableScope]
 int cleared;
     ^
memory/vmalloc.c:299:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err = 0;
     ^
memory/vmalloc.c:868:20: style: The scope of the variable 'va' can be reduced. [variableScope]
 struct vmap_area *va;
                   ^
memory/vmalloc.c:2786:15: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct page *p;
              ^
memory/vmalloc.c:2825:15: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct page *p;
              ^
memory/vmalloc.c:2810:20: portability: 'map' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   memcpy(buf, map + offset, length);
                   ^
memory/vmalloc.c:2849:15: portability: 'map' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   memcpy(map + offset, buf, length);
              ^
memory/vmalloc.c:3056:8: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 kaddr += off;
       ^
memory/vmalloc.c:3067:9: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  kaddr += PAGE_SIZE;
        ^
memory/vmalloc.c:299:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0;
         ^
memory/vmalloc.c:339:0: information: Skipping configuration 'CONFIG_MODULES;MODULES_VADDR' since the value of 'MODULES_VADDR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (addr >= MODULES_VADDR && addr < MODULES_END)
^
memory/vmalloc.c:3163:16: style: The scope of the variable 'addr' can be reduced. [variableScope]
 unsigned long addr;
               ^
memory/vmscan.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 13 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/vmscan.c:3111:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/vmscan.c:3391:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/vmscan.c:3420:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/vmscan.c:3506:15: style: The scope of the variable 'zone' can be reduced. [variableScope]
 struct zone *zone;
              ^
memory/vmscan.c:4069:22: style: Local variable 'kswapd' shadows outer function [shadowFunction]
 struct task_struct *kswapd = NODE_DATA(nid)->kswapd;
                     ^
memory/vmscan.c:3871:12: note: Shadowed declaration
static int kswapd(void *p)
           ^
memory/vmscan.c:4069:22: note: Shadow variable
 struct task_struct *kswapd = NODE_DATA(nid)->kswapd;
                     ^
memory/vmscan.c:570:26: warning: Logical disjunction always evaluates to true: !(shrinker) || shrinker == (struct shrinker*)~0UL. [incorrectLogicOperator]
  if (unlikely(!shrinker || shrinker == SHRINKER_REGISTERING)) {
                         ^
memory/vmscan.c:570:26: style: Opposite expression on both sides of '||'. [oppositeExpression]
  if (unlikely(!shrinker || shrinker == SHRINKER_REGISTERING)) {
                         ^
memory/vmscan.c:2551:0: information: Skipping configuration 'CONFIG_CMA;CONFIG_COMPACTION' since the value of 'CONFIG_COMPACTION' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_COMPACTION) && sc->order &&
^
memory/vmscan.c:2948:0: information: Skipping configuration 'CONFIG_CMA;CONFIG_COMPACTION' since the value of 'CONFIG_COMPACTION' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   if (IS_ENABLED(CONFIG_COMPACTION) &&
^
memory/vmscan.c:4168:31: style: int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information. [truncLongCastAssignment]
 const unsigned long nr_pages = 1 << order;
                              ^
memory/vmstat.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 39 configurations. Use --force to check all configurations. [toomanyconfigs]

^
memory/vmstat.c:1725:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_MEMORY_BALLOON' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1728:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_MEMORY_BALLOON' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
^
memory/vmstat.c:1729:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_MEMORY_BALLOON' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
^
memory/vmstat.c:1762:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_MEMORY_BALLOON' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1776:0: information: Skipping configuration 'CONFIG_BALLOON_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_MEMORY_BALLOON' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (off == NR_VMSTAT_ITEMS - 1) {
^
memory/vmstat.c:2078:6: style: The scope of the variable 'index' can be reduced. [variableScope]
 int index;
     ^
memory/vmstat.c:2128:6: style: The scope of the variable 'index' can be reduced. [variableScope]
 int index;
     ^
memory/vmstat.c:1459:21: style: Condition '++freecount>=100000' is always false [knownConditionTrueFalse]
    if (++freecount >= 100000) {
                    ^
memory/vmstat.c:1442:30: note: Assignment 'freecount=0', assigned value is 0
   unsigned long freecount = 0;
                             ^
memory/vmstat.c:1459:21: note: Condition '++freecount>=100000' is always false
    if (++freecount >= 100000) {
                    ^
memory/vmstat.c:1749:4: style: Variable 'v' is assigned a value that is never used. [unreadVariable]
 v += NR_VM_WRITEBACK_STAT_ITEMS;
   ^
memory/vmstat.c:1725:0: information: Skipping configuration 'CONFIG_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1728:0: information: Skipping configuration 'CONFIG_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
^
memory/vmstat.c:1729:0: information: Skipping configuration 'CONFIG_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
^
memory/vmstat.c:1762:0: information: Skipping configuration 'CONFIG_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1776:0: information: Skipping configuration 'CONFIG_COMPACTION;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (off == NR_VMSTAT_ITEMS - 1) {
^
memory/vmstat.c:1725:0: information: Skipping configuration 'CONFIG_DEBUG_TLBFLUSH;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1728:0: information: Skipping configuration 'CONFIG_DEBUG_TLBFLUSH;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
^
memory/vmstat.c:1729:0: information: Skipping configuration 'CONFIG_DEBUG_TLBFLUSH;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
^
memory/vmstat.c:1762:0: information: Skipping configuration 'CONFIG_DEBUG_TLBFLUSH;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1776:0: information: Skipping configuration 'CONFIG_DEBUG_TLBFLUSH;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (off == NR_VMSTAT_ITEMS - 1) {
^
memory/vmstat.c:1725:0: information: Skipping configuration 'CONFIG_DEBUG_VM_VMACACHE;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1728:0: information: Skipping configuration 'CONFIG_DEBUG_VM_VMACACHE;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
^
memory/vmstat.c:1729:0: information: Skipping configuration 'CONFIG_DEBUG_VM_VMACACHE;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
^
memory/vmstat.c:1762:0: information: Skipping configuration 'CONFIG_DEBUG_VM_VMACACHE;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1776:0: information: Skipping configuration 'CONFIG_DEBUG_VM_VMACACHE;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (off == NR_VMSTAT_ITEMS - 1) {
^
memory/vmstat.c:1725:0: information: Skipping configuration 'CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1728:0: information: Skipping configuration 'CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 BUILD_BUG_ON(ARRAY_SIZE(vmstat_text) < NR_VMSTAT_ITEMS);
^
memory/vmstat.c:1729:0: information: Skipping configuration 'CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 v = kmalloc_array(NR_VMSTAT_ITEMS, sizeof(unsigned long), GFP_KERNEL);
^
memory/vmstat.c:1762:0: information: Skipping configuration 'CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (*pos >= NR_VMSTAT_ITEMS)
^
memory/vmstat.c:1776:0: information: Skipping configuration 'CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD;CONFIG_MEMCG;CONFIG_NUMA;CONFIG_PROC_FS;CONFIG_SYSFS;CONFIG_MEMCG;CONFIG_VM_EVENT_COUNTERS;CONFIG_TRANSPARENT_HUGEPAGE' since the value of 'CONFIG_VM_EVENT_COUNTERS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (off == NR_VMSTAT_ITEMS - 1) {
^
memory/workingset.c:192:29: style:inconclusive: Boolean expression 'workingset' is used in bitwise operation. Did you mean '||'? [bitwiseOnBoolean]
 eviction = (eviction << 1) | workingset;
                            ^
memory/z3fold.c:262:6: style: The scope of the variable 'locked' can be reduced. [variableScope]
 int locked = 0;
     ^
memory/z3fold.c:1453:31: style: Local variable 'slots' shadows outer variable [shadowVariable]
   struct z3fold_buddy_slots *slots = zhdr->slots;
                              ^
memory/z3fold.c:1337:28: note: Shadowed declaration
 struct z3fold_buddy_slots slots __attribute__((aligned(SLOTS_ALIGN)));
                           ^
memory/z3fold.c:1453:31: note: Shadow variable
   struct z3fold_buddy_slots *slots = zhdr->slots;
                              ^
memory/z3fold.c:665:21: portability: 'beg' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return memmove(beg + (dst_chunk << CHUNK_SHIFT),
                    ^
memory/z3fold.c:666:14: portability: 'beg' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
         beg + (zhdr->start_middle << CHUNK_SHIFT),
             ^
memory/z3fold.c:694:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += ZHDR_SIZE_ALIGNED;
    ^
memory/z3fold.c:699:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += zhdr->start_middle << CHUNK_SHIFT;
    ^
memory/z3fold.c:704:5: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  p += PAGE_SIZE - (zhdr->last_chunks << CHUNK_SHIFT);
    ^
memory/z3fold.c:727:6: portability: 'q' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   q += ZHDR_SIZE_ALIGNED;
     ^
memory/z3fold.c:733:6: portability: 'q' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   q += new_zhdr->start_middle << CHUNK_SHIFT;
     ^
memory/z3fold.c:737:6: portability: 'q' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   q += PAGE_SIZE - (new_zhdr->last_chunks << CHUNK_SHIFT);
     ^
memory/z3fold.c:1507:8: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr += ZHDR_SIZE_ALIGNED;
       ^
memory/z3fold.c:1510:8: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr += zhdr->start_middle << CHUNK_SHIFT;
       ^
memory/z3fold.c:1514:8: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr += PAGE_SIZE - (handle_to_chunks(handle) << CHUNK_SHIFT);
       ^
memory/zbud.c:432:6: style: The scope of the variable 'freechunks' can be reduced. [variableScope]
 int freechunks;
     ^
memory/zbud.c:505:29: style: Variable 'first_handle' is assigned a value that is never used. [unreadVariable]
 unsigned long first_handle = 0, last_handle = 0;
                            ^
memory/zbud.c:505:46: style: Variable 'last_handle' is assigned a value that is never used. [unreadVariable]
 unsigned long first_handle = 0, last_handle = 0;
                                             ^
memory/zsmalloc.c:2506:6: style: Condition 'ret' is always false [knownConditionTrueFalse]
 if (ret)
     ^
memory/zsmalloc.c:2505:22: note: Assignment 'ret=zsmalloc_mount()', assigned value is 0
 ret = zsmalloc_mount();
                     ^
memory/zsmalloc.c:2506:6: note: Condition 'ret' is always false
 if (ret)
     ^
memory/zsmalloc.c:1543:22: style: The scope of the variable 'size' can be reduced. [variableScope]
 int s_size, d_size, size;
                     ^
memory/zsmalloc.c:1606:16: style: The scope of the variable 'head' can be reduced. [variableScope]
 unsigned long head;
               ^
memory/zsmalloc.c:1650:16: style: The scope of the variable 'handle' can be reduced. [variableScope]
 unsigned long handle;
               ^
memory/zsmalloc.c:2266:21: style: The scope of the variable 'class' can be reduced. [variableScope]
 struct size_class *class;
                    ^
memory/zsmalloc.c:2309:21: style: The scope of the variable 'class' can be reduced. [variableScope]
 struct size_class *class;
                    ^
memory/zsmalloc.c:1148:19: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memcpy(buf, addr + off, sizes[0]);
                  ^
memory/zsmalloc.c:1178:14: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memcpy(addr + off, buf, sizes[0]);
             ^
memory/zsmalloc.c:1295:7: portability: 'ret' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  ret += ZS_HANDLE_SIZE;
      ^
memory/zsmalloc.c:1483:36: portability: 'vaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 link = (struct link_free *)(vaddr + f_offset);
                                   ^
memory/zsmalloc.c:1565:17: portability: 'd_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(d_addr + d_off, s_addr + s_off, size);
                ^
memory/zsmalloc.c:1565:33: portability: 's_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(d_addr + d_off, s_addr + s_off, size);
                                ^
memory/zsmalloc.c:1616:33: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  head = obj_to_head(page, addr + offset);
                                ^
memory/zsmalloc.c:942:7: style: Variable 'next' is assigned a value that is never used. [unreadVariable]
 next = page = get_first_page(zspage);
      ^
memory/zsmalloc.c:1970:35: portability: 's_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  head = obj_to_head(page, s_addr + pos);
                                  ^
memory/zsmalloc.c:1986:21: portability: 's_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 for (addr = s_addr + offset; addr < s_addr + pos;
                    ^
memory/zsmalloc.c:1987:11: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     addr += class->size) {
          ^
memory/zsmalloc.c:2034:21: portability: 's_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 for (addr = s_addr + offset; addr < s_addr + pos;
                    ^
memory/zsmalloc.c:2035:12: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      addr += class->size) {
           ^
memory/zsmalloc.c:255:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 struct size_class *size_class[ZS_SIZE_CLASSES];
^
memory/zsmalloc.c:539:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (likely(size > ZS_MIN_ALLOC_SIZE))
^
memory/zsmalloc.c:540:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  idx = DIV_ROUND_UP(size - ZS_MIN_ALLOC_SIZE,
^
memory/zsmalloc.c:543:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 return min_t(int, ZS_SIZE_CLASSES - 1, idx);
^
memory/zsmalloc.c:843:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 *page = pfn_to_page(obj >> OBJ_INDEX_BITS);
^
memory/zsmalloc.c:844:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 *obj_idx = (obj & OBJ_INDEX_MASK);
^
memory/zsmalloc.c:856:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 obj = page_to_pfn(page) << OBJ_INDEX_BITS;
^
memory/zsmalloc.c:857:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 obj |= obj_idx & OBJ_INDEX_MASK;
^
memory/zsmalloc.c:2268:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 for (i = ZS_SIZE_CLASSES - 1; i >= 0; i--) {
^
memory/zsmalloc.c:2314:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 for (i = ZS_SIZE_CLASSES - 1; i >= 0; i--) {
^
memory/zsmalloc.c:2379:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 for (i = ZS_SIZE_CLASSES - 1; i >= 0; i--) {
^
memory/zsmalloc.c:2386:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  size = ZS_MIN_ALLOC_SIZE + i * ZS_SIZE_CLASS_DELTA;
^
memory/zsmalloc.c:2476:0: information: Skipping configuration 'MAX_PHYSMEM_BITS' since the value of 'MAX_PHYSMEM_BITS' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 for (i = 0; i < ZS_SIZE_CLASSES; i++) {
^
memory/zswap.c:297:22: style: The scope of the variable 'entry' can be reduced. [variableScope]
 struct zswap_entry *entry;
                     ^
net/compat.c:42:10: style: The scope of the variable 'err' can be reduced. [variableScope]
 ssize_t err;
         ^
net/compat.c:298:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0, i;
         ^
net/dcb/dcbnl.c:1756:6: style: Redundant initialization for 'ret'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret = nlmsg_parse_deprecated(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,
     ^
net/dcb/dcbnl.c:1748:10: note: ret is initialized
 int ret = -EINVAL;
         ^
net/dcb/dcbnl.c:1756:6: note: ret is overwritten
 ret = nlmsg_parse_deprecated(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,
     ^
net/dccp/ackvec.c:51:60: style:inconclusive: Function 'dccp_ackvec_update_records' argument 2 names different: declaration 'seq' definition 'seqno'. [funcArgNamesDifferent]
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)
                                                           ^
net/dccp/ackvec.h:109:60: note: Function 'dccp_ackvec_update_records' argument 2 names different: declaration 'seq' definition 'seqno'.
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seq, u8 sum);
                                                           ^
net/dccp/ackvec.c:51:60: note: Function 'dccp_ackvec_update_records' argument 2 names different: declaration 'seq' definition 'seqno'.
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)
                                                           ^
net/dccp/ackvec.c:51:70: style:inconclusive: Function 'dccp_ackvec_update_records' argument 3 names different: declaration 'sum' definition 'nonce_sum'. [funcArgNamesDifferent]
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)
                                                                     ^
net/dccp/ackvec.h:109:68: note: Function 'dccp_ackvec_update_records' argument 3 names different: declaration 'sum' definition 'nonce_sum'.
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seq, u8 sum);
                                                                   ^
net/dccp/ackvec.c:51:70: note: Function 'dccp_ackvec_update_records' argument 3 names different: declaration 'sum' definition 'nonce_sum'.
int dccp_ackvec_update_records(struct dccp_ackvec *av, u64 seqno, u8 nonce_sum)
                                                                     ^
net/dccp/dccp.h:391:64: portability: '(void*)dh' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 struct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh +
                                                               ^
net/dccp/ccid.c:195:6: style: Condition 'err' is always false [knownConditionTrueFalse]
 if (err)
     ^
net/dccp/ccid.c:193:15: note: Assignment 'err=0', assigned value is 0
 int i, err = tfrc_lib_init();
              ^
net/dccp/ccid.c:195:6: note: Condition 'err' is always false
 if (err)
     ^
net/dccp/feat.c:639:7: style: The scope of the variable 'rpt' can be reduced. [variableScope]
 bool rpt;
      ^
net/dccp/feat.c:1405:11: style:inconclusive: Function 'dccp_feat_parse_options' argument 3 names different: declaration 'mand' definition 'mandatory'. [funcArgNamesDifferent]
       u8 mandatory, u8 opt, u8 feat, u8 *val, u8 len)
          ^
net/dccp/feat.h:112:11: note: Function 'dccp_feat_parse_options' argument 3 names different: declaration 'mand' definition 'mandatory'.
       u8 mand, u8 opt, u8 feat, u8 *val, u8 len);
          ^
net/dccp/feat.c:1405:11: note: Function 'dccp_feat_parse_options' argument 3 names different: declaration 'mand' definition 'mandatory'.
       u8 mandatory, u8 opt, u8 feat, u8 *val, u8 len)
          ^
net/dccp/feat.c:1510:66: style:inconclusive: Function 'dccp_feat_activate_values' argument 2 names different: declaration 'fn' definition 'fn_list'. [funcArgNamesDifferent]
int dccp_feat_activate_values(struct sock *sk, struct list_head *fn_list)
                                                                 ^
net/dccp/dccp.h:463:66: note: Function 'dccp_feat_activate_values' argument 2 names different: declaration 'fn' definition 'fn_list'.
int dccp_feat_activate_values(struct sock *sk, struct list_head *fn);
                                                                 ^
net/dccp/feat.c:1510:66: note: Function 'dccp_feat_activate_values' argument 2 names different: declaration 'fn' definition 'fn_list'.
int dccp_feat_activate_values(struct sock *sk, struct list_head *fn_list)
                                                                 ^
net/dccp/minisocks.c:254:42: style:inconclusive: Function 'dccp_reqsk_init' argument 1 names different: declaration 'rq' definition 'req'. [funcArgNamesDifferent]
int dccp_reqsk_init(struct request_sock *req,
                                         ^
net/dccp/dccp.h:260:42: note: Function 'dccp_reqsk_init' argument 1 names different: declaration 'rq' definition 'req'.
int dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,
                                         ^
net/dccp/minisocks.c:254:42: note: Function 'dccp_reqsk_init' argument 1 names different: declaration 'rq' definition 'req'.
int dccp_reqsk_init(struct request_sock *req,
                                         ^
net/dccp/options.c:365:37: warning: Possible null pointer dereference: dp [nullPointer]
  elapsed_time = dccp_timestamp() - dp->dccps_timestamp_time;
                                    ^
net/dccp/options.c:604:40: note: Calling function 'dccp_insert_option_timestamp_echo', 1st argument 'NULL' value is 0
     dccp_insert_option_timestamp_echo(NULL, dreq, skb))
                                       ^
net/dccp/options.c:365:37: note: Null pointer dereference
  elapsed_time = dccp_timestamp() - dp->dccps_timestamp_time;
                                    ^
net/dccp/options.c:366:24: warning: Possible null pointer dereference: dp [nullPointer]
  tstamp_echo  = htonl(dp->dccps_timestamp_echo);
                       ^
net/dccp/options.c:604:40: note: Calling function 'dccp_insert_option_timestamp_echo', 1st argument 'NULL' value is 0
     dccp_insert_option_timestamp_echo(NULL, dreq, skb))
                                       ^
net/dccp/options.c:366:24: note: Null pointer dereference
  tstamp_echo  = htonl(dp->dccps_timestamp_echo);
                       ^
net/dccp/options.c:367:3: warning: Possible null pointer dereference: dp [nullPointer]
  dp->dccps_timestamp_echo = 0;
  ^
net/dccp/options.c:604:40: note: Calling function 'dccp_insert_option_timestamp_echo', 1st argument 'NULL' value is 0
     dccp_insert_option_timestamp_echo(NULL, dreq, skb))
                                       ^
net/dccp/options.c:367:3: note: Null pointer dereference
  dp->dccps_timestamp_echo = 0;
  ^
net/dccp/output.c:315:14: style: The scope of the variable 'rc' can be reduced. [variableScope]
 long delay, rc;
             ^
net/dccp/output.c:462:70: style:inconclusive: Function 'dccp_ctl_make_reset' argument 2 names different: declaration 'skb' definition 'rcv_skb'. [funcArgNamesDifferent]
struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *rcv_skb)
                                                                     ^
net/dccp/dccp.h:310:70: note: Function 'dccp_ctl_make_reset' argument 2 names different: declaration 'skb' definition 'rcv_skb'.
struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *skb);
                                                                     ^
net/dccp/output.c:462:70: note: Function 'dccp_ctl_make_reset' argument 2 names different: declaration 'skb' definition 'rcv_skb'.
struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *rcv_skb)
                                                                     ^
net/dccp/output.c:639:48: style:inconclusive: Function 'dccp_send_sync' argument 2 names different: declaration 'seq' definition 'ackno'. [funcArgNamesDifferent]
void dccp_send_sync(struct sock *sk, const u64 ackno,
                                               ^
net/dccp/dccp.h:227:48: note: Function 'dccp_send_sync' argument 2 names different: declaration 'seq' definition 'ackno'.
void dccp_send_sync(struct sock *sk, const u64 seq,
                                               ^
net/dccp/output.c:639:48: note: Function 'dccp_send_sync' argument 2 names different: declaration 'seq' definition 'ackno'.
void dccp_send_sync(struct sock *sk, const u64 ackno,
                                               ^
net/dccp/trace.h:40:3: error: syntax error: keyword 'if' is not allowed in global scope [syntaxError]
  if (ccid_get_current_tx_ccid(dccp_sk(sk)) == DCCPC_CCID3)
  ^
net/dccp/qpolicy.c:41:12: style: Condition 'best==NULL' is always true [knownConditionTrueFalse]
  if (best == NULL || skb->priority > best->priority)
           ^
net/dccp/qpolicy.c:38:31: note: Assignment 'best=NULL', assigned value is 0
 struct sk_buff *skb, *best = NULL;
                              ^
net/dccp/qpolicy.c:41:12: note: Condition 'best==NULL' is always true
  if (best == NULL || skb->priority > best->priority)
           ^
net/dccp/qpolicy.c:51:13: style: Condition 'worst==NULL' is always true [knownConditionTrueFalse]
  if (worst == NULL || skb->priority < worst->priority)
            ^
net/dccp/qpolicy.c:48:32: note: Assignment 'worst=NULL', assigned value is 0
 struct sk_buff *skb, *worst = NULL;
                               ^
net/dccp/qpolicy.c:51:13: note: Condition 'worst==NULL' is always true
  if (worst == NULL || skb->priority < worst->priority)
            ^
net/decnet/af_decnet.c:662:2: warning: %hd in format string (no. 1) requires 'short' but the argument type is 'unsigned short'. [invalidPrintfArgType_sint]
 sprintf(buf, "%hd.%hd", area, node);
 ^
net/decnet/af_decnet.c:662:2: warning: %hd in format string (no. 2) requires 'short' but the argument type is 'unsigned short'. [invalidPrintfArgType_sint]
 sprintf(buf, "%hd.%hd", area, node);
 ^
net/decnet/af_decnet.c:1252:15: warning:inconclusive: Either the condition 'skb' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
    amount += skb->len;
              ^
net/decnet/af_decnet.c:1248:7: note: Assuming that condition 'skb' is not redundant
  if (skb) {
      ^
net/decnet/af_decnet.c:1252:15: note: Null pointer dereference
    amount += skb->len;
              ^
net/decnet/af_decnet.c:844:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EAGAIN;
      ^
net/decnet/af_decnet.c:841:7: note: err is assigned
  err = sock_intr_errno(*timeo);
      ^
net/decnet/af_decnet.c:844:7: note: err is overwritten
  err = -EAGAIN;
      ^
net/decnet/af_decnet.c:885:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -ETIMEDOUT;
      ^
net/decnet/af_decnet.c:882:7: note: err is assigned
  err = sock_intr_errno(*timeo);
      ^
net/decnet/af_decnet.c:885:7: note: err is overwritten
  err = -ETIMEDOUT;
      ^
net/decnet/af_decnet.c:1053:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = sock_intr_errno(*timeo);
      ^
net/decnet/af_decnet.c:1050:7: note: err is assigned
  err = -EINVAL;
      ^
net/decnet/af_decnet.c:1053:7: note: err is overwritten
  err = sock_intr_errno(*timeo);
      ^
net/decnet/af_decnet.c:1056:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EAGAIN;
      ^
net/decnet/af_decnet.c:1053:7: note: err is assigned
  err = sock_intr_errno(*timeo);
      ^
net/decnet/af_decnet.c:1056:7: note: err is overwritten
  err = -EAGAIN;
      ^
net/decnet/af_decnet.c:1965:6: style: Variable 'mss' is reassigned a value before the old one has been used. [redundantAssignment]
 mss = dn_current_mss(sk, flags);
     ^
net/decnet/af_decnet.c:1962:6: note: mss is assigned
 mss = scp->segsize_rem;
     ^
net/decnet/af_decnet.c:1965:6: note: mss is overwritten
 mss = dn_current_mss(sk, flags);
     ^
net/decnet/af_decnet.c:246:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/decnet/af_decnet.c:723:27: style: The scope of the variable 'ldev' can be reduced. [variableScope]
 struct net_device *dev, *ldev;
                          ^
net/decnet/dn_dev.c:332:16: style: The scope of the variable 'mac_addr' can be reduced. [variableScope]
 unsigned char mac_addr[6];
               ^
net/decnet/dn_dev.c:360:16: style: The scope of the variable 'mac_addr' can be reduced. [variableScope]
 unsigned char mac_addr[6];
               ^
net/decnet/dn_dev.c:1043:20: style: The scope of the variable 'ifa' can be reduced. [variableScope]
 struct dn_ifaddr *ifa;
                   ^
net/decnet/dn_dev.c:1142:9: style: Local variable 'addr' shadows outer variable [shadowVariable]
 __le16 addr = decnet_address;
        ^
net/decnet/dn_dev.c:1384:12: note: Shadowed declaration
static int addr[2];
           ^
net/decnet/dn_dev.c:1142:9: note: Shadow variable
 __le16 addr = decnet_address;
        ^
net/decnet/dn_dev.c:254:6: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 int tmp, old;
     ^
net/decnet/dn_fib.c:635:17: style: The scope of the variable 'dn_db' can be reduced. [variableScope]
 struct dn_dev *dn_db;
                ^
net/decnet/dn_neigh.c:527:46: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 *(s->rs) = neigh->nud_state & NUD_CONNECTED ? 0x80 : 0x0;
                                             ^
net/decnet/dn_route.c:1171:20: warning: Either the condition 'if(dev_out)' is redundant or there is possible null pointer dereference: dev_out. [nullPointerRedundantCheck]
 fld.flowidn_oif = dev_out->ifindex;
                   ^
net/decnet/dn_route.c:1221:5: note: Assuming that condition 'if(dev_out)' is not redundant
 if (dev_out)
    ^
net/decnet/dn_route.c:1171:20: note: Null pointer dereference
 fld.flowidn_oif = dev_out->ifindex;
                   ^
net/decnet/dn_route.c:1058:23: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
 if (try_hard || (err = dn_fib_lookup(&fld, &res)) != 0) {
                      ^
net/decnet/dn_route.c:1057:6: note: err is assigned
 err = -ESRCH;
     ^
net/decnet/dn_route.c:1058:23: note: err is overwritten
 if (try_hard || (err = dn_fib_lookup(&fld, &res)) != 0) {
                      ^
net/decnet/dn_route.c:930:18: style: The comparison 'best_match == 0' is always true. [knownConditionTrueFalse]
  if (best_match == 0)
                 ^
net/decnet/dn_route.c:913:19: note: 'best_match' is assigned value '0' here.
 int best_match = 0;
                  ^
net/decnet/dn_route.c:930:18: note: The comparison 'best_match == 0' is always true.
  if (best_match == 0)
                 ^
net/dsa/dsa2.c:177:19: style: The scope of the variable 'link_dp' can be reduced. [variableScope]
 struct dsa_port *link_dp;
                  ^
net/dsa/dsa2.c:178:19: style: The scope of the variable 'dl' can be reduced. [variableScope]
 struct dsa_link *dl;
                  ^
net/dsa/dsa2.c:495:19: style: The scope of the variable 'dp' can be reduced. [variableScope]
 struct dsa_port *dp;
                  ^
net/dsa/dsa2.c:694:15: style: The scope of the variable 'mdp_upstream' can be reduced. [variableScope]
 unsigned int mdp_upstream;
              ^
net/dsa/dsa2.c:828:19: style: The scope of the variable 'dp' can be reduced. [variableScope]
 struct dsa_port *dp;
                  ^
net/dsa/dsa2.c:880:19: style: The scope of the variable 'dp' can be reduced. [variableScope]
 struct dsa_port *dp;
                  ^
net/dsa/dsa2.c:881:17: style: The scope of the variable 'dev' can be reduced. [variableScope]
 struct device *dev;
                ^
net/dsa/dsa2.c:882:14: style: The scope of the variable 'name' can be reduced. [variableScope]
 const char *name;
             ^
net/dsa/master.c:150:18: style: The scope of the variable 'count' can be reduced. [variableScope]
 int mcount = 0, count;
                 ^
net/dsa/master.c:151:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/dsa/master.c:153:11: style: The scope of the variable 'ndata' can be reduced. [variableScope]
 uint8_t *ndata;
          ^
net/dsa/master.c:57:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += regs->len;
       ^
net/dsa/master.c:62:7: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 data += sizeof(*cpu_info);
      ^
net/dsa/master.c:64:7: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 data += sizeof(*cpu_regs);
      ^
net/dsa/port.c:87:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/dsa/port.c:201:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err, i;
     ^
net/dsa/port.c:715:22: style: The scope of the variable 'phy_np' can be reduced. [variableScope]
 struct device_node *phy_np;
                     ^
net/dsa/slave.c:2022:7: style: The scope of the variable 'err' can be reduced. [variableScope]
  int err;
      ^
net/dsa/slave.c:1781:39: style:inconclusive: Function 'dsa_slave_create' argument 1 names different: declaration 'dp' definition 'port'. [funcArgNamesDifferent]
int dsa_slave_create(struct dsa_port *port)
                                      ^
net/dsa/dsa_priv.h:173:39: note: Function 'dsa_slave_create' argument 1 names different: declaration 'dp' definition 'port'.
int dsa_slave_create(struct dsa_port *dp);
                                      ^
net/dsa/slave.c:1781:39: note: Function 'dsa_slave_create' argument 1 names different: declaration 'dp' definition 'port'.
int dsa_slave_create(struct dsa_port *port)
                                      ^
net/dsa/slave.c:136:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
      dev->flags & IFF_ALLMULTI ? 1 : -1);
                                ^
net/dsa/slave.c:139:35: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
         dev->flags & IFF_PROMISC ? 1 : -1);
                                  ^
net/dsa/switch.c:112:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err, i;
     ^
net/dsa/switch.c:112:11: style: The scope of the variable 'i' can be reduced. [variableScope]
 int err, i;
          ^
net/dsa/tag_8021q.c:302:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc, port;
     ^
net/dsa/tag_8021q.c:431:30: style: Local variable 'other_ctx' shadows outer argument [shadowArgument]
   struct dsa_8021q_context *other_ctx = c->other_ctx;
                             ^
net/dsa/tag_8021q.c:421:36: note: Shadowed declaration
         struct dsa_8021q_context *other_ctx,
                                   ^
net/dsa/tag_8021q.c:431:30: note: Shadow variable
   struct dsa_8021q_context *other_ctx = c->other_ctx;
                             ^
net/dsa/tag_8021q.c:432:8: style: Local variable 'other_port' shadows outer argument [shadowArgument]
   int other_port = c->other_port;
       ^
net/dsa/tag_8021q.c:422:14: note: Shadowed declaration
         int other_port)
             ^
net/dsa/tag_8021q.c:432:8: note: Shadow variable
   int other_port = c->other_port;
       ^
net/ethtool/bitset.c:437:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ethtool/ioctl.c:2350:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  useraddr += sizeof(coalesce);
  ^
net/ethtool/ioctl.c:2402:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  useraddr += sizeof(coalesce);
  ^
net/ethtool/ioctl.c:2331:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ethtool/ioctl.c:80:22: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sizeaddr = useraddr + offsetof(struct ethtool_gfeatures, size);
                     ^
net/ethtool/ioctl.c:89:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(cmd);
          ^
net/ethtool/ioctl.c:105:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(cmd);
          ^
net/ethtool/ioctl.c:799:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += offsetof(struct ethtool_sset_info, data);
          ^
net/ethtool/ioctl.c:901:12: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  useraddr += offsetof(struct ethtool_rxnfc, rule_locs);
           ^
net/ethtool/ioctl.c:956:16: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      useraddr + offsetof(struct ethtool_rxfh_indir, size),
               ^
net/ethtool/ioctl.c:960:28: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (copy_to_user(useraddr + offsetof(struct ethtool_rxfh_indir, size),
                           ^
net/ethtool/ioctl.c:979:28: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (copy_to_user(useraddr +
                           ^
net/ethtool/ioctl.c:1008:16: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      useraddr + offsetof(struct ethtool_rxfh_indir, size),
               ^
net/ethtool/ioctl.c:1029:18: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
        useraddr + ringidx_offset,
                 ^
net/ethtool/ioctl.c:1116:28: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, hfunc),
                           ^
net/ethtool/ioctl.c:1119:35: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 } else if (copy_to_user(useraddr +
                                  ^
net/ethtool/ioctl.c:1193:18: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
        useraddr + rss_cfg_offset,
                 ^
net/ethtool/ioctl.c:1211:17: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       useraddr + rss_cfg_offset + indir_bytes,
                ^
net/ethtool/ioctl.c:1226:28: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, rss_context),
                           ^
net/ethtool/ioctl.c:1408:34: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 void __user *userbuf = useraddr + sizeof(eeprom);
                                 ^
net/ethtool/ioctl.c:1444:35: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 eeprom.len = userbuf - (useraddr + sizeof(eeprom));
                                  ^
net/ethtool/ioctl.c:1469:34: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 void __user *userbuf = useraddr + sizeof(eeprom);
                                 ^
net/ethtool/ioctl.c:1820:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(gstrings);
          ^
net/ethtool/ioctl.c:1919:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(stats);
          ^
net/ethtool/ioctl.c:1977:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(stats);
          ^
net/ethtool/ioctl.c:2000:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(epaddr);
          ^
net/ethtool/ioctl.c:2156:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += offsetof(struct ethtool_dump, data);
          ^
net/ethtool/ioctl.c:2290:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(tuna);
          ^
net/ethtool/ioctl.c:2315:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(tuna);
          ^
net/ethtool/ioctl.c:2337:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(*per_queue_opt);
          ^
net/ethtool/ioctl.c:2350:12: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  useraddr += sizeof(coalesce);
           ^
net/ethtool/ioctl.c:2371:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(*per_queue_opt);
          ^
net/ethtool/ioctl.c:2402:12: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  useraddr += sizeof(coalesce);
           ^
net/ethtool/ioctl.c:2488:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(tuna);
          ^
net/ethtool/ioctl.c:2515:11: portability: 'useraddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 useraddr += sizeof(tuna);
          ^
net/ethtool/netlink.c:49:32: style:inconclusive: Function 'ethnl_parse_header_dev_get' argument 2 names different: declaration 'nest' definition 'header'. [funcArgNamesDifferent]
          const struct nlattr *header, struct net *net,
                               ^
net/ethtool/netlink.h:14:32: note: Function 'ethnl_parse_header_dev_get' argument 2 names different: declaration 'nest' definition 'header'.
          const struct nlattr *nest, struct net *net,
                               ^
net/ethtool/netlink.c:49:32: note: Function 'ethnl_parse_header_dev_get' argument 2 names different: declaration 'nest' definition 'header'.
          const struct nlattr *header, struct net *net,
                               ^
net/hsr/hsr_main.h:268:17: style: The scope of the variable 'ethhdr' can be reduced. [variableScope]
 struct ethhdr *ethhdr;
                ^
net/hsr/hsr_forward.c:437:16: style: The scope of the variable 'irqflags' can be reduced. [variableScope]
 unsigned long irqflags;
               ^
net/hsr/hsr_framereg.c:210:18: style: The scope of the variable 'rct' can be reduced. [variableScope]
 struct prp_rct *rct;
                 ^
net/hsr/hsr_slave.c:159:23: style:inconclusive: Function 'hsr_add_port' argument 3 names different: declaration 'pt' definition 'type'. [funcArgNamesDifferent]
   enum hsr_port_type type, struct netlink_ext_ack *extack)
                      ^
net/hsr/hsr_slave.h:18:23: note: Function 'hsr_add_port' argument 3 names different: declaration 'pt' definition 'type'.
   enum hsr_port_type pt, struct netlink_ext_ack *extack);
                      ^
net/hsr/hsr_slave.c:159:23: note: Function 'hsr_add_port' argument 3 names different: declaration 'pt' definition 'type'.
   enum hsr_port_type type, struct netlink_ext_ack *extack)
                      ^
net/ieee802154/6lowpan/reassembly.c:530:6: style: Condition 'ret' is always false [knownConditionTrueFalse]
 if (ret)
     ^
net/ieee802154/6lowpan/reassembly.c:529:36: note: Assignment 'ret=lowpan_frags_sysctl_register()', assigned value is 0
 ret = lowpan_frags_sysctl_register();
                                   ^
net/ieee802154/6lowpan/reassembly.c:530:6: note: Condition 'ret' is always false
 if (ret)
     ^
net/ieee802154/6lowpan/reassembly.c:164:25: style:inconclusive: Function 'lowpan_frag_reasm' argument 3 names different: declaration 'prev' definition 'prev_tail'. [funcArgNamesDifferent]
        struct sk_buff *prev_tail, struct net_device *ldev)
                        ^
net/ieee802154/6lowpan/reassembly.c:34:25: note: Function 'lowpan_frag_reasm' argument 3 names different: declaration 'prev' definition 'prev_tail'.
        struct sk_buff *prev,  struct net_device *ldev);
                        ^
net/ieee802154/6lowpan/reassembly.c:164:25: note: Function 'lowpan_frag_reasm' argument 3 names different: declaration 'prev' definition 'prev_tail'.
        struct sk_buff *prev_tail, struct net_device *ldev)
                        ^
net/ieee802154/6lowpan/tx.c:106:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/ieee802154/6lowpan/tx.c:33:66: style:inconclusive: Function 'lowpan_header_create' argument 2 names different: declaration 'dev' definition 'ldev'. [funcArgNamesDifferent]
int lowpan_header_create(struct sk_buff *skb, struct net_device *ldev,
                                                                 ^
net/ieee802154/6lowpan/6lowpan_i.h:40:66: note: Function 'lowpan_header_create' argument 2 names different: declaration 'dev' definition 'ldev'.
int lowpan_header_create(struct sk_buff *skb, struct net_device *dev,
                                                                 ^
net/ieee802154/6lowpan/tx.c:33:66: note: Function 'lowpan_header_create' argument 2 names different: declaration 'dev' definition 'ldev'.
int lowpan_header_create(struct sk_buff *skb, struct net_device *ldev,
                                                                 ^
net/ieee802154/6lowpan/tx.c:34:38: style:inconclusive: Function 'lowpan_header_create' argument 4 names different: declaration '_daddr' definition 'daddr'. [funcArgNamesDifferent]
    unsigned short type, const void *daddr,
                                     ^
net/ieee802154/6lowpan/6lowpan_i.h:41:38: note: Function 'lowpan_header_create' argument 4 names different: declaration '_daddr' definition 'daddr'.
    unsigned short type, const void *_daddr,
                                     ^
net/ieee802154/6lowpan/tx.c:34:38: note: Function 'lowpan_header_create' argument 4 names different: declaration '_daddr' definition 'daddr'.
    unsigned short type, const void *daddr,
                                     ^
net/ieee802154/6lowpan/tx.c:35:17: style:inconclusive: Function 'lowpan_header_create' argument 5 names different: declaration '_saddr' definition 'saddr'. [funcArgNamesDifferent]
    const void *saddr, unsigned int len)
                ^
net/ieee802154/6lowpan/6lowpan_i.h:42:17: note: Function 'lowpan_header_create' argument 5 names different: declaration '_saddr' definition 'saddr'.
    const void *_saddr, unsigned int len);
                ^
net/ieee802154/6lowpan/tx.c:35:17: note: Function 'lowpan_header_create' argument 5 names different: declaration '_saddr' definition 'saddr'.
    const void *saddr, unsigned int len)
                ^
net/ieee802154/6lowpan/tx.c:250:65: style:inconclusive: Function 'lowpan_xmit' argument 2 names different: declaration 'dev' definition 'ldev'. [funcArgNamesDifferent]
netdev_tx_t lowpan_xmit(struct sk_buff *skb, struct net_device *ldev)
                                                                ^
net/ieee802154/6lowpan/6lowpan_i.h:43:65: note: Function 'lowpan_xmit' argument 2 names different: declaration 'dev' definition 'ldev'.
netdev_tx_t lowpan_xmit(struct sk_buff *skb, struct net_device *dev);
                                                                ^
net/ieee802154/6lowpan/tx.c:250:65: note: Function 'lowpan_xmit' argument 2 names different: declaration 'dev' definition 'ldev'.
netdev_tx_t lowpan_xmit(struct sk_buff *skb, struct net_device *ldev)
                                                                ^
net/ieee802154/nl-mac.c:822:6: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
  rc = -EOPNOTSUPP;
     ^
net/ieee802154/nl-mac.c:815:9: note: rc is initialized
 int rc = -EINVAL;
        ^
net/ieee802154/nl-mac.c:822:6: note: rc is overwritten
  rc = -EOPNOTSUPP;
     ^
net/ieee802154/nl-mac.c:529:5: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 rc = ops->set_mac_params(dev, &params);
    ^
net/ieee802154/trace.h:143:3: error: syntax error: keyword 'while' is not allowed in global scope [syntaxError]
  WPAN_CCA_ASSIGN;
  ^
net/ieee802154/socket.c:804:8: style: Condition 'prev' is always false [knownConditionTrueFalse]
   if (prev) {
       ^
net/ieee802154/socket.c:788:27: note: Assignment 'prev=NULL', assigned value is 0
 struct sock *sk, *prev = NULL;
                          ^
net/ieee802154/socket.c:804:8: note: Condition 'prev' is always false
   if (prev) {
       ^
net/ife/ife.c:141:17: portability: 'skbdata' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return skbdata + sizeof(struct meta_tlvhdr);
                ^
net/ife/ife.c:152:17: portability: 'skbdata' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return skbdata + tlvlen;
                ^
net/ipv4/af_inet.c:1306:12: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
      (err = inet_sk_reselect_saddr(sk)) != 0)
           ^
net/ipv4/af_inet.c:1295:7: note: err is assigned
  err = PTR_ERR(rt);
      ^
net/ipv4/af_inet.c:1306:12: note: err is overwritten
      (err = inet_sk_reselect_saddr(sk)) != 0)
           ^
net/ipv4/af_inet.c:562:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/af_inet.c:1696:42: portability: 'bhptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 syncp = (struct u64_stats_sync *)(bhptr + syncp_offset);
                                         ^
net/ipv4/ah4.c:46:13: portability: 'tmp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return tmp + offset;
            ^
net/ipv4/arp.c:217:48: style:inconclusive: Function 'arp_key_eq' argument 1 names different: declaration 'n' definition 'neigh'. [funcArgNamesDifferent]
static bool arp_key_eq(const struct neighbour *neigh, const void *pkey)
                                               ^
net/ipv4/arp.c:123:48: note: Function 'arp_key_eq' argument 1 names different: declaration 'n' definition 'neigh'.
static bool arp_key_eq(const struct neighbour *n, const void *pkey);
                                               ^
net/ipv4/arp.c:217:48: note: Function 'arp_key_eq' argument 1 names different: declaration 'n' definition 'neigh'.
static bool arp_key_eq(const struct neighbour *neigh, const void *pkey)
                                               ^
net/ipv4/bpf_tcp_ca.c:219:43: portability: 'udata' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 prog_fd = (int)(*(unsigned long *)(udata + moff));
                                          ^
net/ipv4/cipso_ipv4.c:1866:10: style: Redundant initialization for 'ret_val'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);
         ^
net/ipv4/cipso_ipv4.c:1841:14: note: ret_val is initialized
 int ret_val = -EPERM;
             ^
net/ipv4/cipso_ipv4.c:1866:10: note: ret_val is overwritten
 ret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);
         ^
net/ipv4/cipso_ipv4.c:1943:10: style: Redundant initialization for 'ret_val'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);
         ^
net/ipv4/cipso_ipv4.c:1926:14: note: ret_val is initialized
 int ret_val = -EPERM;
             ^
net/ipv4/cipso_ipv4.c:1943:10: note: ret_val is overwritten
 ret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);
         ^
net/ipv4/cipso_ipv4.c:858:6: style: The scope of the variable 'ret_val' can be reduced. [variableScope]
 int ret_val;
     ^
net/ipv4/cipso_ipv4.c:990:6: style: The scope of the variable 'ret_val' can be reduced. [variableScope]
 int ret_val;
     ^
net/ipv4/cipso_ipv4.c:1122:6: style: The scope of the variable 'ret_val' can be reduced. [variableScope]
 int ret_val;
     ^
net/ipv4/cipso_ipv4.c:1817:6: error: Uninitialized variable: ret_val [uninitvar]
 if (ret_val < 0)
     ^
net/ipv4/cipso_ipv4.c:1775:14: note: Assuming condition is false
 if (buf_len <= CIPSO_V4_HDR_LEN)
             ^
net/ipv4/cipso_ipv4.c:1817:6: note: Uninitialized variable: ret_val
 if (ret_val < 0)
     ^
net/ipv4/cipso_ipv4.c:300:14: style: Variable 'ret_val' is assigned a value that is never used. [unreadVariable]
 int ret_val = -EPERM;
             ^
net/ipv4/devinet.c:1277:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  len  -= size;
  ^
net/ipv4/devinet.c:1384:7: style: Condition '!addr' is always true [knownConditionTrueFalse]
  if (!addr &&
      ^
net/ipv4/devinet.c:1375:16: note: Assignment 'addr=0', assigned value is 0
 __be32 addr = 0;
               ^
net/ipv4/devinet.c:1384:7: note: Condition '!addr' is always true
  if (!addr &&
      ^
net/ipv4/devinet.c:1388:8: style: Condition 'same' is always false [knownConditionTrueFalse]
   if (same)
       ^
net/ipv4/devinet.c:1376:13: note: Assignment 'same=0', assigned value is 0
 int same = 0;
            ^
net/ipv4/devinet.c:1388:8: note: Condition 'same' is always false
   if (same)
       ^
net/ipv4/devinet.c:1391:7: style: Condition '!same' is always true [knownConditionTrueFalse]
  if (!same) {
      ^
net/ipv4/devinet.c:1376:13: note: Assignment 'same=0', assigned value is 0
 int same = 0;
            ^
net/ipv4/devinet.c:1388:8: note: Assuming condition is false
   if (same)
       ^
net/ipv4/devinet.c:1391:7: note: Condition '!same' is always true
  if (!same) {
      ^
net/ipv4/devinet.c:1488:15: style: Condition 'named++==0' is always true [knownConditionTrueFalse]
  if (named++ == 0)
              ^
net/ipv4/devinet.c:1481:14: note: Assignment 'named=0', assigned value is 0
 int named = 0;
             ^
net/ipv4/devinet.c:1488:15: note: Condition 'named++==0' is always true
  if (named++ == 0)
              ^
net/ipv4/devinet.c:1137:8: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
   ret = 0;
       ^
net/ipv4/devinet.c:1134:8: note: ret is assigned
   ret = -EADDRNOTAVAIL;
       ^
net/ipv4/devinet.c:1137:8: note: ret is overwritten
   ret = 0;
       ^
net/ipv4/devinet.c:1151:8: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
   ret = -ENOBUFS;
       ^
net/ipv4/devinet.c:1146:7: note: ret is assigned
  ret = -EINVAL;
      ^
net/ipv4/devinet.c:1151:8: note: ret is overwritten
   ret = -ENOBUFS;
       ^
net/ipv4/devinet.c:1183:7: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
  ret = inet_set_ifa(dev, ifa);
      ^
net/ipv4/devinet.c:1151:8: note: ret is assigned
   ret = -ENOBUFS;
       ^
net/ipv4/devinet.c:1183:7: note: ret is overwritten
  ret = inet_set_ifa(dev, ifa);
      ^
net/ipv4/devinet.c:1202:7: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
  ret = 0;
      ^
net/ipv4/devinet.c:1199:7: note: ret is assigned
  ret = -EINVAL;
      ^
net/ipv4/devinet.c:1202:7: note: ret is overwritten
  ret = 0;
      ^
net/ipv4/devinet.c:1216:7: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
  ret = 0;
      ^
net/ipv4/devinet.c:1213:7: note: ret is assigned
  ret = -EINVAL;
      ^
net/ipv4/devinet.c:1216:7: note: ret is overwritten
  ret = 0;
      ^
net/ipv4/devinet.c:2719:2: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 kfree(dflt);
 ^
net/ipv4/devinet.c:1955:17: style: The scope of the variable 'a' can be reduced. [variableScope]
 struct nlattr *a, *tb[IFLA_INET_MAX+1];
                ^
net/ipv4/devinet.c:1956:11: style: The scope of the variable 'rem' can be reduced. [variableScope]
 int err, rem;
          ^
net/ipv4/devinet.c:1984:17: style: The scope of the variable 'a' can be reduced. [variableScope]
 struct nlattr *a, *tb[IFLA_INET_MAX+1];
                ^
net/ipv4/devinet.c:1985:6: style: The scope of the variable 'rem' can be reduced. [variableScope]
 int rem;
     ^
net/ipv4/devinet.c:475:39: warning: Found suspicious operator ',' [constStatement]
 struct in_ifaddr __rcu **last_primary, **ifap;
                                      ^
net/ipv4/devinet.c:2670:0: information: Skipping configuration 'CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv4/devinet.c:2678:0: information: Skipping configuration 'CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  } else if (!IS_ENABLED(CONFIG_SYSCTL) ||
^
net/ipv4/esp4.c:757:10: style: Redundant condition: xo. '!xo || (xo && !(xo->flags&CRYPTO_DONE))' is equivalent to '!xo || !(xo->flags&CRYPTO_DONE)' [redundantCondition]
 if (!xo || (xo && !(xo->flags & CRYPTO_DONE)))
         ^
net/ipv4/esp4.c:105:22: style: The scope of the variable 'sg' can be reduced. [variableScope]
 struct scatterlist *sg;
                     ^
net/ipv4/esp4.c:77:44: portability: 'tmp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    crypto_aead_alignmask(aead) + 1) : tmp + extralen;
                                           ^
net/ipv4/esp4.c:110:8: style: Variable 'extra' is assigned a value that is never used. [unreadVariable]
 extra = esp_tmp_extra(tmp);
       ^
net/ipv4/esp4_offload.c:288:18: style: Redundant condition: hw_offload. '!hw_offload || (hw_offload && !skb_is_gso(skb))' is equivalent to '!hw_offload || !skb_is_gso(skb)' [redundantCondition]
 if (!hw_offload || (hw_offload && !skb_is_gso(skb))) {
                 ^
net/ipv4/esp4_offload.c:70:2: warning: Either the condition '!xo' is redundant or there is possible null pointer dereference: xo. [nullPointerRedundantCheck]
 xo->flags |= XFRM_GRO;
 ^
net/ipv4/esp4_offload.c:45:6: note: Assuming that condition '!xo' is not redundant
 if (!xo || !(xo->flags & CRYPTO_DONE)) {
     ^
net/ipv4/esp4_offload.c:70:2: note: Null pointer dereference
 xo->flags |= XFRM_GRO;
 ^
net/ipv4/fib_frontend.c:1121:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
      dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,
                                ^
net/ipv4/fib_frontend.c:1149:31: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,
                              ^
net/ipv4/fib_frontend.c:1154:31: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,
                              ^
net/ipv4/fib_frontend.c:1198:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
      dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,
                                ^
net/ipv4/fib_semantics.c:1955:11: warning: Either the condition 'fi==prev_fi' is redundant or there is possible null pointer dereference: fi. [nullPointerRedundantCheck]
  BUG_ON(!fi->fib_nhs);
          ^
net/ipv4/fib_semantics.c:1956:35: note: Assuming that condition 'fi==prev_fi' is not redundant
  if (nh->fib_nh_dev != dev || fi == prev_fi)
                                  ^
net/ipv4/fib_semantics.c:1955:11: note: Null pointer dereference
  BUG_ON(!fi->fib_nhs);
          ^
net/ipv4/fib_semantics.c:2115:11: warning: Either the condition 'fi==prev_fi' is redundant or there is possible null pointer dereference: fi. [nullPointerRedundantCheck]
  BUG_ON(!fi->fib_nhs);
          ^
net/ipv4/fib_semantics.c:2116:35: note: Assuming that condition 'fi==prev_fi' is not redundant
  if (nh->fib_nh_dev != dev || fi == prev_fi)
                                  ^
net/ipv4/fib_semantics.c:2115:11: note: Null pointer dereference
  BUG_ON(!fi->fib_nhs);
          ^
net/ipv4/fib_semantics.c:1735:44: style:inconclusive: Function 'fib_dump_info' argument 2 names different: declaration 'pid' definition 'portid'. [funcArgNamesDifferent]
int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,
                                           ^
net/ipv4/fib_lookup.h:41:44: note: Function 'fib_dump_info' argument 2 names different: declaration 'pid' definition 'portid'.
int fib_dump_info(struct sk_buff *skb, u32 pid, u32 seq, int event,
                                           ^
net/ipv4/fib_semantics.c:1735:44: note: Function 'fib_dump_info' argument 2 names different: declaration 'pid' definition 'portid'.
int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,
                                           ^
net/ipv4/fib_semantics.c:1494:18: style: Local variable 'nh' shadows outer variable [shadowVariable]
  struct fib_nh *nh = fi->fib_nh;
                 ^
net/ipv4/fib_semantics.c:1351:18: note: Shadowed declaration
 struct nexthop *nh = NULL;
                 ^
net/ipv4/fib_semantics.c:1494:18: note: Shadow variable
  struct fib_nh *nh = fi->fib_nh;
                 ^
net/ipv4/fib_semantics.c:1788:17: style: Local variable 'flags' shadows outer argument [shadowArgument]
  unsigned char flags = 0;
                ^
net/ipv4/fib_semantics.c:1736:43: note: Shadowed declaration
    struct fib_rt_info *fri, unsigned int flags)
                                          ^
net/ipv4/fib_semantics.c:1788:17: note: Shadow variable
  unsigned char flags = 0;
                ^
net/ipv4/fib_trie.c:1371:34: style: Opposite expression on both sides of '|'. [oppositeExpression]
 return (key ^ prefix) & (prefix | -prefix);
                                 ^
net/ipv4/fib_trie.c:2160:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/fib_trie.c:156:15: style: struct member 'trie_stat::totdepth' is never used. [unusedStructMember]
 unsigned int totdepth;
              ^
net/ipv4/fib_trie.c:157:15: style: struct member 'trie_stat::maxdepth' is never used. [unusedStructMember]
 unsigned int maxdepth;
              ^
net/ipv4/fib_trie.c:158:15: style: struct member 'trie_stat::tnodes' is never used. [unusedStructMember]
 unsigned int tnodes;
              ^
net/ipv4/fib_trie.c:159:15: style: struct member 'trie_stat::leaves' is never used. [unusedStructMember]
 unsigned int leaves;
              ^
net/ipv4/fib_trie.c:160:15: style: struct member 'trie_stat::nullpointers' is never used. [unusedStructMember]
 unsigned int nullpointers;
              ^
net/ipv4/fib_trie.c:161:15: style: struct member 'trie_stat::prefixes' is never used. [unusedStructMember]
 unsigned int prefixes;
              ^
net/ipv4/fib_trie.c:162:15: style: struct member 'trie_stat::nodesizes' is never used. [unusedStructMember]
 unsigned int nodesizes[MAX_STAT_DEPTH];
              ^
net/ipv4/fib_trie.c:1369:17: warning: Either the condition '!n' is redundant or there is possible null pointer dereference: n. [nullPointerRedundantCheck]
 t_key prefix = n->key;
                ^
net/ipv4/fib_trie.c:1483:8: note: Assuming that condition '!n' is not redundant
   if (!n)
       ^
net/ipv4/fib_trie.c:1468:37: note: Calling function 'prefix_mismatch', 2nd argument 'n' value is 0
  if (unlikely(prefix_mismatch(key, n)) || (n->slen == n->pos))
                                    ^
net/ipv4/fib_trie.c:1369:17: note: Null pointer dereference
 t_key prefix = n->key;
                ^
net/ipv4/fib_trie.c:1462:36: warning: Either the condition '!n' is redundant or there is possible null pointer dereference: n. [nullPointerRedundantCheck]
  struct key_vector __rcu **cptr = n->tnode;
                                   ^
net/ipv4/fib_trie.c:1483:8: note: Assuming that condition '!n' is not redundant
   if (!n)
       ^
net/ipv4/fib_trie.c:1462:36: note: Null pointer dereference
  struct key_vector __rcu **cptr = n->tnode;
                                   ^
net/ipv4/fib_trie.c:1472:16: warning: Either the condition '!n' is redundant or there is possible null pointer dereference: n. [nullPointerRedundantCheck]
  if (unlikely(IS_LEAF(n)))
               ^
net/ipv4/fib_trie.c:1483:8: note: Assuming that condition '!n' is not redundant
   if (!n)
       ^
net/ipv4/fib_trie.c:1472:16: note: Null pointer dereference
  if (unlikely(IS_LEAF(n)))
               ^
net/ipv4/fou.c:1286:10: style: Condition 'ret==0' is always true [knownConditionTrueFalse]
 if (ret == 0)
         ^
net/ipv4/fou.c:1285:35: note: Assignment 'ret=ip_tunnel_encap_add_fou_ops()', assigned value is 0
 ret = ip_tunnel_encap_add_fou_ops();
                                  ^
net/ipv4/fou.c:1286:10: note: Condition 'ret==0' is always true
 if (ret == 0)
         ^
net/ipv4/fou.c:105:42: portability: '(void*)guehdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 skb_remcsum_process(skb, (void *)guehdr + hdrlen,
                                         ^
net/ipv4/fou.c:194:35: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  __be32 flags = *(__be32 *)(data + doffset);
                                  ^
net/ipv4/fou.c:199:43: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   guehdr = gue_remcsum(skb, guehdr, data + doffset,
                                          ^
net/ipv4/fou.c:381:35: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  __be32 flags = *(__be32 *)(data + doffset);
                                  ^
net/ipv4/fou.c:387:13: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       data + doffset, hdrlen, &grc,
            ^
net/ipv4/fou.c:1032:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += GUE_LEN_PRIV;
       ^
net/ipv4/fou.c:1051:9: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   data += GUE_PLEN_REMCSUM;
        ^
net/ipv4/fou.c:1051:9: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
   data += GUE_PLEN_REMCSUM;
        ^
net/ipv4/fou.c:1084:47: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 int type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :
                                              ^
net/ipv4/fou.c:1101:47: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 int type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :
                                              ^
net/ipv4/gre_demux.c:106:10: style: Variable 'options' is assigned a value that is never used. [unreadVariable]
  options++;
         ^
net/ipv4/icmp.c:1143:26: style: The scope of the variable 'objh' can be reduced. [variableScope]
 struct icmp_extobj_hdr *objh, _objh;
                         ^
net/ipv4/igmp.c:2402:18: warning: Either the condition '!psl' is redundant or there is possible null pointer dereference: psl. [nullPointerRedundantCheck]
 for (i = 0; i < psl->sl_count; i++) {
                 ^
net/ipv4/igmp.c:2378:6: note: Assuming that condition '!psl' is not redundant
 if (!psl || psl->sl_count == psl->sl_max) {
     ^
net/ipv4/igmp.c:2402:18: note: Null pointer dereference
 for (i = 0; i < psl->sl_count; i++) {
                 ^
net/ipv4/igmp.c:1525:15: style: The scope of the variable 'len' can be reduced. [variableScope]
 unsigned int len;
              ^
net/ipv4/igmp.c:1927:13: style: Variable 'changerec' is assigned a value that is never used. [unreadVariable]
  changerec |= rv > 0;
            ^
net/ipv4/igmp.c:1003:45: style: Clarify calculation precedence for '*' and '?'. [clarifyCalculation]
  in_dev->mr_qi = IGMPV3_QQIC(ih3->qqic)*HZ ?: IGMP_QUERY_INTERVAL;
                                            ^
net/ipv4/inet_connection_sock.c:449:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = sock_intr_errno(timeo);
      ^
net/ipv4/inet_connection_sock.c:446:7: note: err is assigned
  err = -EINVAL;
      ^
net/ipv4/inet_connection_sock.c:449:7: note: err is overwritten
  err = sock_intr_errno(timeo);
      ^
net/ipv4/inet_connection_sock.c:452:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EAGAIN;
      ^
net/ipv4/inet_connection_sock.c:449:7: note: err is assigned
  err = sock_intr_errno(timeo);
      ^
net/ipv4/inet_connection_sock.c:452:7: note: err is overwritten
  err = -EAGAIN;
      ^
net/ipv4/inet_diag.c:167:7: style: Condition '!classid' is always true [knownConditionTrueFalse]
  if (!classid)
      ^
net/ipv4/inet_diag.c:158:17: note: Assignment 'classid=0', assigned value is 0
  u32 classid = 0;
                ^
net/ipv4/inet_diag.c:167:7: note: Condition '!classid' is always true
  if (!classid)
      ^
net/ipv4/inet_diag.c:496:6: warning: Either the condition 'if(sk)' is redundant or there is possible null pointer dereference: sk. [nullPointerRedundantCheck]
 if (sk->sk_state == TCP_TIME_WAIT)
     ^
net/ipv4/inet_diag.c:583:5: note: Assuming that condition 'if(sk)' is not redundant
 if (sk)
    ^
net/ipv4/inet_diag.c:571:21: note: Calling function 'sk_diag_fill', 1st argument 'sk' value is 0
 err = sk_diag_fill(sk, rep, cb, req, 0, net_admin);
                    ^
net/ipv4/inet_diag.c:496:6: note: Null pointer dereference
 if (sk->sk_state == TCP_TIME_WAIT)
     ^
net/ipv4/inet_diag.c:1073:13: style: Variable 'num' is reassigned a value before the old one has been used. [redundantAssignment]
  s_i = num = s_num = 0;
            ^
net/ipv4/inet_diag.c:1065:5: note: num is assigned
    ++num;
    ^
net/ipv4/inet_diag.c:1073:13: note: num is overwritten
  s_i = num = s_num = 0;
            ^
net/ipv4/inet_diag.c:351:21: style: Local variable 'info' shadows outer variable [shadowVariable]
  union tcp_cc_info info;
                    ^
net/ipv4/inet_diag.c:246:8: note: Shadowed declaration
 void *info = NULL;
       ^
net/ipv4/inet_diag.c:351:21: note: Shadow variable
  union tcp_cc_info info;
                    ^
net/ipv4/inet_diag.c:353:7: style: Local variable 'attr' shadows outer variable [shadowVariable]
  int attr;
      ^
net/ipv4/inet_diag.c:245:17: note: Shadowed declaration
 struct nlattr *attr;
                ^
net/ipv4/inet_diag.c:353:7: note: Shadow variable
  int attr;
      ^
net/ipv4/inet_diag.c:760:7: portability: 'bc' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   bc += op->yes;
      ^
net/ipv4/inet_diag.c:763:7: portability: 'bc' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   bc += op->no;
      ^
net/ipv4/inet_diag.c:827:7: portability: 'bc' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  bc  += op->yes;
      ^
net/ipv4/inet_diag.c:974:7: portability: 'bc' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  bc  += op->yes;
      ^
net/ipv4/inet_hashtables.c:139:6: style: The scope of the variable 'l3mdev' can be reduced. [variableScope]
 int l3mdev;
     ^
net/ipv4/inet_hashtables.c:285:6: style: The scope of the variable 'score' can be reduced. [variableScope]
 int score, hiscore = 0;
     ^
net/ipv4/inet_hashtables.c:900:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i, nblocks = 1;
              ^
net/ipv4/ip_gre.c:182:12: style: Variable 'data_len' is assigned a value that is never used. [unreadVariable]
  data_len = icmp_hdr(skb)->un.reserved[1] * 4; /* RFC 4884 4.1 */
           ^
net/ipv4/ip_options.c:94:15: style: The scope of the variable 'doffset' can be reduced. [variableScope]
 int soffset, doffset;
              ^
net/ipv4/ip_options.c:606:17: style: The scope of the variable 'rt2' can be reduced. [variableScope]
 struct rtable *rt2;
                ^
net/ipv4/ip_options.c:607:16: style: The scope of the variable 'orefdst' can be reduced. [variableScope]
 unsigned long orefdst;
               ^
net/ipv4/ip_options.c:608:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/ip_output.c:694:6: style: Redundant initialization for 'len'. The initialized value is overwritten before it is read. [redundantInitialization]
 len = state->left;
     ^
net/ipv4/ip_output.c:690:19: note: len is initialized
 unsigned int len = state->left;
                  ^
net/ipv4/ip_output.c:694:6: note: len is overwritten
 len = state->left;
     ^
net/ipv4/ip_output.c:1704:5: style: Redundant initialization for 'rt'. The initialized value is overwritten before it is read. [redundantInitialization]
 rt = ip_route_output_key(net, &fl4);
    ^
net/ipv4/ip_output.c:1671:20: note: rt is initialized
 struct rtable *rt = skb_rtable(skb);
                   ^
net/ipv4/ip_output.c:1704:5: note: rt is overwritten
 rt = ip_route_output_key(net, &fl4);
    ^
net/ipv4/ip_output.c:1310:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/ip_output.c:971:18: style: Local variable 'skb' shadows outer argument [shadowArgument]
 struct sk_buff *skb;
                 ^
net/ipv4/ip_output.c:965:40: note: Shadowed declaration
     int len, int odd, struct sk_buff *skb),
                                       ^
net/ipv4/ip_output.c:971:18: note: Shadow variable
 struct sk_buff *skb;
                 ^
net/ipv4/ip_output.c:979:6: style: Local variable 'offset' shadows outer argument [shadowArgument]
 int offset = 0;
     ^
net/ipv4/ip_output.c:964:46: note: Shadowed declaration
       int getfrag(void *from, char *to, int offset,
                                             ^
net/ipv4/ip_output.c:979:6: note: Shadow variable
 int offset = 0;
     ^
net/ipv4/ip_output.c:1653:39: portability: 'dptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 csum = csum_partial_copy_nocheck(dptr+offset, to, len);
                                      ^
net/ipv4/ip_sockglue.c:1554:19: style: Condition 'opt->optlen==0' is always true [knownConditionTrueFalse]
  if (opt->optlen == 0)
                  ^
net/ipv4/ip_sockglue.c:1547:15: note: opt->optlen is assigned value 0
  opt->optlen = 0;
              ^
net/ipv4/ip_sockglue.c:1554:19: note: Condition 'opt->optlen==0' is always true
  if (opt->optlen == 0)
                  ^
net/ipv4/ip_sockglue.c:1126:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1119:7: note: err is assigned
  err = -EADDRNOTAVAIL;
      ^
net/ipv4/ip_sockglue.c:1126:7: note: err is overwritten
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1131:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv4/ip_sockglue.c:1126:7: note: err is assigned
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1131:7: note: err is overwritten
  err = 0;
      ^
net/ipv4/ip_sockglue.c:1180:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EADDRNOTAVAIL;
      ^
net/ipv4/ip_sockglue.c:1149:7: note: err is assigned
  err = -EFAULT;
      ^
net/ipv4/ip_sockglue.c:1180:7: note: err is overwritten
  err = -EADDRNOTAVAIL;
      ^
net/ipv4/ip_sockglue.c:1188:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1180:7: note: err is assigned
  err = -EADDRNOTAVAIL;
      ^
net/ipv4/ip_sockglue.c:1188:7: note: err is overwritten
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1196:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv4/ip_sockglue.c:1188:7: note: err is assigned
  err = -EINVAL;
      ^
net/ipv4/ip_sockglue.c:1196:7: note: err is overwritten
  err = 0;
      ^
net/ipv4/ip_sockglue.c:1223:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = ip_mc_join_group(sk, &mreq);
       ^
net/ipv4/ip_sockglue.c:1211:7: note: err is assigned
  err = -EFAULT;
      ^
net/ipv4/ip_sockglue.c:1223:8: note: err is overwritten
   err = ip_mc_join_group(sk, &mreq);
       ^
net/ipv4/ip_sockglue.c:1336:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = xfrm_user_policy(sk, optname, optval, optlen);
      ^
net/ipv4/ip_sockglue.c:1333:7: note: err is assigned
  err = -EPERM;
      ^
net/ipv4/ip_sockglue.c:1336:7: note: err is overwritten
  err = xfrm_user_policy(sk, optname, optval, optlen);
      ^
net/ipv4/ip_sockglue.c:817:11: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 gf32 = p + 4; /* we want ->gf_group and ->gf_slist aligned */
          ^
net/ipv4/ip_tunnel.c:222:16: warning:inconclusive: Possible null pointer dereference: t [nullPointer]
  if (local == t->parms.iph.saddr &&
               ^
net/ipv4/ip_tunnel.c:218:24: note: Assignment 't=NULL', assigned value is 0
 struct ip_tunnel *t = NULL;
                       ^
net/ipv4/ip_tunnel.c:222:16: note: Null pointer dereference
  if (local == t->parms.iph.saddr &&
               ^
net/ipv4/ip_tunnel.c:223:17: warning:inconclusive: Possible null pointer dereference: t [nullPointer]
      remote == t->parms.iph.daddr &&
                ^
net/ipv4/ip_tunnel.c:218:24: note: Assignment 't=NULL', assigned value is 0
 struct ip_tunnel *t = NULL;
                       ^
net/ipv4/ip_tunnel.c:223:17: note: Null pointer dereference
      remote == t->parms.iph.daddr &&
                ^
net/ipv4/ip_tunnel.c:224:15: warning:inconclusive: Possible null pointer dereference: t [nullPointer]
      link == t->parms.link &&
              ^
net/ipv4/ip_tunnel.c:218:24: note: Assignment 't=NULL', assigned value is 0
 struct ip_tunnel *t = NULL;
                       ^
net/ipv4/ip_tunnel.c:224:15: note: Null pointer dereference
      link == t->parms.link &&
              ^
net/ipv4/ip_tunnel.c:225:15: warning:inconclusive: Possible null pointer dereference: t [nullPointer]
      type == t->dev->type &&
              ^
net/ipv4/ip_tunnel.c:218:24: note: Assignment 't=NULL', assigned value is 0
 struct ip_tunnel *t = NULL;
                       ^
net/ipv4/ip_tunnel.c:225:15: note: Null pointer dereference
      type == t->dev->type &&
              ^
net/ipv4/ip_tunnel.c:1106:24: style: The scope of the variable 'itn' can be reduced. [variableScope]
 struct ip_tunnel_net *itn;
                       ^
net/ipv4/ip_tunnel_core.c:159:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/ip_tunnel_core.c:732:21: style: The scope of the variable 'opt' can be reduced. [variableScope]
 struct geneve_opt *opt;
                    ^
net/ipv4/ip_tunnel_core.c:864:22: style: The scope of the variable 'opt' can be reduced. [variableScope]
  struct geneve_opt *opt;
                     ^
net/ipv4/ip_tunnel_core.c:232:12: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
  .ihl   = sizeof(*niph) / 4u,
           ^
net/ipv4/ipconfig.c:311:21: style: The scope of the variable 'dev' can be reduced. [variableScope]
 struct net_device *dev;
                    ^
net/ipv4/ipconfig.c:658:6: style: The scope of the variable 'len' can be reduced. [variableScope]
 int len;
     ^
net/ipv4/ipmr.c:1015:18: style: The scope of the variable 'igmp' can be reduced. [variableScope]
 struct igmphdr *igmp;
                 ^
net/ipv4/ipmr.c:1275:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/ipv4/ipmr.c:1724:21: style: The scope of the variable 'v' can be reduced. [variableScope]
 struct vif_device *v;
                    ^
net/ipv4/ipmr.c:1927:24: style:inconclusive: Function 'ip_mr_forward' argument 5 names different: declaration 'cache' definition 'c'. [funcArgNamesDifferent]
     struct mfc_cache *c, int local)
                       ^
net/ipv4/ipmr.c:102:24: note: Function 'ip_mr_forward' argument 5 names different: declaration 'cache' definition 'c'.
     struct mfc_cache *cache, int local);
                       ^
net/ipv4/ipmr.c:1927:24: note: Function 'ip_mr_forward' argument 5 names different: declaration 'cache' definition 'c'.
     struct mfc_cache *c, int local)
                       ^
net/ipv4/ipmr.c:2595:7: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
  err = mr_table_dump(mrt, skb, cb, _ipmr_fill_mroute,
      ^
net/ipv4/ipmr.c:1507:0: information: Skipping configuration 'CONFIG_IP_MROUTE_MULTIPLE_TABLES' since the value of 'CONFIG_IP_MROUTE_MULTIPLE_TABLES' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  if (!IS_BUILTIN(CONFIG_IP_MROUTE_MULTIPLE_TABLES)) {
^
net/ipv4/ipmr.c:2960:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
net/ipv4/ipmr_base.c:96:21: style: The scope of the variable 'proxy' can be reduced. [variableScope]
 struct mr_mfc *c, *proxy;
                    ^
net/ipv4/ipmr_base.c:163:10: style: Variable 'pos' is assigned a value that is never used. [unreadVariable]
  if (pos-- == 0)
         ^
net/ipv4/netfilter/arp_tables.c:604:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/ipv4/netfilter/arp_tables.c:633:20: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int cpu, i;
                   ^
net/ipv4/netfilter/arp_tables.c:1030:23: style: Local variable 'tmp' shadows outer variable [shadowVariable]
  struct xt_counters *tmp;
                      ^
net/ipv4/netfilter/arp_tables.c:1001:26: note: Shadowed declaration
 struct xt_counters_info tmp;
                         ^
net/ipv4/netfilter/arp_tables.c:1030:23: note: Shadow variable
  struct xt_counters *tmp;
                      ^
net/ipv4/netfilter/arp_tables.c:173:36: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (struct arpt_entry *)(base + offset);
                                   ^
net/ipv4/netfilter/arp_tables.c:179:23: portability: '(void*)entry' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (void *)entry + entry->next_offset;
                      ^
net/ipv4/netfilter/arp_tables.c:254:19: portability: 'table_base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (table_base + v
                  ^
net/ipv4/netfilter/arp_tables.c:312:33: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  struct arpt_entry *e = entry0 + pos;
                                ^
net/ipv4/netfilter/arp_tables.c:351:17: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     e = entry0 + pos;
                ^
net/ipv4/netfilter/arp_tables.c:356:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
               ^
net/ipv4/netfilter/arp_tables.c:356:22: portability: 'entry0+pos' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
                     ^
net/ipv4/netfilter/arp_tables.c:377:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + newpos;
               ^
net/ipv4/netfilter/arp_tables.c:546:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + repl->size,
              ^
net/ipv4/netfilter/arp_tables.c:691:21: portability: 'loc_cpu_entry' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  e = loc_cpu_entry + off;
                    ^
net/ipv4/netfilter/arp_tables.c:692:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off, e, sizeof(*e))) {
                           ^
net/ipv4/netfilter/arp_tables.c:696:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off
                           ^
net/ipv4/netfilter/arp_tables.c:697:6: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     + offsetof(struct arpt_entry, counters),
     ^
net/ipv4/netfilter/arp_tables.c:705:36: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                   ^
net/ipv4/netfilter/arp_tables.c:705:42: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                         ^
net/ipv4/netfilter/arp_tables.c:831:8: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
   ret = -EFAULT;
       ^
net/ipv4/netfilter/arp_tables.c:815:8: note: ret is assigned
   ret = compat_table_info(private, &tmp);
       ^
net/ipv4/netfilter/arp_tables.c:831:8: note: ret is overwritten
   ret = -EFAULT;
       ^
net/ipv4/netfilter/arp_tables.c:755:39: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct arpt_entry *)(base + info->hook_entry[i])))
                                      ^
net/ipv4/netfilter/arp_tables.c:758:39: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct arpt_entry *)(base + info->underflow[i])))
                                      ^
net/ipv4/netfilter/arp_tables.c:1138:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct arpt_entry);
         ^
net/ipv4/netfilter/arp_tables.c:1181:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + compatr->size);
              ^
net/ipv4/netfilter/arp_tables.c:1312:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct compat_arpt_entry);
         ^
net/ipv4/netfilter/ip_tables.c:745:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/ipv4/netfilter/ip_tables.c:774:20: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int cpu, i;
                   ^
net/ipv4/netfilter/ip_tables.c:1185:23: style: Local variable 'tmp' shadows outer variable [shadowVariable]
  struct xt_counters *tmp;
                      ^
net/ipv4/netfilter/ip_tables.c:1157:26: note: Shadowed declaration
 struct xt_counters_info tmp;
                         ^
net/ipv4/netfilter/ip_tables.c:1185:23: note: Shadow variable
  struct xt_counters *tmp;
                      ^
net/ipv4/netfilter/ip_tables.c:105:35: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (struct ipt_entry *)(base + offset);
                                  ^
net/ipv4/netfilter/ip_tables.c:220:23: portability: '(void*)entry' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (void *)entry + entry->next_offset;
                      ^
net/ipv4/netfilter/ip_tables.c:330:19: portability: 'table_base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (table_base + v != ipt_next_entry(e) &&
                  ^
net/ipv4/netfilter/ip_tables.c:378:32: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  struct ipt_entry *e = entry0 + pos;
                               ^
net/ipv4/netfilter/ip_tables.c:415:17: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     e = entry0 + pos;
                ^
net/ipv4/netfilter/ip_tables.c:420:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
               ^
net/ipv4/netfilter/ip_tables.c:420:22: portability: 'entry0+pos' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
                     ^
net/ipv4/netfilter/ip_tables.c:441:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + newpos;
               ^
net/ipv4/netfilter/ip_tables.c:686:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + repl->size,
              ^
net/ipv4/netfilter/ip_tables.c:835:21: portability: 'loc_cpu_entry' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  e = loc_cpu_entry + off;
                    ^
net/ipv4/netfilter/ip_tables.c:836:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off, e, sizeof(*e))) {
                           ^
net/ipv4/netfilter/ip_tables.c:840:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off
                           ^
net/ipv4/netfilter/ip_tables.c:841:6: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     + offsetof(struct ipt_entry, counters),
     ^
net/ipv4/netfilter/ip_tables.c:851:18: portability: '(void*)e' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   m = (void *)e + i;
                 ^
net/ipv4/netfilter/ip_tables.c:853:36: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (xt_match_to_user(m, userptr + off + i)) {
                                   ^
net/ipv4/netfilter/ip_tables.c:853:42: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (xt_match_to_user(m, userptr + off + i)) {
                                         ^
net/ipv4/netfilter/ip_tables.c:860:36: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                   ^
net/ipv4/netfilter/ip_tables.c:860:42: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                         ^
net/ipv4/netfilter/ip_tables.c:988:8: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
   ret = -EFAULT;
       ^
net/ipv4/netfilter/ip_tables.c:972:8: note: ret is assigned
   ret = compat_table_info(private, &tmp);
       ^
net/ipv4/netfilter/ip_tables.c:988:8: note: ret is overwritten
   ret = -EFAULT;
       ^
net/ipv4/netfilter/ip_tables.c:912:38: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct ipt_entry *)(base + info->hook_entry[i])))
                                     ^
net/ipv4/netfilter/ip_tables.c:915:38: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct ipt_entry *)(base + info->underflow[i])))
                                     ^
net/ipv4/netfilter/ip_tables.c:1234:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct compat_ipt_entry);
         ^
net/ipv4/netfilter/ip_tables.c:1368:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct ipt_entry);
         ^
net/ipv4/netfilter/ip_tables.c:1416:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + compatr->size);
              ^
net/ipv4/netfilter/ipt_CLUSTERIP.c:298:2: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 spin_lock_bh(&cn->lock);
 ^
net/ipv4/netfilter/ipt_CLUSTERIP.c:597:9: error: Array 'hbuffer[30]' accessed at index -1, which is out of bounds. [negativeIndex]
 hbuffer[--k] = '\0';
        ^
net/ipv4/netfilter/ipt_CLUSTERIP.c:592:2: note: After for loop, k has value 0
 for (k = 0, j = 0; k < HBUFFERLEN - 3 && j < ETH_ALEN; j++) {
 ^
net/ipv4/netfilter/ipt_CLUSTERIP.c:597:9: note: Negative array index
 hbuffer[--k] = '\0';
        ^
net/ipv4/netfilter/ipt_ECN.c:63:29: portability: '(void*)ip_hdr(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 tcph = (void *)ip_hdr(skb) + ip_hdrlen(skb);
                            ^
net/ipv4/netfilter/ipt_rpfilter.c:78:58: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 flow.flowi4_mark = info->flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;
                                                         ^
net/ipv4/netfilter/iptable_mangle.c:47:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/netfilter/iptable_nat.c:65:9: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int i, ret;
        ^
net/ipv4/netfilter/nf_nat_h323.c:33:23: style: The scope of the variable 'th' can be reduced. [variableScope]
 const struct tcphdr *th;
                      ^
net/ipv4/nexthop.c:1388:18: style: The scope of the variable 'nh' can be reduced. [variableScope]
 struct nexthop *nh;
                 ^
net/ipv4/nexthop.c:1828:18: style: The scope of the variable 'nh' can be reduced. [variableScope]
 struct nexthop *nh;
                 ^
net/ipv4/ping.c:121:10: warning:inconclusive: Possible null pointer dereference: sk2 [nullPointer]
       (!sk2->sk_reuse || !sk->sk_reuse))
         ^
net/ipv4/ping.c:82:21: note: Assignment 'sk2=NULL', assigned value is 0
 struct sock *sk2 = NULL;
                    ^
net/ipv4/ping.c:121:10: note: Null pointer dereference
       (!sk2->sk_reuse || !sk->sk_reuse))
         ^
net/ipv4/proc.c:304:6: style: The scope of the variable 'j' can be reduced. [variableScope]
 int j;
     ^
net/ipv4/proc.c:324:31: style: The scope of the variable 'val' can be reduced. [variableScope]
 unsigned long vals[PERLINE], val;
                              ^
net/ipv4/raw.c:265:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = EMSGSIZE;
       ^
net/ipv4/raw.c:260:7: note: err is assigned
  err = EHOSTUNREACH;
      ^
net/ipv4/raw.c:265:8: note: err is overwritten
   err = EMSGSIZE;
       ^
net/ipv4/raw.c:291:22: style: The scope of the variable 'iph' can be reduced. [variableScope]
 const struct iphdr *iph;
                     ^
net/ipv4/raw.c:292:14: style: The scope of the variable 'net' can be reduced. [variableScope]
 struct net *net;
             ^
net/ipv4/route.c:679:24: style: The statement 'if (fnhe->fnhe_genid!=genid) fnhe->fnhe_genid=genid' is logically equivalent to 'fnhe->fnhe_genid=genid'. [duplicateConditionalAssign]
  if (fnhe->fnhe_genid != genid)
                       ^
net/ipv4/route.c:680:21: note: Assignment 'fnhe->fnhe_genid=genid'
   fnhe->fnhe_genid = genid;
                    ^
net/ipv4/route.c:679:24: note: Condition 'fnhe->fnhe_genid!=genid' is redundant
  if (fnhe->fnhe_genid != genid)
                       ^
net/ipv4/route.c:476:29: warning: Either the condition '!daddr' is redundant or there is possible null pointer dereference: (__force u32*)pkey. [nullPointerRedundantCheck]
 __ipv4_confirm_neigh(dev, *(__force u32 *)pkey);
                            ^
net/ipv4/route.c:471:13: note: Assuming that condition '!daddr' is not redundant
 } else if (!daddr ||
            ^
net/ipv4/route.c:465:23: note: Assignment 'pkey=daddr', assigned value is 0
 const __be32 *pkey = daddr;
                      ^
net/ipv4/route.c:467:23: note: Assuming condition is false
 if (rt->rt_gw_family == AF_INET) {
                      ^
net/ipv4/route.c:476:29: note: Null pointer dereference
 __ipv4_confirm_neigh(dev, *(__force u32 *)pkey);
                            ^
net/ipv4/route.c:1210:6: style: The scope of the variable 'res' can be reduced. [variableScope]
 int res;
     ^
net/ipv4/route.c:1700:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/route.c:341:27: style: The scope of the variable 'src' can be reduced. [variableScope]
 struct ip_rt_acct *dst, *src;
                          ^
net/ipv4/sysctl_net_ipv4.c:278:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, ret = 0;
     ^
net/ipv4/tcp_bpf.c:19:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, copied = 0;
     ^
net/ipv4/tcp_bpf.c:97:22: style: The scope of the variable 'sge' can be reduced. [variableScope]
 struct scatterlist *sge;
                     ^
net/ipv4/tcp_bpf.c:152:16: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 int size, ret = 0;
               ^
net/ipv4/tcp_diag.c:132:6: style: The if condition is the same as the previous if condition [duplicateCondition]
 if (net_admin) {
     ^
net/ipv4/tcp_diag.c:119:6: note: First condition
 if (net_admin) {
     ^
net/ipv4/tcp_diag.c:132:6: note: Second condition
 if (net_admin) {
     ^
net/ipv4/tcp_diag.c:65:19: style: Condition 'md5sig_count==0' is always false [knownConditionTrueFalse]
 if (md5sig_count == 0)
                  ^
net/ipv4/tcp_diag.c:61:21: note: Assignment 'md5sig_count=0', assigned value is 0
 int md5sig_count = 0;
                    ^
net/ipv4/tcp_diag.c:64:3: note: md5sig_count is incremented', new value is 1
  md5sig_count++;
  ^
net/ipv4/tcp_diag.c:65:19: note: Condition 'md5sig_count==0' is always false
 if (md5sig_count == 0)
                  ^
net/ipv4/tcp_diag.c:152:32: style: The scope of the variable 'key' can be reduced. [variableScope]
  const struct tcp_md5sig_key *key;
                               ^
net/ipv4/tcp_fastopen.c:115:18: style: The scope of the variable 'i' can be reduced. [variableScope]
 int n_keys = 0, i;
                 ^
net/ipv4/tcp_fastopen.c:552:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/ipv4/tcp_fastopen.c:83:54: portability: 'primary_key' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 ctx->key[0].key[1] = get_unaligned_le64(primary_key + 8);
                                                     ^
net/ipv4/tcp_fastopen.c:86:54: portability: 'backup_key' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  ctx->key[1].key[1] = get_unaligned_le64(backup_key + 8);
                                                     ^
net/ipv4/tcp_input.c:5924:6: style: Condition '!icsk->icsk_ca_initialized' is always true [knownConditionTrueFalse]
 if (!icsk->icsk_ca_initialized)
     ^
net/ipv4/tcp_input.c:5922:28: note: icsk->icsk_ca_initialized is assigned value 0
 icsk->icsk_ca_initialized = 0;
                           ^
net/ipv4/tcp_input.c:5924:6: note: Condition '!icsk->icsk_ca_initialized' is always true
 if (!icsk->icsk_ca_initialized)
     ^
net/ipv4/tcp_input.c:1259:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv4/tcp_input.c:1261:15: style: The scope of the variable 'pkt_len' can be reduced. [variableScope]
 unsigned int pkt_len;
              ^
net/ipv4/tcp_input.c:1262:15: style: The scope of the variable 'mss' can be reduced. [variableScope]
 unsigned int mss;
              ^
net/ipv4/tcp_input.c:1715:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/ipv4/tcp_input.c:5067:18: style: The scope of the variable 'skb1' can be reduced. [variableScope]
 struct sk_buff *skb1;
                 ^
net/ipv4/tcp_input.c:4114:19: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 if (th->doff == (sizeof(*th) / 4)) {
                  ^
net/ipv4/tcp_ipv4.c:2708:19: style: The scope of the variable 'prog' can be reduced. [variableScope]
 struct bpf_prog *prog;
                  ^
net/ipv4/tcp_ipv4.c:1432:2: style:inconclusive: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
 return false;
 ^
net/ipv4/tcp_metrics.c:884:8: style: The scope of the variable 'match' can be reduced. [variableScope]
  bool match;
       ^
net/ipv4/tcp_offload.c:152:7: style: Local variable 'delta' shadows outer variable [shadowVariable]
  int delta;
      ^
net/ipv4/tcp_offload.c:62:9: note: Shadowed declaration
 __be32 delta;
        ^
net/ipv4/tcp_offload.c:152:7: note: Shadow variable
  int delta;
      ^
net/ipv4/tcp_offload.c:263:11: warning: Either the condition 'if(p&&(!NAPI_GRO_CB(skb)->same_flow||flush))' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
 flush |= p->decrypted ^ skb->decrypted;
          ^
net/ipv4/tcp_offload.c:279:5: note: Assuming that condition 'if(p&&(!NAPI_GRO_CB(skb)->same_flow||flush))' is not redundant
 if (p && (!NAPI_GRO_CB(skb)->same_flow || flush))
    ^
net/ipv4/tcp_offload.c:263:11: note: Null pointer dereference
 flush |= p->decrypted ^ skb->decrypted;
          ^
net/ipv4/tcp_output.c:2310:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  len -= skb->len;
  ^
net/ipv4/tcp_output.c:2333:6: style: The scope of the variable 'copy' can be reduced. [variableScope]
 int copy, len;
     ^
net/ipv4/tcp_output.c:3143:6: style: The scope of the variable 'diff' can be reduced. [variableScope]
 int diff, len, err;
     ^
net/ipv4/tcp_output.c:3220:19: style: The scope of the variable 'nskb' can be reduced. [variableScope]
  struct sk_buff *nskb;
                  ^
net/ipv4/tcp_timer.c:145:6: style: The scope of the variable 'mss' can be reduced. [variableScope]
 int mss;
     ^
net/ipv4/tcp_timer.c:218:24: style: The scope of the variable 'do_reset' can be reduced. [variableScope]
 bool expired = false, do_reset;
                       ^
net/ipv4/udp.c:2234:7: style: Condition '!first' is always true [knownConditionTrueFalse]
  if (!first) {
      ^
net/ipv4/udp.c:2210:28: note: Assignment 'first=NULL', assigned value is 0
 struct sock *sk, *first = NULL;
                           ^
net/ipv4/udp.c:2230:7: note: Assuming condition is false
  if (!__udp_is_mcast_sock(net, sk, uh->dest, daddr,
      ^
net/ipv4/udp.c:2234:7: note: Condition '!first' is always true
  if (!first) {
      ^
net/ipv4/udp.c:2461:8: style: Condition 'result' is always false [knownConditionTrueFalse]
   if (result)
       ^
net/ipv4/udp.c:2457:11: note: Assignment 'result=NULL', assigned value is 0
 result = NULL;
          ^
net/ipv4/udp.c:2461:8: note: Condition 'result' is always false
   if (result)
       ^
net/ipv4/udp.c:437:6: style: The scope of the variable 'score' can be reduced. [variableScope]
 int score, badness;
     ^
net/ipv4/udp.c:2166:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv4/udp.c:2188:20: style: The scope of the variable 'old' can be reduced. [variableScope]
 struct dst_entry *old;
                   ^
net/ipv4/udp.c:2507:6: style: The scope of the variable 'ours' can be reduced. [variableScope]
 int ours;
     ^
net/ipv4/udp.c:3046:19: style: The scope of the variable 'prog' can be reduced. [variableScope]
 struct bpf_prog *prog;
                  ^
net/ipv4/udp_offload.c:490:19: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
      (!uh->check ^ !uh2->check)) {
                  ^
net/ipv4/udp_tunnel_nic.c:145:42: style: The scope of the variable 'table' can be reduced. [variableScope]
 const struct udp_tunnel_nic_table_info *table;
                                         ^
net/ipv4/udp_tunnel_nic.c:432:42: style: The scope of the variable 'table' can be reduced. [variableScope]
 const struct udp_tunnel_nic_table_info *table;
                                         ^
net/ipv4/udp_tunnel_nic.c:467:42: style: The scope of the variable 'table' can be reduced. [variableScope]
 const struct udp_tunnel_nic_table_info *table;
                                         ^
net/ipv4/udp_tunnel_nic.c:681:37: style: The scope of the variable 'node' can be reduced. [variableScope]
 struct udp_tunnel_nic_shared_node *node;
                                    ^
net/ipv4/xfrm4_protocol.c:47:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv4/xfrm4_protocol.c:98:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv4/xfrm4_protocol.c:126:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv4/xfrm4_protocol.c:154:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/addrconf.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 15 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/ipv6/addrconf.c:1902:30: style: The scope of the variable 'ndev' can be reduced. [variableScope]
 struct net_device *l3mdev, *ndev;
                             ^
net/ipv6/addrconf.c:4407:25: style: The scope of the variable 'addr' can be reduced. [variableScope]
 const struct in6_addr *addr;
                        ^
net/ipv6/addrconf.c:4411:15: style: The scope of the variable 'hash' can be reduced. [variableScope]
 unsigned int hash;
              ^
net/ipv6/addrconf.c:4412:7: style: The scope of the variable 'hash_found' can be reduced. [variableScope]
 bool hash_found;
      ^
net/ipv6/addrconf.c:5797:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv6/addrconf.c:3206:58: style:inconclusive: Function 'ipv6_generate_stable_address' argument 1 names different: declaration 'addr' definition 'address'. [funcArgNamesDifferent]
static int ipv6_generate_stable_address(struct in6_addr *address,
                                                         ^
net/ipv6/addrconf.c:142:58: note: Function 'ipv6_generate_stable_address' argument 1 names different: declaration 'addr' definition 'address'.
static int ipv6_generate_stable_address(struct in6_addr *addr,
                                                         ^
net/ipv6/addrconf.c:3206:58: note: Function 'ipv6_generate_stable_address' argument 1 names different: declaration 'addr' definition 'address'.
static int ipv6_generate_stable_address(struct in6_addr *address,
                                                         ^
net/ipv6/addrconf.c:6035:63: style:inconclusive: Function '__ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'. [funcArgNamesDifferent]
static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
                                                              ^
net/ipv6/addrconf.c:180:63: note: Function '__ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'.
static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
                                                              ^
net/ipv6/addrconf.c:6035:63: note: Function '__ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'.
static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
                                                              ^
net/ipv6/addrconf.c:6091:61: style:inconclusive: Function 'ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'. [funcArgNamesDifferent]
static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
                                                            ^
net/ipv6/addrconf.c:181:61: note: Function 'ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'.
static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
                                                            ^
net/ipv6/addrconf.c:6091:61: note: Function 'ipv6_ifa_notify' argument 2 names different: declaration 'ifa' definition 'ifp'.
static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)
                                                            ^
net/ipv6/addrconf.c:1600:75: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  int preftmp = dst->prefs & (IPV6_PREFER_SRC_PUBLIC|IPV6_PREFER_SRC_TMP) ?
                                                                          ^
net/ipv6/addrconf.c:1580:50: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  ret = !(score->ifa->flags & IFA_F_HOMEADDRESS) ^ prefhome;
                                                 ^
net/ipv6/addrconf.c:7009:0: information: Skipping configuration 'CONFIG_IPV6_MROUTE;CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv6/addrconf.c:7009:0: information: Skipping configuration 'CONFIG_IPV6_OPTIMISTIC_DAD;CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv6/addrconf.c:7009:0: information: Skipping configuration 'CONFIG_IPV6_ROUTER_PREF;CONFIG_IPV6_ROUTE_INFO;CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv6/addrconf.c:7009:0: information: Skipping configuration 'CONFIG_IPV6_ROUTER_PREF;CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv6/addrconf.c:7009:0: information: Skipping configuration 'CONFIG_IPV6_SEG6_HMAC;CONFIG_SYSCTL' since the value of 'CONFIG_SYSCTL' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (IS_ENABLED(CONFIG_SYSCTL) &&
^
net/ipv6/ah6.c:70:14: portability: 'base' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return base + IPV6HDR_BASELEN;
             ^
net/ipv6/anycast.c:439:21: style: The scope of the variable 'nh_dev' can be reduced. [variableScope]
 struct net_device *nh_dev;
                    ^
net/ipv6/anycast.c:471:52: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
       (ipv6_addr_type(addr) & IPV6_ADDR_LINKLOCAL ?
                                                   ^
net/ipv6/calipso.c:655:6: style: The scope of the variable 'ret_val' can be reduced. [variableScope]
 int ret_val;
     ^
net/ipv6/calipso.c:731:6: style: The scope of the variable 'ret_val' can be reduced. [variableScope]
 int ret_val;
     ^
net/ipv6/calipso.c:1306:31: style: The scope of the variable 'payload' can be reduced. [variableScope]
 int len_delta, new_end, pad, payload;
                              ^
net/ipv6/calipso.c:264:14: style: Variable 'ret_val' is assigned a value that is never used. [unreadVariable]
 int ret_val = -EPERM;
             ^
net/ipv6/esp6.c:791:10: style: Redundant condition: xo. '!xo || (xo && !(xo->flags&CRYPTO_DONE))' is equivalent to '!xo || !(xo->flags&CRYPTO_DONE)' [redundantCondition]
 if (!xo || (xo && !(xo->flags & CRYPTO_DONE)))
         ^
net/ipv6/esp6.c:122:22: style: The scope of the variable 'sg' can be reduced. [variableScope]
 struct scatterlist *sg;
                     ^
net/ipv6/esp6.c:94:44: portability: 'tmp' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    crypto_aead_alignmask(aead) + 1) : tmp + seqhilen;
                                           ^
net/ipv6/esp6_offload.c:319:18: style: Redundant condition: hw_offload. '!hw_offload || (hw_offload && !skb_is_gso(skb))' is equivalent to '!hw_offload || !skb_is_gso(skb)' [redundantCondition]
 if (!hw_offload || (hw_offload && !skb_is_gso(skb))) {
                 ^
net/ipv6/esp6_offload.c:92:2: warning: Either the condition '!xo' is redundant or there is possible null pointer dereference: xo. [nullPointerRedundantCheck]
 xo->flags |= XFRM_GRO;
 ^
net/ipv6/esp6_offload.c:67:6: note: Assuming that condition '!xo' is not redundant
 if (!xo || !(xo->flags & CRYPTO_DONE)) {
     ^
net/ipv6/esp6_offload.c:92:2: note: Null pointer dereference
 xo->flags |= XFRM_GRO;
 ^
net/ipv6/esp6_offload.c:33:23: style: The scope of the variable 'exthdr' can be reduced. [variableScope]
 struct ipv6_opt_hdr *exthdr;
                      ^
net/ipv6/esp6_offload.c:39:29: portability: '(void*)ipv6_hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  exthdr = (void *)ipv6_hdr + off;
                            ^
net/ipv6/exthdrs.c:678:7: style: Redundant initialization for 'idev'. The initialized value is overwritten before it is read. [redundantInitialization]
 idev = __in6_dev_get(skb->dev);
      ^
net/ipv6/exthdrs.c:668:25: note: idev is initialized
 struct inet6_dev *idev = __in6_dev_get(skb->dev);
                        ^
net/ipv6/exthdrs.c:678:7: note: idev is overwritten
 idev = __in6_dev_get(skb->dev);
      ^
net/ipv6/fib6_rules.c:476:6: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]
 err = fib_default_rule_add(ops, 0, RT6_TABLE_LOCAL, 0);
     ^
net/ipv6/fib6_rules.c:470:10: note: err is initialized
 int err = -ENOMEM;
         ^
net/ipv6/fib6_rules.c:476:6: note: err is overwritten
 err = fib_default_rule_add(ops, 0, RT6_TABLE_LOCAL, 0);
     ^
net/ipv6/ila/ila_common.c:121:14: style:inconclusive: Function 'ila_update_ipv6_locator' argument 3 names different: declaration 'set_csum_neutral' definition 'sir2ila'. [funcArgNamesDifferent]
        bool sir2ila)
             ^
net/ipv6/ila/ila.h:94:14: note: Function 'ila_update_ipv6_locator' argument 3 names different: declaration 'set_csum_neutral' definition 'sir2ila'.
        bool set_csum_neutral);
             ^
net/ipv6/ila/ila_common.c:121:14: note: Function 'ila_update_ipv6_locator' argument 3 names different: declaration 'set_csum_neutral' definition 'sir2ila'.
        bool sir2ila)
             ^
net/ipv6/inet6_hashtables.c:143:6: style: The scope of the variable 'score' can be reduced. [variableScope]
 int score, hiscore = 0;
     ^
net/ipv6/ip6_fib.c:1190:4: warning:inconclusive: Either the condition 'sibling' is redundant or there is possible null pointer dereference: sibling. [nullPointerRedundantCheck]
   sibling->fib6_nsiblings++;
   ^
net/ipv6/ip6_fib.c:1172:10: note: Assuming that condition 'sibling' is not redundant
  while (sibling) {
         ^
net/ipv6/ip6_fib.c:1190:4: note: Null pointer dereference
   sibling->fib6_nsiblings++;
   ^
net/ipv6/ip6_fib.c:1191:11: warning:inconclusive: Either the condition 'sibling' is redundant or there is possible null pointer dereference: sibling. [nullPointerRedundantCheck]
   BUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);
          ^
net/ipv6/ip6_fib.c:1172:10: note: Assuming that condition 'sibling' is not redundant
  while (sibling) {
         ^
net/ipv6/ip6_fib.c:1191:11: note: Null pointer dereference
   BUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);
          ^
net/ipv6/ip6_fib.c:1475:6: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]
 err = fib6_add_rt2node(fn, rt, info, extack);
     ^
net/ipv6/ip6_fib.c:1376:10: note: err is initialized
 int err = -ENOMEM;
         ^
net/ipv6/ip6_fib.c:1475:6: note: err is overwritten
 err = fib6_add_rt2node(fn, rt, info, extack);
     ^
net/ipv6/ip6_fib.c:515:6: style: The scope of the variable 'res' can be reduced. [variableScope]
 int res;
     ^
net/ipv6/ip6_fib.c:1045:22: style: The scope of the variable 'new_leaf' can be reduced. [variableScope]
   struct fib6_info *new_leaf;
                     ^
net/ipv6/ip6_fib.c:1747:20: style: The scope of the variable 'child_left' can be reduced. [variableScope]
 struct fib6_node *child_left, *child_right;
                   ^
net/ipv6/ip6_fib.c:1747:33: style: The scope of the variable 'child_right' can be reduced. [variableScope]
 struct fib6_node *child_left, *child_right;
                                ^
net/ipv6/ip6_fib.c:2246:21: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct hlist_head *head;
                    ^
net/ipv6/ip6_fib.c:2232:9: style: Variable 'c.func' is assigned a value that is never used. [unreadVariable]
 c.func = func;
        ^
net/ipv6/ip6_fib.c:2233:11: style: Variable 'c.sernum' is assigned a value that is never used. [unreadVariable]
 c.sernum = sernum;
          ^
net/ipv6/ip6_fib.c:2234:8: style: Variable 'c.arg' is assigned a value that is never used. [unreadVariable]
 c.arg = arg;
       ^
net/ipv6/ip6_fib.c:2235:8: style: Variable 'c.net' is assigned a value that is never used. [unreadVariable]
 c.net = net;
       ^
net/ipv6/ip6_fib.c:2236:16: style: Variable 'c.skip_notify' is assigned a value that is never used. [unreadVariable]
 c.skip_notify = skip_notify;
               ^
net/ipv6/ip6_gre.c:457:32: style: The scope of the variable 'tel' can be reduced. [variableScope]
  struct ipv6_tlv_tnl_enc_lim *tel;
                               ^
net/ipv6/ip6_gre.c:533:21: style: The scope of the variable 'md2' can be reduced. [variableScope]
 struct erspan_md2 *md2;
                    ^
net/ipv6/ip6_gre.c:1972:7: style: Local variable 'err' shadows outer variable [shadowVariable]
  int err = ip6_tnl_encap_setup(nt, &ipencap);
      ^
net/ipv6/ip6_gre.c:1967:6: note: Shadowed declaration
 int err;
     ^
net/ipv6/ip6_gre.c:1972:7: note: Shadow variable
  int err = ip6_tnl_encap_setup(nt, &ipencap);
      ^
net/ipv6/ip6_input.c:52:9: style: The scope of the variable 'edemux' can be reduced. [variableScope]
 void (*edemux)(struct sk_buff *skb);
        ^
net/ipv6/ip6_offload.c:174:23: portability: '(void*)opth' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  opth = (void *)opth + optlen;
                      ^
net/ipv6/ip6_output.c:223:7: warning: Either the condition 'np' is redundant or there is possible null pointer dereference: np. [nullPointerRedundantCheck]
 if (!np->autoflowlabel_set)
      ^
net/ipv6/ip6_output.c:285:6: note: Assuming that condition 'np' is not redundant
 if (np)
     ^
net/ipv6/ip6_output.c:291:28: note: Calling function 'ip6_autoflowlabel', 2nd argument 'np' value is 0
    ip6_autoflowlabel(net, np), fl6));
                           ^
net/ipv6/ip6_output.c:223:7: note: Null pointer dereference
 if (!np->autoflowlabel_set)
      ^
net/ipv6/ip6_output.c:65:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/ip6_output.c:1774:6: style: The scope of the variable 'exthdrlen' can be reduced. [variableScope]
 int exthdrlen;
     ^
net/ipv6/ip6_output.c:1775:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv6/ip6_output.c:1432:18: style: Local variable 'skb' shadows outer argument [shadowArgument]
 struct sk_buff *skb, *skb_prev = NULL;
                 ^
net/ipv6/ip6_output.c:1428:41: note: Shadowed declaration
      int len, int odd, struct sk_buff *skb),
                                        ^
net/ipv6/ip6_output.c:1432:18: note: Shadow variable
 struct sk_buff *skb, *skb_prev = NULL;
                 ^
net/ipv6/ip6_output.c:1440:6: style: Local variable 'offset' shadows outer argument [shadowArgument]
 int offset = 0;
     ^
net/ipv6/ip6_output.c:1427:47: note: Shadowed declaration
        int getfrag(void *from, char *to, int offset,
                                              ^
net/ipv6/ip6_output.c:1440:6: note: Shadow variable
 int offset = 0;
     ^
net/ipv6/ip6_output.c:1059:20: style: Local variable 'rt' shadows outer variable [shadowVariable]
  struct rt6_info *rt;
                   ^
net/ipv6/ip6_output.c:1043:19: note: Shadowed declaration
 struct rt6_info *rt;
                  ^
net/ipv6/ip6_output.c:1059:20: note: Shadow variable
  struct rt6_info *rt;
                   ^
net/ipv6/ip6_tunnel.c:260:4: style: Redundant initialization for 't'. The initialized value is overwritten before it is read. [redundantInitialization]
 t = netdev_priv(dev);
   ^
net/ipv6/ip6_tunnel.c:255:20: note: t is initialized
 struct ip6_tnl *t = netdev_priv(dev);
                   ^
net/ipv6/ip6_tunnel.c:260:4: note: t is overwritten
 t = netdev_priv(dev);
   ^
net/ipv6/ip6_tunnel.c:1647:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EFAULT;
      ^
net/ipv6/ip6_tunnel.c:1644:7: note: err is assigned
  err = -EPERM;
      ^
net/ipv6/ip6_tunnel.c:1647:7: note: err is overwritten
  err = -EFAULT;
      ^
net/ipv6/ip6_tunnel.c:1650:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EINVAL;
      ^
net/ipv6/ip6_tunnel.c:1647:7: note: err is assigned
  err = -EFAULT;
      ^
net/ipv6/ip6_tunnel.c:1650:7: note: err is overwritten
  err = -EINVAL;
      ^
net/ipv6/ip6_tunnel.c:1670:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1650:7: note: err is assigned
  err = -EINVAL;
      ^
net/ipv6/ip6_tunnel.c:1670:8: note: err is overwritten
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1670:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1665:9: note: err is assigned
    err = ip6_tnl0_update(t, &p1);
        ^
net/ipv6/ip6_tunnel.c:1670:8: note: err is overwritten
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1670:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1667:9: note: err is assigned
    err = ip6_tnl_update(t, &p1);
        ^
net/ipv6/ip6_tunnel.c:1670:8: note: err is overwritten
   err = 0;
       ^
net/ipv6/ip6_tunnel.c:1698:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv6/ip6_tunnel.c:1680:7: note: err is assigned
  err = -EPERM;
      ^
net/ipv6/ip6_tunnel.c:1698:7: note: err is overwritten
  err = 0;
      ^
net/ipv6/ip6_tunnel.c:1688:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = -ENOENT;
       ^
net/ipv6/ip6_tunnel.c:1685:8: note: err is assigned
   err = -EFAULT;
       ^
net/ipv6/ip6_tunnel.c:1688:8: note: err is overwritten
   err = -ENOENT;
       ^
net/ipv6/ip6_tunnel.c:1693:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = -EPERM;
       ^
net/ipv6/ip6_tunnel.c:1688:8: note: err is assigned
   err = -ENOENT;
       ^
net/ipv6/ip6_tunnel.c:1693:8: note: err is overwritten
   err = -EPERM;
       ^
net/ipv6/ip6_tunnel.c:1698:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv6/ip6_tunnel.c:1693:8: note: err is assigned
   err = -EPERM;
       ^
net/ipv6/ip6_tunnel.c:1698:7: note: err is overwritten
  err = 0;
      ^
net/ipv6/ip6_tunnel.c:509:32: style: The scope of the variable 'tel' can be reduced. [variableScope]
  struct ipv6_tlv_tnl_enc_lim *tel;
                               ^
net/ipv6/ip6_tunnel.c:1449:15: style: The scope of the variable 'mtu' can be reduced. [variableScope]
 unsigned int mtu;
              ^
net/ipv6/ip6_tunnel.c:2030:23: style: The scope of the variable 't' can be reduced. [variableScope]
 struct ip6_tnl *nt, *t;
                      ^
net/ipv6/ip6_tunnel.c:2230:18: style: The scope of the variable 't' can be reduced. [variableScope]
 struct ip6_tnl *t;
                 ^
net/ipv6/ip6_vti.c:832:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EFAULT;
      ^
net/ipv6/ip6_vti.c:829:7: note: err is assigned
  err = -EPERM;
      ^
net/ipv6/ip6_vti.c:832:7: note: err is overwritten
  err = -EFAULT;
      ^
net/ipv6/ip6_vti.c:835:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EINVAL;
      ^
net/ipv6/ip6_vti.c:832:7: note: err is assigned
  err = -EFAULT;
      ^
net/ipv6/ip6_vti.c:835:7: note: err is overwritten
  err = -EINVAL;
      ^
net/ipv6/ip6_vti.c:852:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = 0;
       ^
net/ipv6/ip6_vti.c:835:7: note: err is assigned
  err = -EINVAL;
      ^
net/ipv6/ip6_vti.c:852:8: note: err is overwritten
   err = 0;
       ^
net/ipv6/ip6_vti.c:852:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = 0;
       ^
net/ipv6/ip6_vti.c:849:8: note: err is assigned
   err = vti6_update(t, &p1, false);
       ^
net/ipv6/ip6_vti.c:852:8: note: err is overwritten
   err = 0;
       ^
net/ipv6/ip6_vti.c:879:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv6/ip6_vti.c:861:7: note: err is assigned
  err = -EPERM;
      ^
net/ipv6/ip6_vti.c:879:7: note: err is overwritten
  err = 0;
      ^
net/ipv6/ip6_vti.c:869:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = -ENOENT;
       ^
net/ipv6/ip6_vti.c:866:8: note: err is assigned
   err = -EFAULT;
       ^
net/ipv6/ip6_vti.c:869:8: note: err is overwritten
   err = -ENOENT;
       ^
net/ipv6/ip6_vti.c:874:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = -EPERM;
       ^
net/ipv6/ip6_vti.c:869:8: note: err is assigned
   err = -ENOENT;
       ^
net/ipv6/ip6_vti.c:874:8: note: err is overwritten
   err = -EPERM;
       ^
net/ipv6/ip6_vti.c:879:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/ipv6/ip6_vti.c:874:8: note: err is assigned
   err = -EPERM;
       ^
net/ipv6/ip6_vti.c:879:7: note: err is overwritten
  err = 0;
      ^
net/ipv6/ip6_vti.c:1177:19: style: The scope of the variable 'ip6n' can be reduced. [variableScope]
 struct vti6_net *ip6n;
                  ^
net/ipv6/ip6mr.c:1239:21: style: The scope of the variable 'v' can be reduced. [variableScope]
 struct vif_device *v;
                    ^
net/ipv6/ip6mr.c:1503:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/ipv6/ip6mr.c:2089:26: style:inconclusive: Function 'ip6_mr_forward' argument 5 names different: declaration 'cache' definition 'c'. [funcArgNamesDifferent]
      struct mfc6_cache *c)
                         ^
net/ipv6/ip6mr.c:87:26: note: Function 'ip6_mr_forward' argument 5 names different: declaration 'cache' definition 'c'.
      struct mfc6_cache *cache);
                         ^
net/ipv6/ip6mr.c:2089:26: note: Function 'ip6_mr_forward' argument 5 names different: declaration 'cache' definition 'c'.
      struct mfc6_cache *c)
                         ^
net/ipv6/ip6mr.c:2239:8: style: Local variable 'err' shadows outer variable [shadowVariable]
   int err = ip6mr_cache_unresolved(mrt, vif, skb, dev);
       ^
net/ipv6/ip6mr.c:2198:6: note: Shadowed declaration
 int err;
     ^
net/ipv6/ip6mr.c:2239:8: note: Shadow variable
   int err = ip6mr_cache_unresolved(mrt, vif, skb, dev);
       ^
net/ipv6/ip6mr.c:58:19: style: struct member 'ip6mr_result::mrt' is never used. [unusedStructMember]
 struct mr_table *mrt;
                  ^
net/ipv6/ip6mr.c:2513:7: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
  err = mr_table_dump(mrt, skb, cb, _ip6mr_fill_mroute,
      ^
net/ipv6/ip6mr.c:471:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
net/ipv6/ipv6_sockglue.c:705:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = -ENOBUFS;
       ^
net/ipv6/ipv6_sockglue.c:700:8: note: retv is assigned
  retv = -EINVAL;
       ^
net/ipv6/ipv6_sockglue.c:705:8: note: retv is overwritten
  retv = -ENOBUFS;
       ^
net/ipv6/ipv6_sockglue.c:712:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:705:8: note: retv is assigned
  retv = -ENOBUFS;
       ^
net/ipv6/ipv6_sockglue.c:712:8: note: retv is overwritten
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:783:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = -EINVAL;
       ^
net/ipv6/ipv6_sockglue.c:778:8: note: retv is assigned
  retv = -EADDRNOTAVAIL;
       ^
net/ipv6/ipv6_sockglue.c:783:8: note: retv is overwritten
  retv = -EINVAL;
       ^
net/ipv6/ipv6_sockglue.c:788:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = 0;
       ^
net/ipv6/ipv6_sockglue.c:783:8: note: retv is assigned
  retv = -EINVAL;
       ^
net/ipv6/ipv6_sockglue.c:788:8: note: retv is overwritten
  retv = 0;
       ^
net/ipv6/ipv6_sockglue.c:834:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:830:8: note: retv is assigned
  retv = -EPROTO;
       ^
net/ipv6/ipv6_sockglue.c:834:8: note: retv is overwritten
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:839:9: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
   retv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
        ^
net/ipv6/ipv6_sockglue.c:834:8: note: retv is assigned
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:839:9: note: retv is overwritten
   retv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);
        ^
net/ipv6/ipv6_sockglue.c:857:9: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
   retv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
        ^
net/ipv6/ipv6_sockglue.c:852:8: note: retv is assigned
  retv = -EFAULT;
       ^
net/ipv6/ipv6_sockglue.c:857:9: note: retv is overwritten
   retv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);
        ^
net/ipv6/ipv6_sockglue.c:940:8: style: Variable 'retv' is reassigned a value before the old one has been used. [redundantAssignment]
  retv = xfrm_user_policy(sk, optname, optval, optlen);
       ^
net/ipv6/ipv6_sockglue.c:937:8: note: retv is assigned
  retv = -EPERM;
       ^
net/ipv6/ipv6_sockglue.c:940:8: note: retv is overwritten
  retv = xfrm_user_policy(sk, optname, optval, optlen);
       ^
net/ipv6/ipv6_sockglue.c:1334:21: style: The scope of the variable 'dst' can be reduced. [variableScope]
  struct dst_entry *dst;
                    ^
net/ipv6/ipv6_sockglue.c:1385:7: style: Local variable 'flags' shadows outer argument [shadowArgument]
  int flags;
      ^
net/ipv6/ipv6_sockglue.c:1118:61: note: Shadowed declaration
      char __user *optval, int __user *optlen, unsigned int flags)
                                                            ^
net/ipv6/ipv6_sockglue.c:1385:7: note: Shadow variable
  int flags;
      ^
net/ipv6/ipv6_sockglue.c:252:11: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 gf32 = p + 4; /* we want ->gf_group and ->gf_slist aligned */
          ^
net/ipv6/mcast.c:438:18: warning: Either the condition '!psl' is redundant or there is possible null pointer dereference: psl. [nullPointerRedundantCheck]
 for (i = 0; i < psl->sl_count; i++) {
                 ^
net/ipv6/mcast.c:417:6: note: Assuming that condition '!psl' is not redundant
 if (!psl || psl->sl_count == psl->sl_max) {
     ^
net/ipv6/mcast.c:438:18: note: Null pointer dereference
 for (i = 0; i < psl->sl_count; i++) {
                 ^
net/ipv6/mcast.c:443:11: warning: Either the condition '!psl' is redundant or there is possible null pointer dereference: psl. [nullPointerRedundantCheck]
 for (j = psl->sl_count-1; j >= i; j--)
          ^
net/ipv6/mcast.c:417:6: note: Assuming that condition '!psl' is not redundant
 if (!psl || psl->sl_count == psl->sl_max) {
     ^
net/ipv6/mcast.c:443:11: note: Null pointer dereference
 for (j = psl->sl_count-1; j >= i; j--)
          ^
net/ipv6/mcast.c:445:2: warning: Either the condition '!psl' is redundant or there is possible null pointer dereference: psl. [nullPointerRedundantCheck]
 psl->sl_addr[i] = *source;
 ^
net/ipv6/mcast.c:417:6: note: Assuming that condition '!psl' is not redundant
 if (!psl || psl->sl_count == psl->sl_max) {
     ^
net/ipv6/mcast.c:445:2: note: Null pointer dereference
 psl->sl_addr[i] = *source;
 ^
net/ipv6/mcast.c:446:2: warning: Either the condition '!psl' is redundant or there is possible null pointer dereference: psl. [nullPointerRedundantCheck]
 psl->sl_count++;
 ^
net/ipv6/mcast.c:417:6: note: Assuming that condition '!psl' is not redundant
 if (!psl || psl->sl_count == psl->sl_max) {
     ^
net/ipv6/mcast.c:446:2: note: Null pointer dereference
 psl->sl_count++;
 ^
net/ipv6/mcast.c:659:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[MAX_ADDR_LEN];
      ^
net/ipv6/mcast.c:695:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[MAX_ADDR_LEN];
      ^
net/ipv6/mcast.c:724:70: style:inconclusive: Function 'mld_add_delrec' argument 2 names different: declaration 'pmc' definition 'im'. [funcArgNamesDifferent]
static void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)
                                                                     ^
net/ipv6/mcast.c:79:70: note: Function 'mld_add_delrec' argument 2 names different: declaration 'pmc' definition 'im'.
static void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *pmc);
                                                                     ^
net/ipv6/mcast.c:724:70: note: Function 'mld_add_delrec' argument 2 names different: declaration 'pmc' definition 'im'.
static void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)
                                                                     ^
net/ipv6/mcast.c:762:70: style:inconclusive: Function 'mld_del_delrec' argument 2 names different: declaration 'pmc' definition 'im'. [funcArgNamesDifferent]
static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)
                                                                     ^
net/ipv6/mcast.c:80:70: note: Function 'mld_del_delrec' argument 2 names different: declaration 'pmc' definition 'im'.
static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *pmc);
                                                                     ^
net/ipv6/mcast.c:762:70: note: Function 'mld_del_delrec' argument 2 names different: declaration 'pmc' definition 'im'.
static void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)
                                                                     ^
net/ipv6/mcast.c:437:5: style: Variable 'rv' is assigned a value that is never used. [unreadVariable]
 rv = 1; /* > 0 for insert logic below if sl_count is 0 */
    ^
net/ipv6/mcast_snoop.c:77:15: style: The scope of the variable 'len' can be reduced. [variableScope]
 unsigned int len;
              ^
net/ipv6/ndisc.c:320:50: style:inconclusive: Function 'ndisc_key_eq' argument 1 names different: declaration 'neigh' definition 'n'. [funcArgNamesDifferent]
static bool ndisc_key_eq(const struct neighbour *n, const void *pkey)
                                                 ^
net/ipv6/ndisc.c:75:50: note: Function 'ndisc_key_eq' argument 1 names different: declaration 'neigh' definition 'n'.
static bool ndisc_key_eq(const struct neighbour *neigh, const void *pkey);
                                                 ^
net/ipv6/ndisc.c:320:50: note: Function 'ndisc_key_eq' argument 1 names different: declaration 'neigh' definition 'n'.
static bool ndisc_key_eq(const struct neighbour *n, const void *pkey)
                                                 ^
net/ipv6/ndisc.c:191:23: portability: '(void*)cur' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  cur = ((void *)cur) + (cur->nd_opt_len << 3);
                      ^
net/ipv6/ndisc.c:213:23: portability: '(void*)cur' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  cur = ((void *)cur) + (cur->nd_opt_len << 3);
                      ^
net/ipv6/ndisc.c:282:29: portability: '(void*)nd_opt' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  nd_opt = ((void *)nd_opt) + l;
                            ^
net/ipv6/ndisc.c:738:21: style: Variable 'probes' is assigned a value that is never used. [unreadVariable]
 } else if ((probes -= NEIGH_VAR(neigh->parms, APP_PROBES)) < 0) {
                    ^
net/ipv6/netfilter/ip6_tables.c:762:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/ipv6/netfilter/ip6_tables.c:791:20: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int cpu, i;
                   ^
net/ipv6/netfilter/ip6_tables.c:1201:23: style: Local variable 'tmp' shadows outer variable [shadowVariable]
  struct xt_counters *tmp;
                      ^
net/ipv6/netfilter/ip6_tables.c:1174:26: note: Shadowed declaration
 struct xt_counters_info tmp;
                         ^
net/ipv6/netfilter/ip6_tables.c:1201:23: note: Shadow variable
  struct xt_counters *tmp;
                      ^
net/ipv6/netfilter/ip6_tables.c:130:36: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (struct ip6t_entry *)(base + offset);
                                   ^
net/ipv6/netfilter/ip6_tables.c:245:23: portability: '(void*)entry' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (void *)entry + entry->next_offset;
                      ^
net/ipv6/netfilter/ip6_tables.c:351:19: portability: 'table_base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (table_base + v != ip6t_next_entry(e) &&
                  ^
net/ipv6/netfilter/ip6_tables.c:396:33: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  struct ip6t_entry *e = entry0 + pos;
                                ^
net/ipv6/netfilter/ip6_tables.c:433:17: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     e = entry0 + pos;
                ^
net/ipv6/netfilter/ip6_tables.c:438:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
               ^
net/ipv6/netfilter/ip6_tables.c:438:22: portability: 'entry0+pos' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + pos + size;
                     ^
net/ipv6/netfilter/ip6_tables.c:459:16: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    e = entry0 + newpos;
               ^
net/ipv6/netfilter/ip6_tables.c:703:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + repl->size,
              ^
net/ipv6/netfilter/ip6_tables.c:851:21: portability: 'loc_cpu_entry' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  e = loc_cpu_entry + off;
                    ^
net/ipv6/netfilter/ip6_tables.c:852:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off, e, sizeof(*e))) {
                           ^
net/ipv6/netfilter/ip6_tables.c:856:28: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (copy_to_user(userptr + off
                           ^
net/ipv6/netfilter/ip6_tables.c:857:6: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     + offsetof(struct ip6t_entry, counters),
     ^
net/ipv6/netfilter/ip6_tables.c:867:18: portability: '(void*)e' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   m = (void *)e + i;
                 ^
net/ipv6/netfilter/ip6_tables.c:869:36: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (xt_match_to_user(m, userptr + off + i)) {
                                   ^
net/ipv6/netfilter/ip6_tables.c:869:42: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   if (xt_match_to_user(m, userptr + off + i)) {
                                         ^
net/ipv6/netfilter/ip6_tables.c:876:36: portability: 'userptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                   ^
net/ipv6/netfilter/ip6_tables.c:876:42: portability: 'userptr+off' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  if (xt_target_to_user(t, userptr + off + e->target_offset)) {
                                         ^
net/ipv6/netfilter/ip6_tables.c:1004:8: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
   ret = -EFAULT;
       ^
net/ipv6/netfilter/ip6_tables.c:988:8: note: ret is assigned
   ret = compat_table_info(private, &tmp);
       ^
net/ipv6/netfilter/ip6_tables.c:1004:8: note: ret is overwritten
   ret = -EFAULT;
       ^
net/ipv6/netfilter/ip6_tables.c:928:39: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct ip6t_entry *)(base + info->hook_entry[i])))
                                      ^
net/ipv6/netfilter/ip6_tables.c:931:39: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
      (e < (struct ip6t_entry *)(base + info->underflow[i])))
                                      ^
net/ipv6/netfilter/ip6_tables.c:1250:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct compat_ip6t_entry);
         ^
net/ipv6/netfilter/ip6_tables.c:1384:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += sizeof(struct ip6t_entry);
         ^
net/ipv6/netfilter/ip6_tables.c:1431:15: portability: 'entry0' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
       entry0 + compatr->size);
              ^
net/ipv6/netfilter/ip6t_ah.c:71:32: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    (ahinfo->hdrlen == hdrlen) ^
                               ^
net/ipv6/netfilter/ip6t_ah.c:81:31: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
   (ahinfo->hdrlen == hdrlen) ^
                              ^
net/ipv6/netfilter/ip6t_hbh.c:86:34: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    ((optinfo->hdrlen == hdrlen) ^
                                 ^
net/ipv6/netfilter/ip6t_hbh.c:90:38: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
        ((optinfo->hdrlen == hdrlen) ^
                                     ^
net/ipv6/netfilter/ip6t_hbh.c:49:15: style: The scope of the variable 'temp' can be reduced. [variableScope]
 unsigned int temp;
              ^
net/ipv6/netfilter/ip6t_hbh.c:57:15: style: The scope of the variable 'optlen' can be reduced. [variableScope]
 unsigned int optlen;
              ^
net/ipv6/netfilter/ip6t_rpfilter.c:53:51: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 fl6.flowi6_mark = flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;
                                                  ^
net/ipv6/netfilter/ip6t_rt.c:79:36: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    ((rtinfo->rt_type == rh->type) ^
                                   ^
net/ipv6/netfilter/ip6t_rt.c:84:33: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
    ((rtinfo->hdrlen == hdrlen) ^
                                ^
net/ipv6/netfilter/ip6t_rt.c:96:37: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
        ((rtinfo->hdrlen == hdrlen) ^
                                    ^
net/ipv6/netfilter/ip6t_rt.c:99:40: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
        ((rtinfo->rt_type == rh->type) ^
                                       ^
net/ipv6/netfilter/ip6t_srh.c:49:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NEXTHDR,
      ^
net/ipv6/netfilter/ip6t_srh.c:55:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:60:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:65:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:71:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:76:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:81:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:91:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:96:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:101:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:110:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_TAG,
      ^
net/ipv6/netfilter/ip6t_srh.c:143:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NEXTHDR,
      ^
net/ipv6/netfilter/ip6t_srh.c:149:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:153:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:157:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:163:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:167:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:171:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:181:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_EQ,
      ^
net/ipv6/netfilter/ip6t_srh.c:185:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_GT,
      ^
net/ipv6/netfilter/ip6t_srh.c:189:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_LT,
      ^
net/ipv6/netfilter/ip6t_srh.c:198:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_TAG,
      ^
net/ipv6/netfilter/ip6t_srh.c:211:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_PSID,
      ^
net/ipv6/netfilter/ip6t_srh.c:226:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NSID,
      ^
net/ipv6/netfilter/ip6t_srh.c:238:7: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LSID,
      ^
net/ipv6/netfilter/ip6t_srh.c:118:14: style: The scope of the variable 'psidoff' can be reduced. [variableScope]
 int hdrlen, psidoff, nsidoff, lsidoff, srhoff = 0;
             ^
net/ipv6/netfilter/ip6t_srh.c:118:23: style: The scope of the variable 'nsidoff' can be reduced. [variableScope]
 int hdrlen, psidoff, nsidoff, lsidoff, srhoff = 0;
                      ^
net/ipv6/netfilter/ip6t_srh.c:118:32: style: The scope of the variable 'lsidoff' can be reduced. [variableScope]
 int hdrlen, psidoff, nsidoff, lsidoff, srhoff = 0;
                               ^
net/ipv6/netfilter/ip6t_srh.c:120:19: style: The scope of the variable 'psid' can be reduced. [variableScope]
 struct in6_addr *psid, *nsid, *lsid;
                  ^
net/ipv6/netfilter/ip6t_srh.c:120:26: style: The scope of the variable 'nsid' can be reduced. [variableScope]
 struct in6_addr *psid, *nsid, *lsid;
                         ^
net/ipv6/netfilter/ip6t_srh.c:120:33: style: The scope of the variable 'lsid' can be reduced. [variableScope]
 struct in6_addr *psid, *nsid, *lsid;
                                ^
net/ipv6/netfilter/ip6table_mangle.c:41:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv6/netfilter/ip6table_nat.c:67:9: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int i, ret;
        ^
net/ipv6/netfilter/nf_log_ipv6.c:316:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  unsigned int i;
               ^
net/ipv6/netfilter/nf_reject_ipv6.c:343:7: style: Variable 'ip6h' is assigned a value that is never used. [unreadVariable]
 ip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_TCP,
      ^
net/ipv6/output_core.c:40:10: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
  id = 1 << 31;
         ^
net/ipv6/output_core.c:21:0: style: Variable '__aligned' is assigned a value that is never used. [unreadVariable]
 } __aligned(SIPHASH_ALIGNMENT) combined = {
^
net/ipv6/proc.c:172:3: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  snprintf(name, sizeof(name), "Icmp6%sType%u",
  ^
net/ipv6/proc.c:185:16: style: The scope of the variable 'buff' can be reduced. [variableScope]
 unsigned long buff[SNMP_MIB_MAX];
               ^
net/ipv6/raw.c:578:8: style: Condition 'csum_skb' is always false [knownConditionTrueFalse]
   if (csum_skb)
       ^
net/ipv6/raw.c:572:30: note: Assignment 'csum_skb=NULL', assigned value is 0
  struct sk_buff *csum_skb = NULL;
                             ^
net/ipv6/raw.c:578:8: note: Condition 'csum_skb' is always false
   if (csum_skb)
       ^
net/ipv6/raw.c:366:25: style: The scope of the variable 'saddr' can be reduced. [variableScope]
 const struct in6_addr *saddr, *daddr;
                        ^
net/ipv6/raw.c:366:33: style: The scope of the variable 'daddr' can be reduced. [variableScope]
 const struct in6_addr *saddr, *daddr;
                                ^
net/ipv6/raw.c:367:14: style: The scope of the variable 'net' can be reduced. [variableScope]
 struct net *net;
             ^
net/ipv6/reassembly.c:584:6: style: Condition 'ret' is always false [knownConditionTrueFalse]
 if (ret)
     ^
net/ipv6/reassembly.c:583:33: note: Assignment 'ret=ip6_frags_sysctl_register()', assigned value is 0
 ret = ip6_frags_sysctl_register();
                                ^
net/ipv6/reassembly.c:584:6: note: Condition 'ret' is always false
 if (ret)
     ^
net/ipv6/route.c:4810:23: style: Redundant condition: mtu<arg->mtu. 'mtu>=arg->mtu || (mtu<arg->mtu && mtu==idev->cnf.mtu6)' is equivalent to 'mtu>=arg->mtu || mtu==idev->cnf.mtu6' [redundantCondition]
  if (mtu >= arg->mtu ||
                      ^
net/ipv6/route.c:1494:7: style: Condition '!oldest' is always true [knownConditionTrueFalse]
  if (!oldest || time_before(rt6_ex->stamp, oldest->stamp))
      ^
net/ipv6/route.c:1488:42: note: Assignment 'oldest=NULL', assigned value is 0
 struct rt6_exception *rt6_ex, *oldest = NULL;
                                         ^
net/ipv6/route.c:1490:6: note: Assuming condition is false
 if (!bucket)
     ^
net/ipv6/route.c:1494:7: note: Condition '!oldest' is always true
  if (!oldest || time_before(rt6_ex->stamp, oldest->stamp))
      ^
net/ipv6/route.c:5203:8: style: Condition '!rt_notif' is always true [knownConditionTrueFalse]
   if (!rt_notif)
       ^
net/ipv6/route.c:5103:31: note: Assignment 'rt_notif=NULL', assigned value is 0
 struct fib6_info *rt_notif = NULL, *rt_last = NULL;
                              ^
net/ipv6/route.c:5176:16: note: Assuming condition is false
 if (list_empty(&rt6_nh_list)) {
               ^
net/ipv6/route.c:5203:8: note: Condition '!rt_notif' is always true
   if (!rt_notif)
       ^
net/ipv6/route.c:3498:6: warning: Either the condition 'if(idev)' is redundant or there is possible null pointer dereference: idev. [nullPointerRedundantCheck]
 if (idev->cnf.disable_ipv6) {
     ^
net/ipv6/route.c:3530:5: note: Assuming that condition 'if(idev)' is not redundant
 if (idev)
    ^
net/ipv6/route.c:3498:6: note: Null pointer dereference
 if (idev->cnf.disable_ipv6) {
     ^
net/ipv6/route.c:3527:24: warning: Either the condition 'if(dev)' is redundant or there is possible null pointer dereference: dev. [nullPointerRedundantCheck]
 fib6_nh->fib_nh_oif = dev->ifindex;
                       ^
net/ipv6/route.c:3536:6: note: Assuming that condition 'if(dev)' is not redundant
  if (dev)
     ^
net/ipv6/route.c:3527:24: note: Null pointer dereference
 fib6_nh->fib_nh_oif = dev->ifindex;
                       ^
net/ipv6/route.c:2412:33: style: Variable 'hash_keys.control.addr_type' is reassigned a value before the old one has been used. [redundantAssignment]
    hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
                                ^
net/ipv6/route.c:2401:31: note: hash_keys.control.addr_type is assigned
  hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
                              ^
net/ipv6/route.c:2412:33: note: hash_keys.control.addr_type is overwritten
    hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
                                ^
net/ipv6/route.c:1156:25: style: The scope of the variable 'sn' can be reduced. [variableScope]
 struct fib6_node *pn, *sn;
                        ^
net/ipv6/route.c:2049:21: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 struct hlist_node *tmp;
                    ^
net/ipv6/route.c:2050:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/ipv6/route.c:2126:24: style: The scope of the variable 'rt6_ex' can be reduced. [variableScope]
 struct rt6_exception *rt6_ex;
                       ^
net/ipv6/route.c:2127:21: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 struct hlist_node *tmp;
                    ^
net/ipv6/route.c:2128:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/ipv6/route.c:2678:22: style: The scope of the variable 'fn' can be reduced. [variableScope]
   struct fib6_node *fn;
                     ^
net/ipv6/route.c:4310:21: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct hlist_head *head;
                    ^
net/ipv6/route.c:5290:6: style: The scope of the variable 'attrlen' can be reduced. [variableScope]
 int attrlen;
     ^
net/ipv6/route.c:5291:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv6/route.c:3334:49: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 bool skip_dev = gwa_type & IPV6_ADDR_LINKLOCAL ? false : true;
                                                ^
net/ipv6/route.c:1507:33: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 val = jhash2((const u32 *)dst, sizeof(*dst)/sizeof(u32), seed);
                                ^
net/ipv6/route.c:2958:13: error: Uninitialized variable: rt [uninitvar]
  res.f6i = rt;
            ^
net/ipv6/route.c:3942:8: error: Uninitialized variable: rt [uninitvar]
   if (rt->nh && cfg->fc_nh_id &&
       ^
net/ipv6/route.c:3926:6: note: Assuming condition is false
 if (!table) {
     ^
net/ipv6/route.c:3942:8: note: Uninitialized variable: rt
   if (rt->nh && cfg->fc_nh_id &&
       ^
net/ipv6/route.c:4237:7: error: Uninitialized variable: rt [uninitvar]
  if (rt->nh)
      ^
net/ipv6/route.c:4229:6: note: Assuming condition is false
 if (!table)
     ^
net/ipv6/route.c:4237:7: note: Uninitialized variable: rt
  if (rt->nh)
      ^
net/ipv6/route.c:3018:15: style: Variable 'rdfl.gateway' is assigned a value that is never used. [unreadVariable]
 rdfl.gateway = *gateway;
              ^
net/ipv6/route.c:1511:34: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
  val = jhash2((const u32 *)src, sizeof(*src)/sizeof(u32), val);
                                 ^
net/ipv6/route.c:713:0: information: Skipping configuration 'CONFIG_IPV6_ROUTER_PREF' since the value of 'CONFIG_IPV6_ROUTER_PREF' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  ret = IS_ENABLED(CONFIG_IPV6_ROUTER_PREF) ?
^
net/ipv6/rpl_iptunnel.c:172:21: portability: '(void*)hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 isrh = (void *)hdr + sizeof(*hdr);
                    ^
net/ipv6/seg6.c:31:6: style: The scope of the variable 'max_last_entry' can be reduced. [variableScope]
 int max_last_entry;
     ^
net/ipv6/seg6.c:128:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = seg6_hmac_info_del(net, hmackeyid);
      ^
net/ipv6/seg6.c:126:8: note: err is assigned
   err = -ENOENT;
       ^
net/ipv6/seg6.c:128:7: note: err is overwritten
  err = seg6_hmac_info_del(net, hmackeyid);
      ^
net/ipv6/seg6_hmac.c:105:25: style: The scope of the variable 'algo' can be reduced. [variableScope]
 struct seg6_hmac_algo *algo;
                        ^
net/ipv6/seg6_hmac.c:353:25: style: The scope of the variable 'algo' can be reduced. [variableScope]
 struct seg6_hmac_algo *algo;
                        ^
net/ipv6/seg6_iptunnel.c:350:6: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]
 err = seg6_do_srh(skb);
     ^
net/ipv6/seg6_iptunnel.c:348:10: note: err is initialized
 int err = -EINVAL;
         ^
net/ipv6/seg6_iptunnel.c:350:6: note: err is overwritten
 err = seg6_do_srh(skb);
     ^
net/ipv6/seg6_iptunnel.c:167:21: portability: '(void*)hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 isrh = (void *)hdr + sizeof(*hdr);
                    ^
net/ipv6/seg6_iptunnel.c:216:21: portability: '(void*)hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 isrh = (void *)hdr + sizeof(*hdr);
                    ^
net/ipv6/seg6_local.c:954:27: style: The scope of the variable 'desc' can be reduced. [variableScope]
 struct seg6_action_desc *desc;
                          ^
net/ipv6/sit.c:1223:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/ipv6/syncookies.c:50:0: style: Variable '__aligned' is assigned a value that is never used. [unreadVariable]
 } __aligned(SIPHASH_ALIGNMENT) combined = {
^
net/ipv6/tcp_ipv6.c:1229:11: style: Variable 'newinet' is assigned a value that is never used. [unreadVariable]
  newinet = inet_sk(newsk);
          ^
net/ipv6/tcp_ipv6.c:1231:9: style: Variable 'newtp' is assigned a value that is never used. [unreadVariable]
  newtp = tcp_sk(newsk);
        ^
net/ipv6/tcpv6_offload.c:54:18: style: Local variable 'th' shadows outer variable [shadowVariable]
  struct tcphdr *th = tcp_hdr(skb);
                 ^
net/ipv6/tcpv6_offload.c:44:17: note: Shadowed declaration
 struct tcphdr *th;
                ^
net/ipv6/tcpv6_offload.c:54:18: note: Shadow variable
  struct tcphdr *th = tcp_hdr(skb);
                 ^
net/ipv6/tcpv6_offload.c:44:17: style: Variable 'th' is not assigned a value. [unassignedVariable]
 struct tcphdr *th;
                ^
net/ipv6/udp.c:1341:4: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
   msg->msg_name = &sin;
   ^
net/ipv6/udp.c:170:6: style: The scope of the variable 'score' can be reduced. [variableScope]
 int score, badness;
     ^
net/ipv6/udp.c:743:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/udp.c:1127:15: style: The scope of the variable 'offset' can be reduced. [variableScope]
 unsigned int offset;
              ^
net/ipv6/udp.c:1130:14: style: Variable 'csum' is assigned a value that is never used. [unreadVariable]
 __wsum csum = 0;
             ^
net/ipv6/xfrm6_protocol.c:48:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/xfrm6_protocol.c:111:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/xfrm6_protocol.c:140:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/ipv6/xfrm6_protocol.c:169:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/iucv/af_iucv.c:1613:7: warning:inconclusive: Possible null pointer dereference: sk [nullPointer]
  if (sk->sk_state == IUCV_LISTEN &&
      ^
net/iucv/af_iucv.c:1611:7: note: Assignment 'sk=NULL', assigned value is 0
 sk = NULL;
      ^
net/iucv/af_iucv.c:1613:7: note: Null pointer dereference
  if (sk->sk_state == IUCV_LISTEN &&
      ^
net/iucv/af_iucv.c:2121:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = afiucv_hs_callback_rx(sk, skb);
      ^
net/iucv/af_iucv.c:2109:7: note: err is assigned
  err = afiucv_hs_callback_win(sk, skb);
      ^
net/iucv/af_iucv.c:2121:7: note: err is overwritten
  err = afiucv_hs_callback_rx(sk, skb);
      ^
net/iucv/af_iucv.c:148:9: style: The scope of the variable 'datalen' can be reduced. [variableScope]
 size_t datalen;
        ^
net/iucv/af_iucv.c:358:16: style: The scope of the variable 'user_data' can be reduced. [variableScope]
 unsigned char user_data[16];
               ^
net/iucv/af_iucv.c:405:16: style: The scope of the variable 'timeo' can be reduced. [variableScope]
 unsigned long timeo;
               ^
net/iucv/af_iucv.c:546:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/iucv/af_iucv.c:1163:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/iucv/af_iucv.c:1224:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/iucv/af_iucv.c:1362:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/iucv/af_iucv.c:2211:20: style: The scope of the variable 'iucv' can be reduced. [variableScope]
 struct iucv_sock *iucv;
                   ^
net/iucv/af_iucv.c:1687:6: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 err = 0;
     ^
net/iucv/iucv.c:1065:21: style: The scope of the variable 'array' can be reduced. [variableScope]
 struct iucv_array *array;
                    ^
net/iucv/iucv.c:1067:9: style: The scope of the variable 'copy' can be reduced. [variableScope]
 size_t copy;
        ^
net/kcm/kcmproc.c:212:4: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]
 i = 0;
   ^
net/kcm/kcmproc.c:210:4: note: i is assigned
  i++;
   ^
net/kcm/kcmproc.c:212:4: note: i is overwritten
 i = 0;
   ^
net/kcm/kcmsock.c:810:4: warning: Either the condition '!tskb' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
   skb->ip_summed = CHECKSUM_UNNECESSARY;
   ^
net/kcm/kcmsock.c:797:11: note: Assuming that condition '!tskb' is not redundant
   while (!tskb) {
          ^
net/kcm/kcmsock.c:809:10: note: Assignment 'skb=tskb', assigned value is 0
   skb = tskb;
         ^
net/kcm/kcmsock.c:810:4: note: Null pointer dereference
   skb->ip_summed = CHECKSUM_UNNECESSARY;
   ^
net/kcm/kcmsock.c:840:2: warning:inconclusive: Either the condition '!tskb' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
 skb->len += size;
 ^
net/kcm/kcmsock.c:797:11: note: Assuming that condition '!tskb' is not redundant
   while (!tskb) {
          ^
net/kcm/kcmsock.c:809:10: note: Assignment 'skb=tskb', assigned value is 0
   skb = tskb;
         ^
net/kcm/kcmsock.c:840:2: note: Null pointer dereference
 skb->len += size;
 ^
net/kcm/kcmsock.c:841:2: warning:inconclusive: Either the condition '!tskb' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
 skb->data_len += size;
 ^
net/kcm/kcmsock.c:797:11: note: Assuming that condition '!tskb' is not redundant
   while (!tskb) {
          ^
net/kcm/kcmsock.c:809:10: note: Assignment 'skb=tskb', assigned value is 0
   skb = tskb;
         ^
net/kcm/kcmsock.c:841:2: note: Null pointer dereference
 skb->data_len += size;
 ^
net/kcm/kcmsock.c:842:2: warning:inconclusive: Either the condition '!tskb' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
 skb->truesize += size;
 ^
net/kcm/kcmsock.c:797:11: note: Assuming that condition '!tskb' is not redundant
   while (!tskb) {
          ^
net/kcm/kcmsock.c:809:10: note: Assignment 'skb=tskb', assigned value is 0
   skb = tskb;
         ^
net/kcm/kcmsock.c:842:2: note: Null pointer dereference
 skb->truesize += size;
 ^
net/kcm/kcmsock.c:950:3: warning: Either the condition '!head' is redundant or there is possible null pointer dereference: skb. [nullPointerRedundantCheck]
  skb->ip_summed = CHECKSUM_UNNECESSARY;
  ^
net/kcm/kcmsock.c:936:10: note: Assuming that condition '!head' is not redundant
  while (!head) {
         ^
net/kcm/kcmsock.c:945:9: note: Assignment 'skb=head', assigned value is 0
  skb = head;
        ^
net/kcm/kcmsock.c:950:3: note: Null pointer dereference
  skb->ip_summed = CHECKSUM_UNNECESSARY;
  ^
net/key/af_key.c:1291:6: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
 err = xfrm_init_state(x);
     ^
net/key/af_key.c:1170:6: note: err is assigned
 err = -ENOBUFS;
     ^
net/key/af_key.c:1291:6: note: err is overwritten
 err = xfrm_init_state(x);
     ^
net/key/af_key.c:2392:12: style: Variable 'sel.proto' is reassigned a value before the old one has been used. [redundantAssignment]
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:2384:12: note: sel.proto is assigned
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:2392:12: note: sel.proto is overwritten
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:774:25: style: The scope of the variable 'sec_ctx' can be reduced. [variableScope]
 struct sadb_x_sec_ctx *sec_ctx;
                        ^
net/key/af_key.c:1926:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/key/af_key.c:1994:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/key/af_key.c:2028:26: style: The scope of the variable 't' can be reduced. [variableScope]
 const struct xfrm_tmpl *t;
                         ^
net/key/af_key.c:2068:25: style: The scope of the variable 'sec_ctx' can be reduced. [variableScope]
 struct sadb_x_sec_ctx *sec_ctx;
                        ^
net/key/af_key.c:3147:25: style: The scope of the variable 'sec_ctx' can be reduced. [variableScope]
 struct sadb_x_sec_ctx *sec_ctx;
                        ^
net/key/af_key.c:1008:35: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
  n_type->sadb_x_nat_t_type_len = sizeof(*n_type)/sizeof(uint64_t);
                                  ^
net/key/af_key.c:1017:35: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
  n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
                                  ^
net/key/af_key.c:1024:35: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
  n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
                                  ^
net/key/af_key.c:1890:28: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 if (hdr->sadb_msg_len == (sizeof(*hdr) / sizeof(uint64_t))) {
                           ^
net/key/af_key.c:3413:34: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
                                 ^
net/key/af_key.c:3435:34: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
 n_port->sadb_x_nat_t_port_len = sizeof(*n_port)/sizeof(uint64_t);
                                 ^
net/key/af_key.c:384:28: style: Variable 'sin' is not assigned a value. [unassignedVariable]
 const struct sockaddr_in *sin;
                           ^
net/key/af_key.c:2601:12: style: Variable 'sel.proto' is reassigned a value before the old one has been used. [redundantAssignment]
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:2592:12: note: sel.proto is assigned
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:2601:12: note: sel.proto is overwritten
 sel.proto = pfkey_proto_to_xfrm(sa->sadb_address_proto);
           ^
net/key/af_key.c:2547:23: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int i, len, ret, err = -EINVAL;
                      ^
net/l2tp/l2tp_eth.c:166:24: style: The scope of the variable 'spriv' can be reduced. [variableScope]
 struct l2tp_eth_sess *spriv;
                       ^
net/l2tp/l2tp_eth.c:167:21: style: The scope of the variable 'dev' can be reduced. [variableScope]
 struct net_device *dev;
                    ^
net/l2tp/l2tp_netlink.c:473:6: style: Redundant initialization for 'ret'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret = l2tp_nl_tunnel_send(msg, info->snd_portid, info->snd_seq,
     ^
net/l2tp/l2tp_netlink.c:451:10: note: ret is initialized
 int ret = -ENOBUFS;
         ^
net/l2tp/l2tp_netlink.c:473:6: note: ret is overwritten
 ret = l2tp_nl_tunnel_send(msg, info->snd_portid, info->snd_seq,
     ^
net/l2tp/l2tp_netlink.c:50:8: style: The scope of the variable 'ifname' can be reduced. [variableScope]
 char *ifname;
       ^
net/l2tp/l2tp_netlink.c:76:10: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 int ret = -ENOBUFS;
         ^
net/l2tp/l2tp_ppp.c:744:6: warning: Either the condition '!tunnel' is redundant or there is possible null pointer dereference: tunnel. [nullPointerRedundantCheck]
 if (tunnel->peer_tunnel_id == 0)
     ^
net/l2tp/l2tp_ppp.c:702:7: note: Assuming that condition '!tunnel' is not redundant
  if (!tunnel) {
      ^
net/l2tp/l2tp_ppp.c:744:6: note: Null pointer dereference
 if (tunnel->peer_tunnel_id == 0)
     ^
net/lapb/lapb_out.c:68:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb, *skbn;
                 ^
net/lapb/lapb_out.c:68:24: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skb, *skbn;
                       ^
net/lapb/lapb_subr.c:48:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/llc/af_llc.c:567:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:564:6: note: rc is assigned
  rc = -ERESTARTSYS;
     ^
net/llc/af_llc.c:567:6: note: rc is overwritten
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:570:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = 0;
     ^
net/llc/af_llc.c:567:6: note: rc is assigned
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:570:6: note: rc is overwritten
  rc = 0;
     ^
net/llc/af_llc.c:609:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:606:6: note: rc is assigned
  rc = -ERESTARTSYS;
     ^
net/llc/af_llc.c:609:6: note: rc is overwritten
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:634:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = sock_intr_errno(timeo);
     ^
net/llc/af_llc.c:631:6: note: rc is assigned
  rc = -EAGAIN;
     ^
net/llc/af_llc.c:634:6: note: rc is overwritten
  rc = sock_intr_errno(timeo);
     ^
net/llc/af_llc.c:637:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = 0;
     ^
net/llc/af_llc.c:634:6: note: rc is assigned
  rc = sock_intr_errno(timeo);
     ^
net/llc/af_llc.c:637:6: note: rc is overwritten
  rc = 0;
     ^
net/llc/af_llc.c:166:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/llc/llc_c_ac.c:77:70: style:inconclusive: Function 'llc_conn_ac_data_confirm' argument 2 names different: declaration 'ev' definition 'skb'. [funcArgNamesDifferent]
static int llc_conn_ac_data_confirm(struct sock *sk, struct sk_buff *skb)
                                                                     ^
net/llc/llc_c_ac.c:34:70: note: Function 'llc_conn_ac_data_confirm' argument 2 names different: declaration 'ev' definition 'skb'.
static int llc_conn_ac_data_confirm(struct sock *sk, struct sk_buff *ev);
                                                                     ^
net/llc/llc_c_ac.c:77:70: note: Function 'llc_conn_ac_data_confirm' argument 2 names different: declaration 'ev' definition 'skb'.
static int llc_conn_ac_data_confirm(struct sock *sk, struct sk_buff *skb)
                                                                     ^
net/llc/llc_conn.c:643:25: style: The scope of the variable 'curr_state' can be reduced. [variableScope]
 struct llc_conn_state *curr_state;
                        ^
net/llc/llc_conn.c:644:22: style: The scope of the variable 'next_offset' can be reduced. [variableScope]
 int state, ev_type, next_offset;
                     ^
net/llc/llc_conn.c:435:28: style:inconclusive: Function 'llc_exec_conn_trans_actions' argument 3 names different: declaration 'ev' definition 'skb'. [funcArgNamesDifferent]
           struct sk_buff *skb)
                           ^
net/llc/llc_conn.c:37:28: note: Function 'llc_exec_conn_trans_actions' argument 3 names different: declaration 'ev' definition 'skb'.
           struct sk_buff *ev);
                           ^
net/llc/llc_conn.c:435:28: note: Function 'llc_exec_conn_trans_actions' argument 3 names different: declaration 'ev' definition 'skb'.
           struct sk_buff *skb)
                           ^
net/llc/llc_core.c:36:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/llc/llc_sap.c:365:18: style: The scope of the variable 'skb1' can be reduced. [variableScope]
 struct sk_buff *skb1;
                 ^
net/mac80211/agg-rx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/sta_info.h:124:1: error: There is an unknown macro here somewhere. Configuration is required. If DECLARE_EWMA is a macro then please configure it. [unknownMacro]
DECLARE_EWMA(avg_signal, 10, 8)
^
net/mac80211/agg-tx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/airtime.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/cfg.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 25 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/chan.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/debugfs.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/debugfs_key.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/debugfs_netdev.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/debugfs_sta.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/driver-ops.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/ethtool.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/fils_aead.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/he.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/ht.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/ibss.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/iface.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/main.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 26 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh_hwmp.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh_pathtbl.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh_plink.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh_ps.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mesh_sync.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/mlme.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/ocb.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/offchannel.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/pm.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/rate.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/rc80211_minstrel.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/rc80211_minstrel_debugfs.c:87:8: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  p += sprintf(p, " %3u%s ", mr->bitrate / 2,
       ^
net/mac80211/rc80211_minstrel_debugfs.c:108:7: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 p += sprintf(p, "\nTotal packet count::    ideal %d      "
      ^
net/mac80211/rc80211_minstrel_debugfs.c:108:7: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 p += sprintf(p, "\nTotal packet count::    ideal %d      "
      ^
net/mac80211/rc80211_minstrel_debugfs.c:144:8: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  p += sprintf(p, ",%u%s", mr->bitrate / 2,
       ^
net/mac80211/rc80211_minstrel_debugfs.c:153:8: warning: %d in format string (no. 12) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u,%u,%u,"
       ^
net/mac80211/rc80211_minstrel_debugfs.c:153:8: warning: %d in format string (no. 13) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u,%u,%u,"
       ^
net/mac80211/rc80211_minstrel_debugfs.c:62:18: style: The scope of the variable 'tp_max' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                 ^
net/mac80211/rc80211_minstrel_debugfs.c:62:26: style: The scope of the variable 'tp_avg' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                         ^
net/mac80211/rc80211_minstrel_debugfs.c:62:34: style: The scope of the variable 'eprob' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                                 ^
net/mac80211/rc80211_minstrel_debugfs.c:124:18: style: The scope of the variable 'tp_max' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                 ^
net/mac80211/rc80211_minstrel_debugfs.c:124:26: style: The scope of the variable 'tp_avg' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                         ^
net/mac80211/rc80211_minstrel_debugfs.c:124:34: style: The scope of the variable 'eprob' can be reduced. [variableScope]
 unsigned int i, tp_max, tp_avg, eprob;
                                 ^
net/mac80211/rc80211_minstrel_ht.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/rc80211_minstrel_ht_debugfs.c:89:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   p += sprintf(p, "   %2u.%1uM", r / 10, r % 10);
        ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:89:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   p += sprintf(p, "   %2u.%1uM", r / 10, r % 10);
        ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:92:8: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  p += sprintf(p, "  %3u  ", idx);
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:156:7: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
 p += sprintf(p, "\nTotal packet count::    ideal %d      "
      ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:161:8: warning: %d in format string (no. 1) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:161:8: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:235:9: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   p += sprintf(p, ",%2u.%1uM,", r / 10, r % 10);
        ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:235:9: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
   p += sprintf(p, ",%2u.%1uM,", r / 10, r % 10);
        ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:238:8: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
  p += sprintf(p, "%u,", idx);
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:259:8: warning: %d in format string (no. 2) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "%d,%d,%d.%d\n",
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:259:8: warning: %d in format string (no. 3) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "%d,%d,%d.%d\n",
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:259:8: warning: %d in format string (no. 4) requires 'int' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
  p += sprintf(p, "%d,%d,%d.%d\n",
       ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:127:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/mac80211/rc80211_minstrel_ht_debugfs.c:277:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/mac80211/rx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 25 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/s1g.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/scan.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/spectmgmt.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/sta_info.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/status.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/tdls.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/tkip.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 23 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/trace.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/tx.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 25 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/util.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/vht.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 24 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/wep.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/wme.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac80211/wpa.c:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 20 configurations. Use --force to check all configurations. [toomanyconfigs]

^
net/mac802154/trace.h:105:3: error: syntax error: keyword 'while' is not allowed in global scope [syntaxError]
  CCA_ASSIGN;
  ^
net/mac802154/llsec.c:790:8: warning:inconclusive: Possible null pointer dereference: dev [nullPointer]
   if (dev->dev.pan_id == devaddr.pan_id &&
       ^
net/mac802154/llsec.c:778:39: note: Assignment 'dev=NULL', assigned value is 0
 struct mac802154_llsec_device *dev = NULL;
                                      ^
net/mac802154/llsec.c:780:43: note: Assuming condition is false
 if (devaddr.mode == IEEE802154_ADDR_NONE &&
                                          ^
net/mac802154/llsec.c:790:8: note: Null pointer dereference
   if (dev->dev.pan_id == devaddr.pan_id &&
       ^
net/mac802154/llsec.c:799:8: warning:inconclusive: Possible null pointer dereference: dev [nullPointer]
   if (dev->dev.hwaddr == devaddr.extended_addr)
       ^
net/mac802154/llsec.c:778:39: note: Assignment 'dev=NULL', assigned value is 0
 struct mac802154_llsec_device *dev = NULL;
                                      ^
net/mac802154/llsec.c:780:43: note: Assuming condition is false
 if (devaddr.mode == IEEE802154_ADDR_NONE &&
                                          ^
net/mac802154/llsec.c:799:8: note: Null pointer dereference
   if (dev->dev.hwaddr == devaddr.extended_addr)
       ^
net/mac802154/main.c:179:5: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
 rc = wpan_phy_register(local->phy);
    ^
net/mac802154/main.c:146:9: note: rc is initialized
 int rc = -ENOSYS;
        ^
net/mac802154/main.c:179:5: note: rc is overwritten
 rc = wpan_phy_register(local->phy);
    ^
net/mpls/af_mpls.c:2742:6: style: Condition 'err' is always false [knownConditionTrueFalse]
 if (err)
     ^
net/mpls/af_mpls.c:2741:39: note: Assignment 'err=ipgre_tunnel_encap_add_mpls_ops()', assigned value is 0
 err = ipgre_tunnel_encap_add_mpls_ops();
                                      ^
net/mpls/af_mpls.c:2742:6: note: Condition 'err' is always false
 if (err)
     ^
net/mpls/af_mpls.c:691:6: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]
 err = -EINVAL;
     ^
net/mpls/af_mpls.c:681:10: note: err is initialized
 int err = -ENODEV;
         ^
net/mpls/af_mpls.c:691:6: note: err is overwritten
 err = -EINVAL;
     ^
net/mpls/af_mpls.c:1032:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = mpls_nh_build_multi(cfg, rt, max_labels, extack);
      ^
net/mpls/af_mpls.c:1020:6: note: err is assigned
 err = -ENOMEM;
     ^
net/mpls/af_mpls.c:1032:7: note: err is overwritten
  err = mpls_nh_build_multi(cfg, rt, max_labels, extack);
      ^
net/mpls/af_mpls.c:2104:7: style: The scope of the variable 'ifindex' can be reduced. [variableScope]
  int ifindex;
      ^
net/mpls/af_mpls.c:2493:41: warning: Found suspicious operator ',' [constStatement]
 struct mpls_route __rcu **labels = NULL, **old;
                                        ^
net/mpls/af_mpls.c:889:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0;
         ^
net/mptcp/options.c:502:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  remaining -= map_size;
  ^
net/mptcp/options.c:687:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  remaining -= opt_size;
  ^
net/mptcp/options.c:397:15: style: The scope of the variable 'data_len' can be reduced. [variableScope]
 unsigned int data_len;
              ^
net/mptcp/options.c:502:13: style: Variable 'remaining' is assigned a value that is never used. [unreadVariable]
  remaining -= map_size;
            ^
net/mptcp/options.c:683:13: style: Variable 'remaining' is assigned a value that is never used. [unreadVariable]
  remaining -= opt_size;
            ^
net/mptcp/options.c:687:13: style: Variable 'remaining' is assigned a value that is never used. [unreadVariable]
  remaining -= opt_size;
            ^
net/ncsi/ncsi-aen.c:34:41: portability: '(void*)(h+1)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 pchecksum = (__be32 *)((void *)(h + 1) + payload - 4);
                                        ^
net/ncsi/ncsi-aen.c:34:51: portability: '(void*)(h+1)+payload' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 pchecksum = (__be32 *)((void *)(h + 1) + payload - 4);
                                                  ^
net/ncsi/ncsi-cmd.c:56:35: portability: '(void*)h' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 pchecksum = (__be32 *)((void *)h + sizeof(struct ncsi_pkt_hdr) +
                                  ^
net/ncsi/ncsi-cmd.c:56:65: portability: '(void*)h+sizeof(struct ncsi_pkt_hdr)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 pchecksum = (__be32 *)((void *)h + sizeof(struct ncsi_pkt_hdr) +
                                                                ^
net/ncsi/ncsi-manage.c:998:11: style: Condition 'ret<0' is always true [knownConditionTrueFalse]
  if (ret < 0)
          ^
net/ncsi/ncsi-manage.c:988:10: note: Assignment 'ret=-1', assigned value is -1
  ret = -1;
         ^
net/ncsi/ncsi-manage.c:998:11: note: Condition 'ret<0' is always true
  if (ret < 0)
          ^
net/ncsi/ncsi-manage.c:647:9: warning:inconclusive: Possible null pointer dereference: vlan [nullPointer]
  vid = vlan->vid;
        ^
net/ncsi/ncsi-manage.c:631:26: note: Assignment 'vlan=NULL', assigned value is 0
 struct vlan_vid *vlan = NULL;
                         ^
net/ncsi/ncsi-manage.c:637:16: note: Assuming condition is false
 if (list_empty(&ndp->vlan_vids))
               ^
net/ncsi/ncsi-manage.c:647:9: note: Null pointer dereference
  vid = vlan->vid;
        ^
net/ncsi/ncsi-manage.c:498:14: style: Variable 'nd->state' is reassigned a value before the old one has been used. 'break;' missing? [redundantAssignInSwitch]
   nd->state = ncsi_dev_state_suspend_gls;
             ^
net/ncsi/ncsi-manage.c:476:13: note: $symbol is assigned
  nd->state = ncsi_dev_state_suspend_select;
            ^
net/ncsi/ncsi-manage.c:498:14: note: $symbol is overwritten
   nd->state = ncsi_dev_state_suspend_gls;
             ^
net/ncsi/ncsi-manage.c:429:23: style: The scope of the variable 'cmd' can be reduced. [variableScope]
 struct ncsi_cmd_pkt *cmd;
                      ^
net/ncsi/ncsi-manage.c:1685:22: style: The scope of the variable 'np' can be reduced. [variableScope]
 struct device_node *np;
                     ^
net/ncsi/ncsi-manage.c:1797:37: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 struct ncsi_channel *nc, *active, *tmp;
                                    ^
net/ncsi/ncsi-manage.c:847:28: style:inconclusive: Function 'ncsi_update_tx_channel' argument 2 names different: declaration 'np' definition 'package'. [funcArgNamesDifferent]
      struct ncsi_package *package,
                           ^
net/ncsi/internal.h:392:28: note: Function 'ncsi_update_tx_channel' argument 2 names different: declaration 'np' definition 'package'.
      struct ncsi_package *np,
                           ^
net/ncsi/ncsi-manage.c:847:28: note: Function 'ncsi_update_tx_channel' argument 2 names different: declaration 'np' definition 'package'.
      struct ncsi_package *package,
                           ^
net/ncsi/ncsi-rsp.c:82:16: style: The scope of the variable 'id' can be reduced. [variableScope]
 unsigned char id;
               ^
net/ncsi/ncsi-rsp.c:102:16: style: The scope of the variable 'id' can be reduced. [variableScope]
 unsigned char id;
               ^
net/ncsi/ncsi-rsp.c:59:41: portability: '(void*)(h+1)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 pchecksum = (__be32 *)((void *)(h + 1) + ALIGN(payload, 4) - 4);
                                        ^
net/netfilter/ipset/ip_set_bitmap_gen.h:36:1: error: There is an unknown macro here somewhere. Configuration is required. If IPSET_TOKEN is a macro then please configure it. [unknownMacro]
mtype_gc_init(struct ip_set *set, void (*gc)(struct timer_list *t))
^
net/netfilter/ipset/ip_set_core.c:921:17: style: The scope of the variable 'set' can be reduced. [variableScope]
 struct ip_set *set;
                ^
net/netfilter/ipset/ip_set_core.c:1781:23: style: The scope of the variable 'nla' can be reduced. [variableScope]
 const struct nlattr *nla;
                      ^
net/netfilter/ipset/ip_set_core.c:959:39: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 return nlh->nlmsg_flags & NLM_F_EXCL ? 0 : IPSET_FLAG_EXIST;
                                      ^
net/netfilter/ipset/ip_set_core.c:1493:36: portability: '(void*)nlh' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 struct nlattr *attr = (void *)nlh + min_len;
                                   ^
net/netfilter/ipset/ip_set_core.c:1748:34: portability: '(void*)&errmsg->msg' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  cmdattr = (void *)&errmsg->msg + min_len;
                                 ^
net/netfilter/ipset/ip_set_core.c:1203:10: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 int ret = 0;
         ^
net/netfilter/ipset/ip_set_hash_gen.h:402:1: error: There is an unknown macro here somewhere. Configuration is required. If IPSET_TOKEN is a macro then please configure it. [unknownMacro]
mtype_ahash_memsize(const struct htype *h, const struct htable *t)
^
net/netfilter/ipset/ip_set_hash_gen.h:352:1: error: There is an unknown macro here somewhere. Configuration is required. If IPSET_TOKEN is a macro then please configure it. [unknownMacro]
mtype_add_cidr(struct ip_set *set, struct htype *h, u8 cidr, u8 n)
^
net/netfilter/ipset/ip_set_list_set.c:57:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/ipvs/ip_vs_core.c:2461:21: style: The scope of the variable 'ipvs' can be reduced. [variableScope]
 struct netns_ipvs *ipvs;
                    ^
net/netfilter/ipvs/ip_vs_core.c:2479:21: style: The scope of the variable 'ipvs' can be reduced. [variableScope]
 struct netns_ipvs *ipvs;
                    ^
net/netfilter/ipvs/ip_vs_core.c:784:32: portability: '(void*)ciph' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  __be16 *ports = (void *)ciph + ciph->ihl*4;
                               ^
net/netfilter/ipvs/ip_vs_ctl.c:2828:3: error: sprintf format string requires 4 parameters but only 2 are given. [wrongPrintfScanfArgNum]
  sprintf(buf, "IP Virtual Server version %d.%d.%d (size=%d)",
  ^
net/netfilter/ipvs/ip_vs_ctl.c:1651:21: style: The scope of the variable 'ipvs' can be reduced. [variableScope]
 struct netns_ipvs *ipvs;
                    ^
net/netfilter/ipvs/ip_vs_ctl.c:2760:10: style: union member 'ip_vs_get_arglen::field_IP_VS_SO_GET_VERSION' is never used. [unusedStructMember]
 char    field_IP_VS_SO_GET_VERSION[64];
         ^
net/netfilter/ipvs/ip_vs_dh.c:103:21: style: The scope of the variable 'dest' can be reduced. [variableScope]
 struct ip_vs_dest *dest;
                    ^
net/netfilter/ipvs/ip_vs_dh.c:138:21: style: The scope of the variable 'dest' can be reduced. [variableScope]
 struct ip_vs_dest *dest;
                    ^
net/netfilter/ipvs/ip_vs_ftp.c:102:11: style: The scope of the variable 'c' can be reduced. [variableScope]
 char *s, c;
          ^
net/netfilter/ipvs/ip_vs_ftp.c:106:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i = 0;
     ^
net/netfilter/ipvs/ip_vs_lc.c:46:7: style: Condition '!least' is always true [knownConditionTrueFalse]
  if (!least || doh < loh) {
      ^
net/netfilter/ipvs/ip_vs_lc.c:27:36: note: Assignment 'least=NULL', assigned value is 0
 struct ip_vs_dest *dest, *least = NULL;
                                   ^
net/netfilter/ipvs/ip_vs_lc.c:42:45: note: Assuming condition is false
  if ((dest->flags & IP_VS_DEST_F_OVERLOAD) ||
                                            ^
net/netfilter/ipvs/ip_vs_lc.c:46:7: note: Condition '!least' is always true
  if (!least || doh < loh) {
      ^
net/netfilter/ipvs/ip_vs_mh.c:332:10: style: Condition 'g>0' is always false [knownConditionTrueFalse]
   if (g > 0)
         ^
net/netfilter/ipvs/ip_vs_mh.c:327:10: note: Assignment 'g=0', assigned value is 0
 int g = 0;
         ^
net/netfilter/ipvs/ip_vs_mh.c:332:10: note: Condition 'g>0' is always false
   if (g > 0)
         ^
net/netfilter/ipvs/ip_vs_mh.c:109:21: style: The scope of the variable 'dest' can be reduced. [variableScope]
 struct ip_vs_dest *dest;
                    ^
net/netfilter/ipvs/ip_vs_mh.c:128:6: style: The scope of the variable 'lw' can be reduced. [variableScope]
 int lw;
     ^
net/netfilter/ipvs/ip_vs_mh.c:251:23: style: The scope of the variable 'roffset' can be reduced. [variableScope]
 unsigned int offset, roffset;
                      ^
net/netfilter/ipvs/ip_vs_mh.c:252:15: style: The scope of the variable 'hash' can be reduced. [variableScope]
 unsigned int hash, ihash;
              ^
net/netfilter/ipvs/ip_vs_mh.c:326:6: style: The scope of the variable 'weight' can be reduced. [variableScope]
 int weight;
     ^
net/netfilter/ipvs/ip_vs_mh.c:347:6: style: The scope of the variable 'new_weight' can be reduced. [variableScope]
 int new_weight, weight = 0;
     ^
net/netfilter/ipvs/ip_vs_nfct.c:245:18: style: The scope of the variable 'ct' can be reduced. [variableScope]
 struct nf_conn *ct;
                 ^
net/netfilter/ipvs/ip_vs_ovf.c:41:7: style: Condition '!h' is always true [knownConditionTrueFalse]
  if (!h || w > hw) {
      ^
net/netfilter/ipvs/ip_vs_ovf.c:28:32: note: Assignment 'h=NULL', assigned value is 0
 struct ip_vs_dest *dest, *h = NULL;
                               ^
net/netfilter/ipvs/ip_vs_ovf.c:38:43: note: Assuming condition is false
      atomic_read(&dest->activeconns) > w ||
                                          ^
net/netfilter/ipvs/ip_vs_ovf.c:41:7: note: Condition '!h' is always true
  if (!h || w > hw) {
      ^
net/netfilter/ipvs/ip_vs_ovf.c:29:14: style: The scope of the variable 'w' can be reduced. [variableScope]
 int hw = 0, w;
             ^
net/netfilter/ipvs/ip_vs_proto.c:331:27: style: The scope of the variable 'pd' can be reduced. [variableScope]
 struct ip_vs_proto_data *pd;
                          ^
net/netfilter/ipvs/ip_vs_proto.c:376:25: style: The scope of the variable 'pp' can be reduced. [variableScope]
 struct ip_vs_protocol *pp;
                        ^
net/netfilter/ipvs/ip_vs_proto_sctp.c:22:34: style: The scope of the variable 'sch' can be reduced. [variableScope]
 struct sctp_chunkhdr _schunkh, *sch;
                                 ^
net/netfilter/ipvs/ip_vs_proto_sctp.c:123:43: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sctph = (void *) skb_network_header(skb) + sctphoff;
                                          ^
net/netfilter/ipvs/ip_vs_proto_sctp.c:170:43: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sctph = (void *) skb_network_header(skb) + sctphoff;
                                          ^
net/netfilter/ipvs/ip_vs_proto_tcp.c:182:41: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 tcph = (void *)skb_network_header(skb) + tcphoff;
                                        ^
net/netfilter/ipvs/ip_vs_proto_tcp.c:263:41: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 tcph = (void *)skb_network_header(skb) + tcphoff;
                                        ^
net/netfilter/ipvs/ip_vs_proto_udp.c:173:41: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 udph = (void *)skb_network_header(skb) + udphoff;
                                        ^
net/netfilter/ipvs/ip_vs_proto_udp.c:257:41: portability: '(void*)skb_network_header(skb)' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 udph = (void *)skb_network_header(skb) + udphoff;
                                        ^
net/netfilter/ipvs/ip_vs_sched.c:43:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/ipvs/ip_vs_sh.c:124:23: style: The scope of the variable 'roffset' can be reduced. [variableScope]
 unsigned int offset, roffset;
                      ^
net/netfilter/ipvs/ip_vs_sh.c:125:15: style: The scope of the variable 'hash' can be reduced. [variableScope]
 unsigned int hash, ihash;
              ^
net/netfilter/ipvs/ip_vs_sh.c:214:21: style: The scope of the variable 'dest' can be reduced. [variableScope]
 struct ip_vs_dest *dest;
                    ^
net/netfilter/ipvs/ip_vs_sync.c:1818:10: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
  result = -EEXIST;
         ^
net/netfilter/ipvs/ip_vs_sync.c:1759:13: note: result is initialized
 int result = -ENOMEM;
            ^
net/netfilter/ipvs/ip_vs_sync.c:1818:10: note: result is overwritten
  result = -EEXIST;
         ^
net/netfilter/ipvs/ip_vs_sync.c:1209:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, nr_conns;
     ^
net/netfilter/ipvs/ip_vs_sync.c:1209:9: style: The scope of the variable 'nr_conns' can be reduced. [variableScope]
 int i, nr_conns;
        ^
net/netfilter/ipvs/ip_vs_sync.c:1181:38: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    (opt_flags & IPVS_OPT_F_SEQ_DATA ? &opt : NULL)
                                     ^
net/netfilter/ipvs/ip_vs_sync.c:1188:38: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    (opt_flags & IPVS_OPT_F_SEQ_DATA ? &opt : NULL)
                                     ^
net/netfilter/ipvs/ip_vs_wrr.c:78:10: style: Condition 'g>0' is always false [knownConditionTrueFalse]
   if (g > 0)
         ^
net/netfilter/ipvs/ip_vs_wrr.c:73:10: note: Assignment 'g=0', assigned value is 0
 int g = 0;
         ^
net/netfilter/ipvs/ip_vs_wrr.c:78:10: note: Condition 'g>0' is always false
   if (g > 0)
         ^
net/netfilter/ipvs/ip_vs_wrr.c:72:6: style: The scope of the variable 'weight' can be reduced. [variableScope]
 int weight;
     ^
net/netfilter/ipvs/ip_vs_wrr.c:94:6: style: The scope of the variable 'new_weight' can be reduced. [variableScope]
 int new_weight, weight = 0;
     ^
net/netfilter/ipvs/ip_vs_xmit.c:1060:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += GUE_LEN_PRIV;
       ^
net/netfilter/ipvs/ip_vs_xmit.c:1076:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += GUE_PLEN_REMCSUM;
       ^
net/netfilter/ipvs/ip_vs_xmit.c:1076:8: style: Variable 'data' is assigned a value that is never used. [unreadVariable]
  data += GUE_PLEN_REMCSUM;
       ^
net/netfilter/nft_meta.c:870:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/netfilter/nft_nat.c:383:6: style: Condition 'ret' is always false [knownConditionTrueFalse]
 if (ret)
     ^
net/netfilter/nft_nat.c:381:36: note: Assignment 'ret=nft_nat_inet_module_init()', assigned value is 0
 int ret = nft_nat_inet_module_init();
                                   ^
net/netfilter/nft_nat.c:383:6: note: Condition 'ret' is always false
 if (ret)
     ^
net/netfilter/nft_objref.c:38:6: style: Redundant initialization for 'obj'. The initialized value is overwritten before it is read. [redundantInitialization]
 obj = nft_obj_lookup(ctx->net, ctx->table,
     ^
net/netfilter/nft_objref.c:29:25: note: obj is initialized
 struct nft_object *obj = nft_objref_priv(expr);
                        ^
net/netfilter/nft_objref.c:38:6: note: obj is overwritten
 obj = nft_obj_lookup(ctx->net, ctx->table,
     ^
net/netfilter/nft_osf.c:26:7: style: The scope of the variable 'os_match' can be reduced. [variableScope]
 char os_match[NFT_OSF_MAXGENRELEN + 1];
      ^
net/netfilter/nft_redir.c:267:10: style: Condition 'ret<0' is always false [knownConditionTrueFalse]
 if (ret < 0) {
         ^
net/netfilter/nft_redir.c:266:34: note: Assignment 'ret=nft_redir_module_init_inet()', assigned value is 0
 ret = nft_redir_module_init_inet();
                                 ^
net/netfilter/nft_redir.c:267:10: note: Condition 'ret<0' is always false
 if (ret < 0) {
         ^
net/netfilter/nft_redir.c:49:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/netfilter/nft_set_pipapo.c:374:29: style: Opposite expression on both sides of '&'. [oppositeExpression]
   unsigned long t = bitset & -bitset;
                            ^
net/netfilter/nft_set_pipapo.c:368:16: style: The scope of the variable 'bitset' can be reduced. [variableScope]
 unsigned long bitset;
               ^
net/netfilter/nft_set_pipapo.c:1165:20: style: The scope of the variable 'err' can be reduced. [variableScope]
 int i, bsize_max, err = 0;
                   ^
net/netfilter/nft_set_pipapo.c:1165:24: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int i, bsize_max, err = 0;
                       ^
net/netfilter/nft_set_pipapo.h:192:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 unsigned long *lt = NFT_PIPAPO_LT_ALIGN(f->lt);
^
net/netfilter/nft_set_pipapo.h:220:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 unsigned long *lt = NFT_PIPAPO_LT_ALIGN(f->lt);
^
net/netfilter/nft_set_pipapo.c:630:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      NFT_PIPAPO_ALIGN / sizeof(*new_lt));
^
net/netfilter/nft_set_pipapo.c:643:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
     NFT_PIPAPO_ALIGN_HEADROOM,
^
net/netfilter/nft_set_pipapo.c:648:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 new_p = NFT_PIPAPO_LT_ALIGN(new_lt);
^
net/netfilter/nft_set_pipapo.c:649:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 old_p = NFT_PIPAPO_LT_ALIGN(old_lt);
^
net/netfilter/nft_set_pipapo.c:679:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  NFT_PIPAPO_LT_ASSIGN(f, new_lt);
^
net/netfilter/nft_set_pipapo.c:701:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 pos = NFT_PIPAPO_LT_ALIGN(f->lt);
^
net/netfilter/nft_set_pipapo.c:867:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 new_lt = kvzalloc(lt_size + NFT_PIPAPO_ALIGN_HEADROOM, GFP_KERNEL);
^
net/netfilter/nft_set_pipapo.c:874:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       NFT_PIPAPO_LT_ALIGN(f->lt),
^
net/netfilter/nft_set_pipapo.c:875:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       NFT_PIPAPO_LT_ALIGN(new_lt));
^
net/netfilter/nft_set_pipapo.c:878:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       NFT_PIPAPO_LT_ALIGN(f->lt),
^
net/netfilter/nft_set_pipapo.c:879:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
       NFT_PIPAPO_LT_ALIGN(new_lt));
^
net/netfilter/nft_set_pipapo.c:887:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 NFT_PIPAPO_LT_ASSIGN(f, new_lt);
^
net/netfilter/nft_set_pipapo.c:1118:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
           NFT_PIPAPO_ALIGN_HEADROOM,
^
net/netfilter/nft_set_pipapo.c:1136:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  scratch_aligned = NFT_PIPAPO_LT_ALIGN(scratch);
^
net/netfilter/nft_set_pipapo.c:1306:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
      NFT_PIPAPO_ALIGN_HEADROOM,
^
net/netfilter/nft_set_pipapo.c:1311:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  NFT_PIPAPO_LT_ASSIGN(dst, new_lt);
^
net/netfilter/nft_set_pipapo.c:1313:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  memcpy(NFT_PIPAPO_LT_ALIGN(new_lt),
^
net/netfilter/nft_set_pipapo.c:1314:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
         NFT_PIPAPO_LT_ALIGN(src->lt),
^
net/netfilter/nft_set_pipapo.c:1497:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   pos = NFT_PIPAPO_LT_ALIGN(f->lt) + g *
^
net/netfilter/nft_set_pipapo.c:1810:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
   pos = NFT_PIPAPO_LT_ALIGN(f->lt) +
^
net/netfilter/nft_set_pipapo.c:2087:0: information: Skipping configuration 'NFT_PIPAPO_ALIGN' since the value of 'NFT_PIPAPO_ALIGN' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
  NFT_PIPAPO_LT_ASSIGN(f, NULL);
^
net/netfilter/nft_set_pipapo_avx2.c:105:16: style: The scope of the variable 'mask' can be reduced. [variableScope]
 unsigned long mask;
               ^
net/netfilter/nft_set_pipapo_avx2.c:222:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:284:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:363:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:459:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:553:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:679:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:736:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:800:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:875:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:960:69: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, m256_size = f->bsize / NFT_PIPAPO_LONGS_PER_M256, b;
                                                                    ^
net/netfilter/nft_set_pipapo_avx2.c:1053:19: style: The scope of the variable 'b' can be reduced. [variableScope]
 int i, ret = -1, b;
                  ^
net/netfilter/nft_set_pipapo_avx2.c:254:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:256:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:330:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:332:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:425:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:427:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:514:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:516:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:649:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:651:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:706:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:708:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:770:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:772:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:845:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:847:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:930:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:932:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:1022:1: style: Label 'nomatch' is not used. [unusedLabel]
nomatch:
^
net/netfilter/nft_set_pipapo_avx2.c:1024:1: style: Label 'nothing' is not used. [unusedLabel]
nothing:
^
net/netfilter/nft_set_pipapo_avx2.c:1052:20: style: Variable 'lt' is assigned a value that is never used. [unreadVariable]
 unsigned long *lt = f->lt, bsize = f->bsize;
                   ^
net/netfilter/nft_set_pipapo_avx2.c:1055:5: style: Variable 'lt' is assigned a value that is never used. [unreadVariable]
 lt += offset * NFT_PIPAPO_LONGS_PER_M256;
    ^
net/netfilter/nft_set_rbtree.c:55:14: style: The scope of the variable 'this' can be reduced. [variableScope]
 const void *this;
             ^
net/netfilter/nft_set_rbtree.c:56:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
net/netfilter/nft_set_rbtree.c:136:14: style: The scope of the variable 'this' can be reduced. [variableScope]
 const void *this;
             ^
net/netfilter/nft_set_rbtree.c:137:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
net/netfilter/nft_set_rbtree.c:226:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
net/netfilter/nft_set_rbtree.c:428:6: style: The scope of the variable 'd' can be reduced. [variableScope]
 int d;
     ^
net/netfilter/nft_set_rbtree.c:577:26: style: The scope of the variable 'rbe' can be reduced. [variableScope]
 struct nft_rbtree_elem *rbe;
                         ^
net/netfilter/x_tables.c:461:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/x_tables.c:964:6: style: The scope of the variable 'm' can be reduced. [variableScope]
 int m, low = 0, hi = size;
     ^
net/netfilter/x_tables.c:984:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/x_tables.c:1188:6: style: The scope of the variable 'cpu' can be reduced. [variableScope]
 int cpu;
     ^
net/netfilter/x_tables.c:299:21: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     clear_user(dst + usersize, aligned_size - usersize))
                    ^
net/netfilter/x_tables.c:932:42: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return xt_check_entry_match(elems, base + target_offset,
                                         ^
net/netfilter/x_tables.c:42:15: style: struct member 'compat_delta::offset' is never used. [unusedStructMember]
 unsigned int offset; /* offset in kernel */
              ^
net/netfilter/x_tables.c:43:6: style: struct member 'compat_delta::delta' is never used. [unusedStructMember]
 int delta; /* delta in 32bit user land */
     ^
net/netfilter/x_tables.c:1339:22: style: Variable 'mem' is not assigned a value. [unassignedVariable]
 struct xt_counters *mem;
                     ^
net/netfilter/x_tables.c:680:6: style: The scope of the variable 'mid' can be reduced. [variableScope]
 int mid, left = 0, right = xt[af].cur - 1;
     ^
net/netfilter/x_tables.c:755:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += msize;
         ^
net/netfilter/x_tables.c:785:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += msize;
         ^
net/netfilter/x_tables.c:844:42: portability: 'base' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return xt_check_entry_match(elems, base + target_offset,
                                         ^
net/netfilter/x_tables.c:1138:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += tsize;
         ^
net/netfilter/x_tables.c:1162:10: portability: '*dstptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *dstptr += tsize;
         ^
net/netfilter/xt_CT.c:271:23: style: The scope of the variable 'help' can be reduced. [variableScope]
 struct nf_conn_help *help;
                      ^
net/netfilter/xt_CT.c:175:6: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 ret = 0;
     ^
net/netfilter/xt_HMARK.c:66:9: style: Variable 'hp.b32' is assigned a value that is never used. [unreadVariable]
 hp.b32 = (uports->b32 & info->port_mask.b32) | info->port_set.b32;
        ^
net/netfilter/xt_addrtype.c:151:55: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  ret &= match_type(net, dev, iph->daddr, info->dest) ^
                                                      ^
net/netfilter/xt_cluster.c:118:43: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return !!((1 << hash) & info->node_mask) ^
                                          ^
net/netfilter/xt_connlimit.c:78:37: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return (connections > info->limit) ^ !!(info->flags & XT_CONNLIMIT_INVERT);
                                    ^
net/netfilter/xt_conntrack.c:83:44: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (nf_ct_protonum(ct) == info->l4proto) ^
                                           ^
net/netfilter/xt_conntrack.c:89:47: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (tuple->src.u.all == info->origsrc_port) ^
                                              ^
net/netfilter/xt_conntrack.c:94:47: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (tuple->dst.u.all == info->origdst_port) ^
                                              ^
net/netfilter/xt_conntrack.c:101:47: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (tuple->src.u.all == info->replsrc_port) ^
                                              ^
net/netfilter/xt_conntrack.c:106:47: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (tuple->dst.u.all == info->repldst_port) ^
                                              ^
net/netfilter/xt_conntrack.c:127:44: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (nf_ct_protonum(ct) == info->l4proto) ^
                                           ^
net/netfilter/xt_conntrack.c:186:33: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (!!(state_mask & statebit) ^
                                ^
net/netfilter/xt_conntrack.c:194:49: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (CTINFO2DIR(ctinfo) == IP_CT_DIR_ORIGINAL) ^
                                                ^
net/netfilter/xt_conntrack.c:199:54: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (conntrack_mt_origsrc(ct, info, xt_family(par)) ^
                                                     ^
net/netfilter/xt_conntrack.c:204:54: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (conntrack_mt_origdst(ct, info, xt_family(par)) ^
                                                     ^
net/netfilter/xt_conntrack.c:209:54: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (conntrack_mt_replsrc(ct, info, xt_family(par)) ^
                                                     ^
net/netfilter/xt_conntrack.c:214:54: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (conntrack_mt_repldst(ct, info, xt_family(par)) ^
                                                     ^
net/netfilter/xt_conntrack.c:227:36: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (!!(status_mask & ct->status) ^
                                   ^
net/netfilter/xt_conntrack.c:235:37: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
      expires <= info->expires_max) ^
                                    ^
net/netfilter/xt_dccp.c:111:10: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return  DCCHECK(ntohs(dh->dccph_sport) >= info->spts[0]
         ^
net/netfilter/xt_dccp.c:114:6: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  && DCCHECK(ntohs(dh->dccph_dport) >= info->dpts[0]
     ^
net/netfilter/xt_dccp.c:117:6: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  && DCCHECK(match_types(dh, info->typemask),
     ^
net/netfilter/xt_dccp.c:119:6: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  && DCCHECK(match_option(info->option, skb, par->thoff, dh,
     ^
net/netfilter/xt_devgroup.c:24:63: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
     (((info->src_group ^ xt_in(par)->group) & info->src_mask ? 1 : 0) ^
                                                              ^
net/netfilter/xt_devgroup.c:29:64: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
     (((info->dst_group ^ xt_out(par)->group) & info->dst_mask ? 1 : 0) ^
                                                               ^
net/netfilter/xt_dscp.c:30:30: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return (dscp == info->dscp) ^ !!info->invert;
                             ^
net/netfilter/xt_dscp.c:39:30: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return (dscp == info->dscp) ^ !!info->invert;
                             ^
net/netfilter/xt_dscp.c:58:27: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
         info->tos_value) ^ !!info->invert;
                          ^
net/netfilter/xt_dscp.c:61:27: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
         info->tos_value) ^ !!info->invert;
                          ^
net/netfilter/xt_ecn.c:66:64: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return ((ip_hdr(skb)->tos & XT_ECN_IP_MASK) == einfo->ip_ect) ^
                                                               ^
net/netfilter/xt_ecn.c:108:25: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
         einfo->ip_ect) ^
                        ^
net/netfilter/xt_hashlimit.c:844:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/xt_hashlimit.c:1174:22: style: The scope of the variable 'ent' can be reduced. [variableScope]
 struct dsthash_ent *ent;
                     ^
net/netfilter/xt_hashlimit.c:1188:22: style: The scope of the variable 'ent' can be reduced. [variableScope]
 struct dsthash_ent *ent;
                     ^
net/netfilter/xt_hashlimit.c:1202:22: style: The scope of the variable 'ent' can be reduced. [variableScope]
 struct dsthash_ent *ent;
                     ^
net/netfilter/xt_hashlimit.c:187:5: warning:inconclusive: Division of result of sizeof() on pointer type. [divideSizeof]
    sizeof(*dst)/sizeof(u32),
    ^
net/netfilter/xt_ipvs.c:61:30: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  match = skb->ipvs_property ^
                             ^
net/netfilter/xt_ipvs.c:75:39: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if ((iph.protocol == data->l4proto) ^
                                      ^
net/netfilter/xt_ipvs.c:102:34: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if ((cp->vport == data->vport) ^
                                 ^
net/netfilter/xt_ipvs.c:110:46: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
       cp->control->vport == data->vportctl) ^
                                             ^
net/netfilter/xt_ipvs.c:125:34: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if ((ctinfo >= IP_CT_IS_REPLY) ^
                                 ^
net/netfilter/xt_ipvs.c:133:65: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (((cp->flags & IP_VS_CONN_F_FWD_MASK) == data->fwd_method) ^
                                                                ^
net/netfilter/xt_ipvs.c:141:31: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
        &data->vmask, family) ^
                              ^
net/netfilter/xt_owner.c:88:47: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
       uid_lte(filp->f_cred->fsuid, uid_max)) ^
                                              ^
net/netfilter/xt_owner.c:115:13: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (match ^ !(info->invert & XT_OWNER_GID))
            ^
net/netfilter/xt_owner.c:94:16: style: The scope of the variable 'i' can be reduced. [variableScope]
  unsigned int i, match = false;
               ^
net/netfilter/xt_physdev.c:59:16: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (!!outdev ^ !(info->invert & XT_PHYSDEV_OP_BRIDGED)))
               ^
net/netfilter/xt_physdev.c:66:14: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (!indev ^ !!(info->invert & XT_PHYSDEV_OP_ISIN))) ||
             ^
net/netfilter/xt_physdev.c:68:15: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
     (!outdev ^ !!(info->invert & XT_PHYSDEV_OP_ISOUT))))
              ^
net/netfilter/xt_physdev.c:78:12: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  if (!ret ^ !(info->invert & XT_PHYSDEV_OP_IN))
           ^
net/netfilter/xt_physdev.c:91:16: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return (!!ret ^ !(info->invert & XT_PHYSDEV_OP_OUT));
               ^
net/netfilter/xt_policy.c:55:31: style: The scope of the variable 'e' can be reduced. [variableScope]
 const struct xt_policy_elem *e;
                              ^
net/netfilter/xt_policy.c:58:9: style: The scope of the variable 'pos' can be reduced. [variableScope]
 int i, pos;
        ^
net/netfilter/xt_policy.c:85:31: style: The scope of the variable 'e' can be reduced. [variableScope]
 const struct xt_policy_elem *e;
                              ^
net/netfilter/xt_policy.c:88:9: style: The scope of the variable 'pos' can be reduced. [variableScope]
 int i, pos;
        ^
net/netfilter/xt_policy.c:122:44: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  ret = info->flags & XT_POLICY_MATCH_NONE ? true : false;
                                           ^
net/netfilter/xt_rateest.c:68:47: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 ret ^= info->flags & XT_RATEEST_MATCH_INVERT ? true : false;
                                              ^
net/netfilter/xt_recent.c:360:6: style: Redundant initialization for 'ret'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret = xt_check_proc_name(info->name, sizeof(info->name));
     ^
net/netfilter/xt_recent.c:336:10: note: ret is initialized
 int ret = -EINVAL;
         ^
net/netfilter/xt_recent.c:360:6: note: ret is overwritten
 ret = xt_check_proc_name(info->name, sizeof(info->name));
     ^
net/netfilter/xt_sctp.c:138:10: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
 return  SCCHECK(ntohs(sh->source) >= info->spts[0]
         ^
net/netfilter/xt_sctp.c:141:3: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  SCCHECK(ntohs(sh->dest) >= info->dpts[0]
  ^
net/netfilter/xt_sctp.c:144:3: style: Boolean result is used in bitwise operation. Clarify expression with parentheses. [clarifyCondition]
  SCCHECK(match_packet(skb, par->thoff + sizeof(_sh),
  ^
net/netfilter/xt_set.c:392:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netfilter/xt_set.c:438:10: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 int ret = 0;
         ^
net/netfilter/xt_u32.c:22:15: style: The scope of the variable 'nnums' can be reduced. [variableScope]
 unsigned int nnums;
              ^
net/netfilter/xt_u32.c:23:15: style: The scope of the variable 'nvals' can be reduced. [variableScope]
 unsigned int nvals;
              ^
net/netlabel/netlabel_addrlist.c:162:7: warning:inconclusive: Either the condition 'iter!=NULL' is redundant or there is possible null pointer dereference: iter. [nullPointerRedundantCheck]
  if (iter->valid &&
      ^
net/netlabel/netlabel_addrlist.c:153:11: note: Assuming that condition 'iter!=NULL' is not redundant
 if (iter != NULL &&
          ^
net/netlabel/netlabel_addrlist.c:162:7: note: Null pointer dereference
  if (iter->valid &&
      ^
net/netlabel/netlabel_calipso.c:293:10: style: Redundant initialization for 'ret_val'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret_val = netlbl_domhsh_walk(&skip_bkt, &skip_chain,
         ^
net/netlabel/netlabel_calipso.c:281:14: note: ret_val is initialized
 int ret_val = -EINVAL;
             ^
net/netlabel/netlabel_calipso.c:293:10: note: ret_val is overwritten
 ret_val = netlbl_domhsh_walk(&skip_bkt, &skip_chain,
         ^
net/netlabel/netlabel_cipso_v4.c:152:10: style: Redundant initialization for 'ret_val'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret_val = netlbl_cipsov4_add_common(info, doi_def);
         ^
net/netlabel/netlabel_cipso_v4.c:124:14: note: ret_val is initialized
 int ret_val = -EINVAL;
             ^
net/netlabel/netlabel_cipso_v4.c:152:10: note: ret_val is overwritten
 ret_val = netlbl_cipsov4_add_common(info, doi_def);
         ^
net/netlabel/netlabel_cipso_v4.c:712:10: style: Redundant initialization for 'ret_val'. The initialized value is overwritten before it is read. [redundantInitialization]
 ret_val = netlbl_domhsh_walk(&skip_bkt, &skip_chain,
         ^
net/netlabel/netlabel_cipso_v4.c:700:14: note: ret_val is initialized
 int ret_val = -EINVAL;
             ^
net/netlabel/netlabel_cipso_v4.c:712:10: note: ret_val is overwritten
 ret_val = netlbl_domhsh_walk(&skip_bkt, &skip_chain,
         ^
net/netlabel/netlabel_domainhash.c:141:20: style: The scope of the variable 'bkt_list' can be reduced. [variableScope]
 struct list_head *bkt_list;
                   ^
net/netlabel/netlabel_domainhash.c:142:25: style: The scope of the variable 'iter' can be reduced. [variableScope]
 struct netlbl_dom_map *iter;
                        ^
net/netlink/af_netlink.c:306:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netlink/af_netlink.c:538:16: style: The scope of the variable 'mask' can be reduced. [variableScope]
 unsigned long mask;
               ^
net/netlink/af_netlink.c:1771:12: style: The scope of the variable 'idx' can be reduced. [variableScope]
  int pos, idx, shift;
           ^
net/netlink/af_netlink.c:1771:17: style: The scope of the variable 'shift' can be reduced. [variableScope]
  int pos, idx, shift;
                ^
net/netlink/af_netlink.c:2113:20: style: The scope of the variable 'new' can be reduced. [variableScope]
 struct listeners *new, *old;
                   ^
net/netlink/af_netlink.c:2113:26: style: The scope of the variable 'old' can be reduced. [variableScope]
 struct listeners *new, *old;
                         ^
net/netlink/af_netlink.c:2831:1: error: There is an unknown macro here somewhere. Configuration is required. If BTF_ID_LIST is a macro then please configure it. [unknownMacro]
BTF_ID_LIST(btf_netlink_sock_id)
^
net/netlink/genetlink.c:1422:7: style: Condition 'prev' is always false [knownConditionTrueFalse]
  if (prev) {
      ^
net/netlink/genetlink.c:1417:27: note: Assignment 'prev=NULL', assigned value is 0
 struct net *net, *prev = NULL;
                          ^
net/netlink/genetlink.c:1422:7: note: Condition 'prev' is always false
  if (prev) {
      ^
net/netlink/genetlink.c:534:68: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 enum netlink_validation validate = ops->validate & no_strict_flag ?
                                                                   ^
net/netlink/policy.c:152:28: style: Local variable 'policy' shadows outer argument [shadowArgument]
  const struct nla_policy *policy;
                           ^
net/netlink/policy.c:127:33: note: Shadowed declaration
       const struct nla_policy *policy,
                                ^
net/netlink/policy.c:152:28: note: Shadow variable
  const struct nla_policy *policy;
                           ^
net/netrom/af_netrom.c:214:16: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned char i, j;
               ^
net/netrom/af_netrom.c:214:19: style: The scope of the variable 'j' can be reduced. [variableScope]
 unsigned char i, j;
                  ^
net/netrom/af_netrom.c:566:16: style: The scope of the variable 'source' can be reduced. [variableScope]
 ax25_address *source;
               ^
net/netrom/af_netrom.c:869:43: style: The scope of the variable 'timeout' can be reduced. [variableScope]
 unsigned short frametype, flags, window, timeout;
                                          ^
net/netrom/af_netrom.c:870:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/netrom/af_netrom.c:1277:14: style: The scope of the variable 'devname' can be reduced. [variableScope]
 const char *devname;
             ^
net/netrom/af_netrom.c:1278:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11];
      ^
net/netrom/nr_dev.c:101:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/netrom/nr_in.c:44:6: style: Condition '!more' is always true [knownConditionTrueFalse]
 if (!more && nr->fraglen > 0) { /* End of fragment */
     ^
net/netrom/nr_in.c:38:6: note: Assuming that condition 'more' is not redundant
 if (more) {
     ^
net/netrom/nr_in.c:44:6: note: Condition '!more' is always true
 if (!more && nr->fraglen > 0) { /* End of fragment */
     ^
net/netrom/nr_in.c:31:18: style: The scope of the variable 'skbo' can be reduced. [variableScope]
 struct sk_buff *skbo, *skbn = skb;
                 ^
net/netrom/nr_loopback.c:51:16: style: The scope of the variable 'nr_dest' can be reduced. [variableScope]
 ax25_address *nr_dest;
               ^
net/netrom/nr_loopback.c:52:21: style: The scope of the variable 'dev' can be reduced. [variableScope]
 struct net_device *dev;
                    ^
net/netrom/nr_out.c:34:18: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skbn;
                 ^
net/netrom/nr_out.c:35:16: style: The scope of the variable 'transport' can be reduced. [variableScope]
 unsigned char transport[NR_TRANSPORT_LEN];
               ^
net/netrom/nr_out.c:36:11: style: The scope of the variable 'frontlen' can be reduced. [variableScope]
 int err, frontlen, len;
          ^
net/netrom/nr_out.c:36:21: style: The scope of the variable 'len' can be reduced. [variableScope]
 int err, frontlen, len;
                    ^
net/netrom/nr_out.c:125:24: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skb, *skbn;
                       ^
net/netrom/nr_route.c:578:14: style: Condition 'first==NULL' is always true [knownConditionTrueFalse]
   if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
             ^
net/netrom/nr_route.c:573:35: note: Assignment 'first=NULL', assigned value is 0
 struct net_device *dev, *first = NULL;
                                  ^
net/netrom/nr_route.c:578:14: note: Condition 'first==NULL' is always true
   if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
             ^
net/netrom/nr_route.c:972:9: warning:inconclusive: Possible null pointer dereference: s [nullPointer]
  while(s->count) {
        ^
net/netrom/nr_route.c:960:23: note: Assignment 's=NULL', assigned value is 0
 struct nr_neigh *s = NULL;
                      ^
net/netrom/nr_route.c:972:9: note: Null pointer dereference
  while(s->count) {
        ^
net/netrom/nr_route.c:861:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11];
      ^
net/netrom/nr_route.c:862:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/netrom/nr_route.c:918:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11];
      ^
net/netrom/nr_route.c:919:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/netrom/nr_subr.c:49:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/core.c:821:21: style: The scope of the variable 'tg' can be reduced. [variableScope]
 struct nfc_target *tg;
                    ^
net/nfc/core.c:902:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/nfc/core.c:279:46: style:inconclusive: Function 'nfc_dep_link_up' argument 2 names different: declaration 'target_idx' definition 'target_index'. [funcArgNamesDifferent]
int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)
                                             ^
net/nfc/nfc.h:136:46: note: Function 'nfc_dep_link_up' argument 2 names different: declaration 'target_idx' definition 'target_index'.
int nfc_dep_link_up(struct nfc_dev *dev, int target_idx, u8 comm_mode);
                                             ^
net/nfc/core.c:279:46: note: Function 'nfc_dep_link_up' argument 2 names different: declaration 'target_idx' definition 'target_index'.
int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)
                                             ^
net/nfc/digital_dep.c:1459:5: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 rc = digital_tg_send_psl_res(ddev, psl_req->did, rf_tech);
    ^
net/nfc/hci/core.c:452:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/nfc/hci/core.c:862:6: style: The scope of the variable 'msg_len' can be reduced. [variableScope]
 int msg_len;
     ^
net/nfc/hci/llc.c:23:6: style: Condition 'r' is always false [knownConditionTrueFalse]
 if (r)
     ^
net/nfc/hci/llc.c:22:28: note: Assignment 'r=nfc_llc_shdlc_register()', assigned value is 0
 r = nfc_llc_shdlc_register();
                           ^
net/nfc/hci/llc.c:23:6: note: Condition 'r' is always false
 if (r)
     ^
net/nfc/hci/llc_shdlc.c:288:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/hci/llc_shdlc.c:314:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/hci/llc_shdlc.c:399:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/nfc/hci/llc_shdlc.c:520:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/hci/llc_shdlc.c:521:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/nfc/hci/llc_shdlc.c:522:16: style: The scope of the variable 'time_sent' can be reduced. [variableScope]
 unsigned long time_sent;
               ^
net/nfc/llcp_commands.c:646:18: style: The scope of the variable 'pdu' can be reduced. [variableScope]
 struct sk_buff *pdu;
                 ^
net/nfc/llcp_commands.c:649:9: style: The scope of the variable 'frag_len' can be reduced. [variableScope]
 size_t frag_len = 0, remaining_len;
        ^
net/nfc/llcp_commands.c:729:18: style: The scope of the variable 'pdu' can be reduced. [variableScope]
 struct sk_buff *pdu;
                 ^
net/nfc/llcp_commands.c:731:9: style: The scope of the variable 'frag_len' can be reduced. [variableScope]
 size_t frag_len = 0, remaining_len;
        ^
net/nfc/llcp_commands.c:649:18: style: Variable 'frag_len' is assigned a value that is never used. [unreadVariable]
 size_t frag_len = 0, remaining_len;
                 ^
net/nfc/llcp_commands.c:731:18: style: Variable 'frag_len' is assigned a value that is never used. [unreadVariable]
 size_t frag_len = 0, remaining_len;
                 ^
net/nfc/llcp_core.c:687:16: style: Condition 'skb_copy==NULL' is always true [knownConditionTrueFalse]
  if (skb_copy == NULL) {
               ^
net/nfc/llcp_core.c:677:29: note: Assignment 'skb_copy=NULL', assigned value is 0
 struct sk_buff *skb_copy = NULL, *nskb;
                            ^
net/nfc/llcp_core.c:684:20: note: Assuming condition is false
  if (sk->sk_state != LLCP_BOUND)
                   ^
net/nfc/llcp_core.c:687:16: note: Condition 'skb_copy==NULL' is always true
  if (skb_copy == NULL) {
               ^
net/nfc/llcp_core.c:89:17: style: The scope of the variable 'accept_sk' can be reduced. [variableScope]
   struct sock *accept_sk;
                ^
net/nfc/llcp_core.c:23:64: style:inconclusive: Function 'nfc_llcp_sock_link' argument 2 names different: declaration 's' definition 'sk'. [funcArgNamesDifferent]
void nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)
                                                               ^
net/nfc/llcp.h:201:64: note: Function 'nfc_llcp_sock_link' argument 2 names different: declaration 's' definition 'sk'.
void nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *s);
                                                               ^
net/nfc/llcp_core.c:23:64: note: Function 'nfc_llcp_sock_link' argument 2 names different: declaration 's' definition 'sk'.
void nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)
                                                               ^
net/nfc/llcp_core.c:30:66: style:inconclusive: Function 'nfc_llcp_sock_unlink' argument 2 names different: declaration 's' definition 'sk'. [funcArgNamesDifferent]
void nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)
                                                                 ^
net/nfc/llcp.h:202:66: note: Function 'nfc_llcp_sock_unlink' argument 2 names different: declaration 's' definition 'sk'.
void nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *s);
                                                                 ^
net/nfc/llcp_core.c:30:66: note: Function 'nfc_llcp_sock_unlink' argument 2 names different: declaration 's' definition 'sk'.
void nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)
                                                                 ^
net/nfc/llcp_core.c:1568:46: style:inconclusive: Function 'nfc_llcp_register_device' argument 1 names different: declaration 'dev' definition 'ndev'. [funcArgNamesDifferent]
int nfc_llcp_register_device(struct nfc_dev *ndev)
                                             ^
net/nfc/nfc.h:49:46: note: Function 'nfc_llcp_register_device' argument 1 names different: declaration 'dev' definition 'ndev'.
int nfc_llcp_register_device(struct nfc_dev *dev);
                                             ^
net/nfc/llcp_core.c:1568:46: note: Function 'nfc_llcp_register_device' argument 1 names different: declaration 'dev' definition 'ndev'.
int nfc_llcp_register_device(struct nfc_dev *ndev)
                                             ^
net/nfc/llcp_core.c:527:9: style: Local variable 'wks' shadows outer variable [shadowVariable]
 __be16 wks = cpu_to_be16(local->local_wks);
        ^
net/nfc/llcp_core.c:296:14: note: Shadowed declaration
static char *wks[] = {
             ^
net/nfc/llcp_core.c:527:9: note: Shadow variable
 __be16 wks = cpu_to_be16(local->local_wks);
        ^
net/nfc/llcp_core.c:926:6: style: Local variable 'ssap' shadows outer variable [shadowVariable]
  u8 ssap = nfc_llcp_reserve_sdp_ssap(local);
     ^
net/nfc/llcp_core.c:882:11: note: Shadowed declaration
 u8 dsap, ssap, reason;
          ^
net/nfc/llcp_core.c:926:6: note: Shadow variable
  u8 ssap = nfc_llcp_reserve_sdp_ssap(local);
     ^
net/nfc/llcp_sock.c:401:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/nfc/llcp_sock.c:529:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/nfc/llcp_sock.c:609:16: style: The scope of the variable 'accept_sk' can be reduced. [variableScope]
  struct sock *accept_sk;
               ^
net/nfc/llcp_sock.c:397:51: style:inconclusive: Function 'nfc_llcp_accept_dequeue' argument 1 names different: declaration 'sk' definition 'parent'. [funcArgNamesDifferent]
struct sock *nfc_llcp_accept_dequeue(struct sock *parent,
                                                  ^
net/nfc/llcp.h:220:51: note: Function 'nfc_llcp_accept_dequeue' argument 1 names different: declaration 'sk' definition 'parent'.
struct sock *nfc_llcp_accept_dequeue(struct sock *sk, struct socket *newsock);
                                                  ^
net/nfc/llcp_sock.c:397:51: note: Function 'nfc_llcp_accept_dequeue' argument 1 names different: declaration 'sk' definition 'parent'.
struct sock *nfc_llcp_accept_dequeue(struct sock *parent,
                                                  ^
net/nfc/nci/core.c:965:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/nfc/nci/core.c:1054:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/nfc/nci/core.c:1355:25: style: The scope of the variable 'op' can be reduced. [variableScope]
 struct nci_driver_ops *op;
                        ^
net/nfc/nci/core.c:1429:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/nci/core.c:1511:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/nfc/nci/hci.c:170:8: style: Variable 'len' is reassigned a value before the old one has been used. [redundantAssignment]
   len = data_len - i;
       ^
net/nfc/nci/hci.c:164:7: note: len is assigned
  len = conn_info->max_pkt_payload_len;
      ^
net/nfc/nci/hci.c:170:8: note: len is overwritten
   len = data_len - i;
       ^
net/nfc/nci/hci.c:147:6: style: The scope of the variable 'len' can be reduced. [variableScope]
 int len, i, r;
     ^
net/nfc/nci/hci.c:147:14: style: The scope of the variable 'r' can be reduced. [variableScope]
 int len, i, r;
             ^
net/nfc/nci/hci.c:226:26: style: The scope of the variable 'message' can be reduced. [variableScope]
 struct nci_hcp_message *message;
                         ^
net/nfc/nci/hci.c:438:6: style: The scope of the variable 'msg_len' can be reduced. [variableScope]
 int msg_len;
     ^
net/nfc/nci/hci.c:565:26: style: The scope of the variable 'message' can be reduced. [variableScope]
 struct nci_hcp_message *message;
                         ^
net/nfc/nci/hci.c:613:26: style: The scope of the variable 'message' can be reduced. [variableScope]
 struct nci_hcp_message *message;
                         ^
net/nfc/nci/hci.c:707:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/nfc/nci/hci.c:369:12: style: Variable 'status' is assigned a value that is never used. [unreadVariable]
 u8 status = result;
           ^
net/nfc/netlink.c:737:5: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
 rc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,
    ^
net/nfc/netlink.c:720:9: note: rc is initialized
 int rc = -ENOBUFS;
        ^
net/nfc/netlink.c:737:5: note: rc is overwritten
 rc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,
    ^
net/nfc/netlink.c:130:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/nfc/rawsock.c:367:7: style: Condition '!skb_copy' is always true [knownConditionTrueFalse]
  if (!skb_copy) {
      ^
net/nfc/rawsock.c:360:29: note: Assignment 'skb_copy=NULL', assigned value is 0
 struct sk_buff *skb_copy = NULL, *nskb;
                            ^
net/nfc/rawsock.c:367:7: note: Condition '!skb_copy' is always true
  if (!skb_copy) {
      ^
net/openvswitch/actions.c:528:8: style: The scope of the variable 'recalc_csum' can be reduced. [variableScope]
  bool recalc_csum = true;
       ^
net/openvswitch/actions.c:1248:20: style: Local variable 'clone' shadows outer function [shadowFunction]
   struct sk_buff *clone;
                   ^
net/openvswitch/actions.c:1008:12: note: Shadowed declaration
static int clone(struct datapath *dp, struct sk_buff *skb,
           ^
net/openvswitch/actions.c:1248:20: note: Shadow variable
   struct sk_buff *clone;
                   ^
net/openvswitch/actions.c:1451:22: style: Local variable 'clone' shadows outer function [shadowFunction]
 struct sw_flow_key *clone;
                     ^
net/openvswitch/actions.c:1008:12: note: Shadowed declaration
static int clone(struct datapath *dp, struct sk_buff *skb,
           ^
net/openvswitch/actions.c:1451:22: note: Shadow variable
 struct sw_flow_key *clone;
                     ^
net/openvswitch/conntrack.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
net/openvswitch/datapath.c:789:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/openvswitch/flow.c:770:17: style: The scope of the variable 'eth' can be reduced. [variableScope]
 struct ethhdr *eth;
                ^
net/openvswitch/flow_netlink.c:1184:3: warning: Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]
  SW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);
  ^
net/openvswitch/flow_netlink.c:1183:13: note: outer condition: !is_mask
 } else if (!is_mask) {
            ^
net/openvswitch/flow_netlink.c:1184:3: note: opposite inner condition: is_mask
  SW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);
  ^
net/openvswitch/flow_netlink.c:1531:4: warning: Opposite inner 'if' condition leads to a dead code block. [oppositeInnerCondition]
   SW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);
   ^
net/openvswitch/flow_netlink.c:1530:14: note: outer condition: !is_mask
  } else if (!is_mask) {
             ^
net/openvswitch/flow_netlink.c:1531:4: note: opposite inner condition: is_mask
   SW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);
   ^
net/openvswitch/flow_netlink.c:1393:7: style: The scope of the variable 'i' can be reduced. [variableScope]
  int i;
      ^
net/openvswitch/flow_netlink.c:3547:17: style: The scope of the variable 'start' can be reduced. [variableScope]
 struct nlattr *start;
                ^
net/openvswitch/flow_netlink.c:3548:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/openvswitch/flow_netlink.c:1776:30: style:inconclusive: Function 'ovs_nla_get_match' argument 3 names different: declaration 'key' definition 'nla_key'. [funcArgNamesDifferent]
        const struct nlattr *nla_key,
                             ^
net/openvswitch/flow_netlink.h:46:30: note: Function 'ovs_nla_get_match' argument 3 names different: declaration 'key' definition 'nla_key'.
        const struct nlattr *key, const struct nlattr *mask,
                             ^
net/openvswitch/flow_netlink.c:1776:30: note: Function 'ovs_nla_get_match' argument 3 names different: declaration 'key' definition 'nla_key'.
        const struct nlattr *nla_key,
                             ^
net/openvswitch/flow_netlink.c:1777:30: style:inconclusive: Function 'ovs_nla_get_match' argument 4 names different: declaration 'mask' definition 'nla_mask'. [funcArgNamesDifferent]
        const struct nlattr *nla_mask,
                             ^
net/openvswitch/flow_netlink.h:46:56: note: Function 'ovs_nla_get_match' argument 4 names different: declaration 'mask' definition 'nla_mask'.
        const struct nlattr *key, const struct nlattr *mask,
                                                       ^
net/openvswitch/flow_netlink.c:1777:30: note: Function 'ovs_nla_get_match' argument 4 names different: declaration 'mask' definition 'nla_mask'.
        const struct nlattr *nla_mask,
                             ^
net/openvswitch/flow_table.c:276:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err, ma_count = READ_ONCE(ma->count);
     ^
net/openvswitch/flow_table.c:531:21: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct hlist_head *head;
                    ^
net/openvswitch/flow_table.c:533:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/openvswitch/flow_table.c:527:63: style:inconclusive: Function 'ovs_flow_tbl_dump_next' argument 1 names different: declaration 'table' definition 'ti'. [funcArgNamesDifferent]
struct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *ti,
                                                              ^
net/openvswitch/flow_table.h:91:63: note: Function 'ovs_flow_tbl_dump_next' argument 1 names different: declaration 'table' definition 'ti'.
struct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *table,
                                                              ^
net/openvswitch/flow_table.c:527:63: note: Function 'ovs_flow_tbl_dump_next' argument 1 names different: declaration 'table' definition 'ti'.
struct sw_flow *ovs_flow_tbl_dump_next(struct table_instance *ti,
                                                              ^
net/openvswitch/flow_table.c:528:30: style:inconclusive: Function 'ovs_flow_tbl_dump_next' argument 3 names different: declaration 'idx' definition 'last'. [funcArgNamesDifferent]
           u32 *bucket, u32 *last)
                             ^
net/openvswitch/flow_table.h:92:30: note: Function 'ovs_flow_tbl_dump_next' argument 3 names different: declaration 'idx' definition 'last'.
           u32 *bucket, u32 *idx);
                             ^
net/openvswitch/flow_table.c:528:30: note: Function 'ovs_flow_tbl_dump_next' argument 3 names different: declaration 'idx' definition 'last'.
           u32 *bucket, u32 *last)
                             ^
net/openvswitch/vport.c:338:76: style:inconclusive: Function 'ovs_vport_set_upcall_portids' argument 2 names different: declaration 'pids' definition 'ids'. [funcArgNamesDifferent]
int ovs_vport_set_upcall_portids(struct vport *vport, const struct nlattr *ids)
                                                                           ^
net/openvswitch/vport.h:38:71: note: Function 'ovs_vport_set_upcall_portids' argument 2 names different: declaration 'pids' definition 'ids'.
int ovs_vport_set_upcall_portids(struct vport *, const struct nlattr *pids);
                                                                      ^
net/openvswitch/vport.c:338:76: note: Function 'ovs_vport_set_upcall_portids' argument 2 names different: declaration 'pids' definition 'ids'.
int ovs_vport_set_upcall_portids(struct vport *vport, const struct nlattr *ids)
                                                                           ^
net/packet/af_packet.c:562:6: style: The if condition is the same as the previous if condition [duplicateCondition]
 if (div)
     ^
net/packet/af_packet.c:559:6: note: First condition
 if (div)
     ^
net/packet/af_packet.c:562:6: note: Second condition
 if (div)
     ^
net/packet/af_packet.c:1359:27: style: The scope of the variable 'po_next' can be reduced. [variableScope]
 struct packet_sock *po, *po_next, *po_skip = NULL;
                          ^
net/packet/af_packet.c:2505:29: style: The scope of the variable 'nr_frags' can be reduced. [variableScope]
 int to_write, offset, len, nr_frags, len_max;
                            ^
net/packet/af_packet.c:2507:15: style: The scope of the variable 'page' can be reduced. [variableScope]
 struct page *page;
              ^
net/packet/af_packet.c:2311:41: portability: 'h.raw' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     virtio_net_hdr_from_skb(skb, h.raw + macoff -
                                        ^
net/packet/af_packet.c:2311:50: portability: 'h.raw+macoff' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
     virtio_net_hdr_from_skb(skb, h.raw + macoff -
                                                 ^
net/packet/af_packet.c:2338:30: portability: 'h.raw' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 skb_copy_bits(skb, 0, h.raw + macoff, snaplen);
                             ^
net/packet/af_packet.c:2391:14: portability: 'h.raw' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sll = h.raw + TPACKET_ALIGN(hdrlen);
             ^
net/packet/af_packet.c:2541:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += hdrlen;
       ^
net/packet/af_packet.c:2564:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += len;
       ^
net/packet/af_packet.c:2643:16: portability: 'frame' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 *data = frame + off;
               ^
net/packet/af_packet.c:2746:9: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   data += sizeof(*vnet_hdr);
        ^
net/packet/af_packet.c:4506:11: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    kaddr += PAGE_SIZE;
          ^
net/packet/af_packet.c:3924:8: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
   ret = -EBUSY;
       ^
net/packet/af_packet.c:3927:8: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
   ret = 0;
       ^
net/phonet/af_phonet.c:252:16: style: Local variable 'sk' shadows outer argument [shadowArgument]
  struct sock *sk = pn_find_sock_by_res(net, res);
               ^
net/phonet/af_phonet.c:224:30: note: Shadowed declaration
int pn_skb_send(struct sock *sk, struct sk_buff *skb,
                             ^
net/phonet/af_phonet.c:252:16: note: Shadow variable
  struct sock *sk = pn_find_sock_by_res(net, res);
               ^
net/qrtr/ns.c:193:22: style: The scope of the variable 'srv' can be reduced. [variableScope]
 struct qrtr_server *srv;
                     ^
net/qrtr/ns.c:663:30: style: The scope of the variable 'pkt' can be reduced. [variableScope]
 const struct qrtr_ctrl_pkt *pkt;
                             ^
net/qrtr/ns.c:667:15: style: The scope of the variable 'cmd' can be reduced. [variableScope]
 unsigned int cmd;
              ^
net/qrtr/ns.c:668:10: style: The scope of the variable 'msglen' can be reduced. [variableScope]
 ssize_t msglen;
         ^
net/qrtr/ns.c:671:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/qrtr/qrtr.c:169:23: style: The scope of the variable 'flow' can be reduced. [variableScope]
 struct qrtr_tx_flow *flow;
                      ^
net/qrtr/qrtr.c:877:18: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skbn;
                 ^
net/qrtr/qrtr.c:499:25: portability: 'data' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 skb_put_data(skb, data + hdrlen, size);
                        ^
net/qrtr/qrtr.c:505:42: portability: 'data' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  const struct qrtr_ctrl_pkt *pkt = data + hdrlen;
                                         ^
net/rds/connection.c:305:26: style: The scope of the variable 'cp' can be reduced. [variableScope]
   struct rds_conn_path *cp;
                         ^
net/rds/connection.c:355:46: style:inconclusive: Function 'rds_conn_shutdown' argument 1 names different: declaration 'cpath' definition 'cp'. [funcArgNamesDifferent]
void rds_conn_shutdown(struct rds_conn_path *cp)
                                             ^
net/rds/rds.h:775:46: note: Function 'rds_conn_shutdown' argument 1 names different: declaration 'cpath' definition 'cp'.
void rds_conn_shutdown(struct rds_conn_path *cpath);
                                             ^
net/rds/connection.c:355:46: note: Function 'rds_conn_shutdown' argument 1 names different: declaration 'cpath' definition 'cp'.
void rds_conn_shutdown(struct rds_conn_path *cp)
                                             ^
net/rds/connection.c:869:47: style:inconclusive: Function 'rds_conn_path_drop' argument 1 names different: declaration 'cpath' definition 'cp'. [funcArgNamesDifferent]
void rds_conn_path_drop(struct rds_conn_path *cp, bool destroy)
                                              ^
net/rds/rds.h:778:47: note: Function 'rds_conn_path_drop' argument 1 names different: declaration 'cpath' definition 'cp'.
void rds_conn_path_drop(struct rds_conn_path *cpath, bool destroy);
                                              ^
net/rds/connection.c:869:47: note: Function 'rds_conn_path_drop' argument 1 names different: declaration 'cpath' definition 'cp'.
void rds_conn_path_drop(struct rds_conn_path *cp, bool destroy)
                                              ^
net/rds/connection.c:306:8: style: Local variable 'i' shadows outer variable [shadowVariable]
   int i;
       ^
net/rds/connection.c:172:11: note: Shadowed declaration
 int ret, i;
          ^
net/rds/connection.c:306:8: note: Shadow variable
   int i;
       ^
net/rds/ib_cm.c:1083:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0;
         ^
net/rds/ib_frmr.c:369:16: style: Condition '!ret' is always true [knownConditionTrueFalse]
   if (ret2 && !ret)
               ^
net/rds/ib_frmr.c:362:12: note: Assignment 'ret=0', assigned value is 0
 int ret = 0, ret2;
           ^
net/rds/ib_frmr.c:369:16: note: Condition '!ret' is always true
   if (ret2 && !ret)
               ^
net/rds/ib_frmr.c:361:22: style: The scope of the variable 'frmr' can be reduced. [variableScope]
 struct rds_ib_frmr *frmr;
                     ^
net/rds/ib_frmr.c:59:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0;
         ^
net/rds/ib_rdma.c:614:7: warning: Either the condition 'if(rds_ibdev)' is redundant or there is possible null pointer dereference: rds_ibdev. [nullPointerRedundantCheck]
 if (!rds_ibdev->mr_8k_pool || !rds_ibdev->mr_1m_pool) {
      ^
net/rds/ib_rdma.c:628:5: note: Assuming that condition 'if(rds_ibdev)' is not redundant
 if (rds_ibdev)
    ^
net/rds/ib_rdma.c:614:7: note: Null pointer dereference
 if (!rds_ibdev->mr_8k_pool || !rds_ibdev->mr_1m_pool) {
      ^
net/rds/ib_rdma.c:412:17: style: The scope of the variable 'flags' can be reduced. [variableScope]
  unsigned long flags;
                ^
net/rds/ib_rdma.c:218:46: style:inconclusive: Function 'rds_ib_sync_mr' argument 2 names different: declaration 'dir' definition 'direction'. [funcArgNamesDifferent]
void rds_ib_sync_mr(void *trans_private, int direction)
                                             ^
net/rds/ib_mr.h:124:46: note: Function 'rds_ib_sync_mr' argument 2 names different: declaration 'dir' definition 'direction'.
void rds_ib_sync_mr(void *trans_private, int dir);
                                             ^
net/rds/ib_rdma.c:218:46: note: Function 'rds_ib_sync_mr' argument 2 names different: declaration 'dir' definition 'direction'.
void rds_ib_sync_mr(void *trans_private, int direction)
                                             ^
net/rds/ib_rdma.c:643:68: style:inconclusive: Function 'rds_ib_create_mr_pool' argument 1 names different: declaration 'rds_dev' definition 'rds_ibdev'. [funcArgNamesDifferent]
struct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_ibdev,
                                                                   ^
net/rds/ib_mr.h:113:68: note: Function 'rds_ib_create_mr_pool' argument 1 names different: declaration 'rds_dev' definition 'rds_ibdev'.
struct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_dev,
                                                                   ^
net/rds/ib_rdma.c:643:68: note: Function 'rds_ib_create_mr_pool' argument 1 names different: declaration 'rds_dev' definition 'rds_ibdev'.
struct rds_ib_mr_pool *rds_ib_create_mr_pool(struct rds_ib_device *rds_ibdev,
                                                                   ^
net/rds/ib_rdma.c:644:15: style:inconclusive: Function 'rds_ib_create_mr_pool' argument 2 names different: declaration 'npages' definition 'pool_type'. [funcArgNamesDifferent]
          int pool_type)
              ^
net/rds/ib_mr.h:114:15: note: Function 'rds_ib_create_mr_pool' argument 2 names different: declaration 'npages' definition 'pool_type'.
          int npages);
              ^
net/rds/ib_rdma.c:644:15: note: Function 'rds_ib_create_mr_pool' argument 2 names different: declaration 'npages' definition 'pool_type'.
          int pool_type)
              ^
net/rds/ib_recv.c:103:28: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct rds_ib_cache_head *head;
                           ^
net/rds/ib_recv.c:138:28: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct rds_ib_cache_head *head;
                           ^
net/rds/ib_recv.c:250:6: style: The scope of the variable 'avail_allocs' can be reduced. [variableScope]
 int avail_allocs;
     ^
net/rds/ib_recv.c:280:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rds/ib_recv.c:536:16: style: The scope of the variable 'to_copy' can be reduced. [variableScope]
 unsigned long to_copy;
               ^
net/rds/ib_recv.c:539:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rds/ib_recv.c:790:16: style: The scope of the variable 'to_copy' can be reduced. [variableScope]
 unsigned long to_copy;
               ^
net/rds/ib_recv.c:1040:44: style:inconclusive: Function 'rds_ib_recv_path' argument 1 names different: declaration 'conn' definition 'cp'. [funcArgNamesDifferent]
int rds_ib_recv_path(struct rds_conn_path *cp)
                                           ^
net/rds/ib.h:397:44: note: Function 'rds_ib_recv_path' argument 1 names different: declaration 'conn' definition 'cp'.
int rds_ib_recv_path(struct rds_conn_path *conn);
                                           ^
net/rds/ib_recv.c:1040:44: note: Function 'rds_ib_recv_path' argument 1 names different: declaration 'conn' definition 'cp'.
int rds_ib_recv_path(struct rds_conn_path *cp)
                                           ^
net/rds/ib_recv.c:817:14: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  src = addr + frag->f_sg.offset + frag_off;
             ^
net/rds/ib_recv.c:818:45: portability: '(void*)map->m_page_addrs[map_page]' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  dst = (void *)map->m_page_addrs[map_page] + map_off;
                                            ^
net/rds/ib_send.c:247:27: style: The scope of the variable 'send' can be reduced. [variableScope]
 struct rds_ib_send_work *send;
                          ^
net/rds/ib_send.c:626:16: style: The scope of the variable 'len' can be reduced. [variableScope]
  unsigned int len = 0;
               ^
net/rds/ib_send.c:297:9: style: Variable 'nr_sig' is assigned a value that is never used. [unreadVariable]
 nr_sig = 0;
        ^
net/rds/info.c:118:16: style: The scope of the variable 'this' can be reduced. [variableScope]
 unsigned long this;
               ^
net/rds/info.c:130:21: portability: 'iter->addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memcpy(iter->addr + iter->offset, data, this);
                    ^
net/rds/info.c:132:8: portability: 'data' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  data += this;
       ^
net/rds/message.c:424:16: style: The scope of the variable 'to_copy' can be reduced. [variableScope]
 unsigned long to_copy, nbytes;
               ^
net/rds/message.c:424:25: style: The scope of the variable 'nbytes' can be reduced. [variableScope]
 unsigned long to_copy, nbytes;
                        ^
net/rds/message.c:470:16: style: The scope of the variable 'to_copy' can be reduced. [variableScope]
 unsigned long to_copy;
               ^
net/rds/message.c:473:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rds/message.c:75:61: style:inconclusive: Function 'rds_notify_msg_zcopy_purge' argument 1 names different: declaration 'info' definition 'q'. [funcArgNamesDifferent]
void rds_notify_msg_zcopy_purge(struct rds_msg_zcopy_queue *q)
                                                            ^
net/rds/rds.h:871:61: note: Function 'rds_notify_msg_zcopy_purge' argument 1 names different: declaration 'info' definition 'q'.
void rds_notify_msg_zcopy_purge(struct rds_msg_zcopy_queue *info);
                                                            ^
net/rds/message.c:75:61: note: Function 'rds_notify_msg_zcopy_purge' argument 1 names different: declaration 'info' definition 'q'.
void rds_notify_msg_zcopy_purge(struct rds_msg_zcopy_queue *q)
                                                            ^
net/rds/message.c:284:52: style:inconclusive: Function 'rds_message_alloc' argument 1 names different: declaration 'nents' definition 'extra_len'. [funcArgNamesDifferent]
struct rds_message *rds_message_alloc(unsigned int extra_len, gfp_t gfp)
                                                   ^
net/rds/rds.h:853:52: note: Function 'rds_message_alloc' argument 1 names different: declaration 'nents' definition 'extra_len'.
struct rds_message *rds_message_alloc(unsigned int nents, gfp_t gfp);
                                                   ^
net/rds/message.c:284:52: note: Function 'rds_message_alloc' argument 1 names different: declaration 'nents' definition 'extra_len'.
struct rds_message *rds_message_alloc(unsigned int extra_len, gfp_t gfp)
                                                   ^
net/rds/rdma.c:70:17: style: The scope of the variable 'mr' can be reduced. [variableScope]
 struct rds_mr *mr;
                ^
net/rds/rdma.c:489:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/rds/rdma.c:532:15: style: The scope of the variable 'nr_pages' can be reduced. [variableScope]
 unsigned int nr_pages;
              ^
net/rds/rdma.c:560:15: style: The scope of the variable 'nr_pages' can be reduced. [variableScope]
 unsigned int nr_pages;
              ^
net/rds/rdma_transport.c:123:8: style: Condition 'err' is always true [knownConditionTrueFalse]
      (err && len >= sizeof(*err) &&
       ^
net/rds/rdma_transport.c:122:7: note: Assuming that condition '!err' is not redundant
  if (!err ||
      ^
net/rds/rdma_transport.c:123:8: note: Condition 'err' is always true
      (err && len >= sizeof(*err) &&
       ^
net/rds/recv.c:135:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/rds/recv.c:136:27: style: The scope of the variable 'tmp' can be reduced. [variableScope]
 struct rds_message *rm, *tmp;
                          ^
net/rds/recv.c:137:16: style: The scope of the variable 'flags' can be reduced. [variableScope]
 unsigned long flags;
               ^
net/rds/recv.c:168:24: style: The scope of the variable 'type' can be reduced. [variableScope]
 unsigned int pos = 0, type, len;
                       ^
net/rds/recv.c:201:24: style: The scope of the variable 'type' can be reduced. [variableScope]
 unsigned int pos = 0, type, len;
                       ^
net/rds/recv.c:254:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/rds/recv.c:255:24: style: The scope of the variable 'cp' can be reduced. [variableScope]
 struct rds_conn_path *cp;
                       ^
net/rds/recv.c:405:16: style: The scope of the variable 'flags' can be reduced. [variableScope]
 unsigned long flags;
               ^
net/rds/recv.c:57:72: style:inconclusive: Function 'rds_inc_path_init' argument 2 names different: declaration 'conn' definition 'cp'. [funcArgNamesDifferent]
void rds_inc_path_init(struct rds_incoming *inc, struct rds_conn_path *cp,
                                                                       ^
net/rds/rds.h:893:72: note: Function 'rds_inc_path_init' argument 2 names different: declaration 'conn' definition 'cp'.
void rds_inc_path_init(struct rds_incoming *inc, struct rds_conn_path *conn,
                                                                       ^
net/rds/recv.c:57:72: note: Function 'rds_inc_path_init' argument 2 names different: declaration 'conn' definition 'cp'.
void rds_inc_path_init(struct rds_incoming *inc, struct rds_conn_path *cp,
                                                                       ^
net/rds/recv.c:450:62: style:inconclusive: Function 'rds_notify_queue_get' argument 2 names different: declaration 'msg' definition 'msghdr'. [funcArgNamesDifferent]
int rds_notify_queue_get(struct rds_sock *rs, struct msghdr *msghdr)
                                                             ^
net/rds/rds.h:902:62: note: Function 'rds_notify_queue_get' argument 2 names different: declaration 'msg' definition 'msghdr'.
int rds_notify_queue_get(struct rds_sock *rs, struct msghdr *msg);
                                                             ^
net/rds/recv.c:450:62: note: Function 'rds_notify_queue_get' argument 2 names different: declaration 'msg' definition 'msghdr'.
int rds_notify_queue_get(struct rds_sock *rs, struct msghdr *msghdr)
                                                             ^
net/rds/send.c:310:7: warning: Either the condition '!rm' is redundant or there is possible null pointer dereference: rm. [nullPointerRedundantCheck]
  if (rm->rdma.op_active && !cp->cp_xmit_rdma_sent) {
      ^
net/rds/send.c:239:7: note: Assuming that condition '!rm' is not redundant
  if (!rm) {
      ^
net/rds/send.c:310:7: note: Null pointer dereference
  if (rm->rdma.op_active && !cp->cp_xmit_rdma_sent) {
      ^
net/rds/send.c:65:48: style:inconclusive: Function 'rds_send_path_reset' argument 1 names different: declaration 'conn' definition 'cp'. [funcArgNamesDifferent]
void rds_send_path_reset(struct rds_conn_path *cp)
                                               ^
net/rds/rds.h:913:48: note: Function 'rds_send_path_reset' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_send_path_reset(struct rds_conn_path *conn);
                                               ^
net/rds/send.c:65:48: note: Function 'rds_send_path_reset' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_send_path_reset(struct rds_conn_path *cp)
                                               ^
net/rds/send.c:500:57: style:inconclusive: Function 'rds_rdma_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'. [funcArgNamesDifferent]
void rds_rdma_send_complete(struct rds_message *rm, int status)
                                                        ^
net/rds/rds.h:942:57: note: Function 'rds_rdma_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'.
void rds_rdma_send_complete(struct rds_message *rm, int wc_status);
                                                        ^
net/rds/send.c:500:57: note: Function 'rds_rdma_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'.
void rds_rdma_send_complete(struct rds_message *rm, int status)
                                                        ^
net/rds/send.c:536:59: style:inconclusive: Function 'rds_atomic_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'. [funcArgNamesDifferent]
void rds_atomic_send_complete(struct rds_message *rm, int status)
                                                          ^
net/rds/rds.h:943:59: note: Function 'rds_atomic_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'.
void rds_atomic_send_complete(struct rds_message *rm, int wc_status);
                                                          ^
net/rds/send.c:536:59: note: Function 'rds_atomic_send_complete' argument 2 names different: declaration 'wc_status' definition 'status'.
void rds_atomic_send_complete(struct rds_message *rm, int status)
                                                          ^
net/rds/tcp.c:531:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = 0;
         ^
net/rds/tcp_connect.c:200:55: style:inconclusive: Function 'rds_tcp_conn_path_shutdown' argument 1 names different: declaration 'conn' definition 'cp'. [funcArgNamesDifferent]
void rds_tcp_conn_path_shutdown(struct rds_conn_path *cp)
                                                      ^
net/rds/tcp.h:65:55: note: Function 'rds_tcp_conn_path_shutdown' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_tcp_conn_path_shutdown(struct rds_conn_path *conn);
                                                      ^
net/rds/tcp_connect.c:200:55: note: Function 'rds_tcp_conn_path_shutdown' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_tcp_conn_path_shutdown(struct rds_conn_path *cp)
                                                      ^
net/rds/tcp_listen.c:192:6: warning: Either the condition 'if(rs_tcp)' is redundant or there is possible null pointer dereference: rs_tcp. [nullPointerRedundantCheck]
 if (rs_tcp->t_sock) {
     ^
net/rds/tcp_listen.c:217:5: note: Assuming that condition 'if(rs_tcp)' is not redundant
 if (rs_tcp)
    ^
net/rds/tcp_listen.c:192:6: note: Null pointer dereference
 if (rs_tcp->t_sock) {
     ^
net/rds/tcp_listen.c:213:17: warning:inconclusive: Either the condition 'if(new_sock)' is redundant or there is possible null pointer dereference: new_sock. [nullPointerRedundantCheck]
 sock_no_linger(new_sock->sk);
                ^
net/rds/tcp_listen.c:219:5: note: Assuming that condition 'if(new_sock)' is not redundant
 if (new_sock)
    ^
net/rds/tcp_listen.c:213:17: note: Null pointer dereference
 sock_no_linger(new_sock->sk);
                ^
net/rds/tcp_recv.c:109:24: style: The scope of the variable 'skb_off' can be reduced. [variableScope]
 unsigned int to_copy, skb_off;
                       ^
net/rds/tcp_recv.c:133:41: portability: '(void*)map->m_page_addrs[map_page]' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    (void *)map->m_page_addrs[map_page] + map_off,
                                        ^
net/rds/tcp_send.c:105:36: portability: '(void*)&rm->m_inc.i_hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
          (void *)&rm->m_inc.i_hdr + hdr_off,
                                   ^
net/rds/threads.c:196:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rds/threads.c:222:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rds/threads.c:74:54: style:inconclusive: Function 'rds_connect_path_complete' argument 1 names different: declaration 'conn' definition 'cp'. [funcArgNamesDifferent]
void rds_connect_path_complete(struct rds_conn_path *cp, int curr)
                                                     ^
net/rds/rds.h:1002:54: note: Function 'rds_connect_path_complete' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_connect_path_complete(struct rds_conn_path *conn, int curr);
                                                     ^
net/rds/threads.c:74:54: note: Function 'rds_connect_path_complete' argument 1 names different: declaration 'conn' definition 'cp'.
void rds_connect_path_complete(struct rds_conn_path *cp, int curr)
                                                     ^
net/rds/threads.c:267:41: style:inconclusive: Function 'rds_addr_cmp' argument 1 names different: declaration 'a1' definition 'addr1'. [funcArgNamesDifferent]
int rds_addr_cmp(const struct in6_addr *addr1,
                                        ^
net/rds/rds.h:1004:41: note: Function 'rds_addr_cmp' argument 1 names different: declaration 'a1' definition 'addr1'.
int rds_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2);
                                        ^
net/rds/threads.c:267:41: note: Function 'rds_addr_cmp' argument 1 names different: declaration 'a1' definition 'addr1'.
int rds_addr_cmp(const struct in6_addr *addr1,
                                        ^
net/rds/threads.c:268:27: style:inconclusive: Function 'rds_addr_cmp' argument 2 names different: declaration 'a2' definition 'addr2'. [funcArgNamesDifferent]
   const struct in6_addr *addr2)
                          ^
net/rds/rds.h:1004:68: note: Function 'rds_addr_cmp' argument 2 names different: declaration 'a2' definition 'addr2'.
int rds_addr_cmp(const struct in6_addr *a1, const struct in6_addr *a2);
                                                                   ^
net/rds/threads.c:268:27: note: Function 'rds_addr_cmp' argument 2 names different: declaration 'a2' definition 'addr2'.
   const struct in6_addr *addr2)
                          ^
net/rfkill/core.c:1375:6: style: Condition 'error' is always false [knownConditionTrueFalse]
 if (error)
     ^
net/rfkill/core.c:1374:44: note: Assignment 'error=rfkill_global_led_trigger_register()', assigned value is 0
 error = rfkill_global_led_trigger_register();
                                           ^
net/rfkill/core.c:1375:6: note: Condition 'error' is always false
 if (error)
     ^
net/rfkill/core.c:111:12: style: struct member 'Anonymous0::sav' is never used. [unusedStructMember]
 bool cur, sav;
           ^
net/rfkill/core.c:902:7: style: The scope of the variable 'cur' can be reduced. [variableScope]
 bool cur;
      ^
net/rose/af_rose.c:128:18: style: The scope of the variable 'j' can be reduced. [variableScope]
 unsigned int i, j;
                 ^
net/rose/af_rose.c:662:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
net/rose/af_rose.c:1220:17: style: The scope of the variable 'asmptr' can be reduced. [variableScope]
 unsigned char *asmptr;
                ^
net/rose/af_rose.c:1222:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n, er, qbit;
     ^
net/rose/af_rose.c:1391:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11], rsbuf[11];
      ^
net/rose/af_rose.c:1391:16: style: The scope of the variable 'rsbuf' can be reduced. [variableScope]
 char buf[11], rsbuf[11];
               ^
net/rose/af_rose.c:1194:0: information: Skipping configuration 'M_BIT' since the value of 'M_BIT' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
    skbn->data[2] |= M_BIT;
^
net/rose/rose_dev.c:59:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/rose/rose_link.c:141:18: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skbn;
                 ^
net/rose/rose_out.c:48:24: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skb, *skbn;
                       ^
net/rose/rose_route.c:613:14: style: Condition 'first==NULL' is always true [knownConditionTrueFalse]
   if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
             ^
net/rose/rose_route.c:608:35: note: Assignment 'first=NULL', assigned value is 0
 struct net_device *dev, *first = NULL;
                                  ^
net/rose/rose_route.c:613:14: note: Condition 'first==NULL' is always true
   if (first == NULL || strncmp(dev->name, first->name, 3) < 0)
             ^
net/rose/rose_route.c:479:21: style: The scope of the variable 's' can be reduced. [variableScope]
 struct rose_neigh *s, *rose_neigh;
                    ^
net/rose/rose_route.c:554:21: style: The scope of the variable 's' can be reduced. [variableScope]
 struct rose_neigh *s, *rose_neigh;
                    ^
net/rose/rose_route.c:555:21: style: The scope of the variable 't' can be reduced. [variableScope]
 struct rose_node  *t, *rose_node;
                    ^
net/rose/rose_route.c:1303:21: style: The scope of the variable 's' can be reduced. [variableScope]
 struct rose_neigh *s, *rose_neigh = rose_neigh_list;
                    ^
net/rose/rose_route.c:1304:21: style: The scope of the variable 't' can be reduced. [variableScope]
 struct rose_node  *t, *rose_node  = rose_node_list;
                    ^
net/rose/rose_route.c:1305:21: style: The scope of the variable 'u' can be reduced. [variableScope]
 struct rose_route *u, *rose_route = rose_route_list;
                    ^
net/rose/rose_route.c:1120:7: style: The scope of the variable 'rsbuf' can be reduced. [variableScope]
 char rsbuf[11];
      ^
net/rose/rose_route.c:1121:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/rose/rose_route.c:1186:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11];
      ^
net/rose/rose_route.c:1187:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/rose/rose_route.c:1257:7: style: The scope of the variable 'buf' can be reduced. [variableScope]
 char buf[11], rsbuf[11];
      ^
net/rose/rose_route.c:1257:16: style: The scope of the variable 'rsbuf' can be reduced. [variableScope]
 char buf[11], rsbuf[11];
               ^
net/rose/rose_subr.c:45:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/rose/rose_subr.c:440:11: style: The scope of the variable 'nb' can be reduced. [variableScope]
 int len, nb;
          ^
net/rxrpc/af_rxrpc.c:1022:10: style: Condition 'ret<0' is always false [knownConditionTrueFalse]
 if (ret < 0) {
         ^
net/rxrpc/af_rxrpc.c:1021:25: note: Assignment 'ret=rxrpc_sysctl_init()', assigned value is 0
 ret = rxrpc_sysctl_init();
                        ^
net/rxrpc/af_rxrpc.c:1022:10: note: Condition 'ret<0' is always false
 if (ret < 0) {
         ^
net/rxrpc/af_rxrpc.c:235:7: style: Variable 'ret' is reassigned a value before the old one has been used. [redundantAssignment]
  ret = rxrpc_service_prealloc(rx, GFP_KERNEL);
      ^
net/rxrpc/af_rxrpc.c:228:7: note: ret is assigned
  ret = -EINVAL;
      ^
net/rxrpc/af_rxrpc.c:235:7: note: ret is overwritten
  ret = rxrpc_service_prealloc(rx, GFP_KERNEL);
      ^
net/rxrpc/af_rxrpc.c:121:22: portability: '(void*)srx' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memset((void *)srx + tail, 0, len - tail);
                     ^
net/rxrpc/af_rxrpc.c:756:0: information: Skipping configuration 'CONFIG_AF_RXRPC_IPV6' since the value of 'CONFIG_AF_RXRPC_IPV6' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
     IS_ENABLED(CONFIG_AF_RXRPC_IPV6) && protocol != PF_INET6)
^
net/rxrpc/conn_client.c:100:6: style: The scope of the variable 'id' can be reduced. [variableScope]
 int id;
     ^
net/rxrpc/conn_client.c:562:7: style: The scope of the variable 'drop_ref' can be reduced. [variableScope]
 bool drop_ref;
      ^
net/rxrpc/conn_client.c:584:16: style: The scope of the variable 'avail' can be reduced. [variableScope]
 unsigned long avail, mask;
               ^
net/rxrpc/conn_client.c:585:15: style: The scope of the variable 'channel' can be reduced. [variableScope]
 unsigned int channel, slot;
              ^
net/rxrpc/conn_client.c:585:24: style: The scope of the variable 'slot' can be reduced. [variableScope]
 unsigned int channel, slot;
                       ^
net/rxrpc/conn_client.c:898:26: style: The scope of the variable 'need_put' can be reduced. [variableScope]
 bool need_drop = false, need_put = false;
                         ^
net/rxrpc/conn_event.c:155:21: style: The scope of the variable 'call' can be reduced. [variableScope]
 struct rxrpc_call *call;
                    ^
net/rxrpc/conn_event.c:290:6: style: The scope of the variable 'loop' can be reduced. [variableScope]
 int loop, ret;
     ^
net/rxrpc/conn_service.c:33:18: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct rb_node *p;
                 ^
net/rxrpc/input.c:203:6: style: The scope of the variable 'ix' can be reduced. [variableScope]
 int ix;
     ^
net/rxrpc/input.c:306:16: style: The scope of the variable 'now' can be reduced. [variableScope]
 unsigned long now, timo;
               ^
net/rxrpc/input.c:306:21: style: The scope of the variable 'timo' can be reduced. [variableScope]
 unsigned long now, timo;
                    ^
net/rxrpc/input.c:435:17: style: The scope of the variable 'now' can be reduced. [variableScope]
  unsigned long now, expect_req_by;
                ^
net/rxrpc/input.c:435:22: style: The scope of the variable 'expect_req_by' can be reduced. [variableScope]
  unsigned long now, expect_req_by;
                     ^
net/rxrpc/input.c:770:6: style: The scope of the variable 'ix' can be reduced. [variableScope]
 int ix;
     ^
net/rxrpc/input.c:469:18: style: Local variable 'serial' shadows outer variable [shadowVariable]
  rxrpc_serial_t serial = sp->hdr.serial + j;
                 ^
net/rxrpc/input.c:416:17: note: Shadowed declaration
 rxrpc_serial_t serial = sp->hdr.serial, ack_serial = 0;
                ^
net/rxrpc/input.c:469:18: note: Shadow variable
  rxrpc_serial_t serial = sp->hdr.serial + j;
                 ^
net/rxrpc/key.c:567:16: style: The scope of the variable 'oldxdr' can be reduced. [variableScope]
 __be32 *xdr, *oldxdr;
               ^
net/rxrpc/local_object.c:334:15: style: The scope of the variable 'debug_id' can be reduced. [variableScope]
 unsigned int debug_id;
              ^
net/rxrpc/local_object.c:335:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
net/rxrpc/output.c:78:6: style: The scope of the variable 'ix' can be reduced. [variableScope]
 int ix;
     ^
net/rxrpc/peer_object.c:433:15: style: The scope of the variable 'debug_id' can be reduced. [variableScope]
 unsigned int debug_id;
              ^
net/rxrpc/peer_object.c:434:6: style: The scope of the variable 'n' can be reduced. [variableScope]
 int n;
     ^
net/rxrpc/proc.c:313:9: style: Condition 'n==0' is always false [knownConditionTrueFalse]
  if (n == 0) {
        ^
net/rxrpc/proc.c:306:7: note: Assignment 'n=1', assigned value is 1
  n = 1;
      ^
net/rxrpc/proc.c:309:14: note: Assuming condition is false
  if (bucket >= HASH_SIZE(rxnet->peer_hash)) {
             ^
net/rxrpc/proc.c:313:9: note: Condition 'n==0' is always false
  if (n == 0) {
        ^
net/rxrpc/proc.c:291:23: style: The scope of the variable 'n' can be reduced. [variableScope]
 unsigned int bucket, n;
                      ^
net/rxrpc/recvmsg.c:325:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/rxrpc/recvmsg.c:594:10: style: Local variable 'len' shadows outer argument [shadowArgument]
  size_t len = sizeof(call->peer->srx);
         ^
net/rxrpc/recvmsg.c:488:67: note: Shadowed declaration
int rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,
                                                                  ^
net/rxrpc/recvmsg.c:594:10: note: Shadow variable
  size_t len = sizeof(call->peer->srx);
         ^
net/rxrpc/sendmsg.c:474:6: style: The scope of the variable 'len' can be reduced. [variableScope]
 int len;
     ^
net/rxrpc/sendmsg.c:271:17: style: Local variable 'now' shadows outer variable [shadowVariable]
  unsigned long now = jiffies;
                ^
net/rxrpc/sendmsg.c:199:16: note: Shadowed declaration
 unsigned long now;
               ^
net/rxrpc/sendmsg.c:271:17: note: Shadow variable
  unsigned long now = jiffies;
                ^
net/sched/act_api.c:545:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/sched/act_api.c:710:30: style: The scope of the variable 'ops' can be reduced. [variableScope]
 const struct tc_action_ops *ops;
                             ^
net/sched/act_csum.c:396:43: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 switch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {
                                          ^
net/sched/act_ife.c:588:18: style: The if condition is the same as the previous if condition [duplicateCondition]
 if (parm->flags & IFE_ENCODE) {
                 ^
net/sched/act_ife.c:579:18: note: First condition
 if (parm->flags & IFE_ENCODE) {
                 ^
net/sched/act_ife.c:588:18: note: Second condition
 if (parm->flags & IFE_ENCODE) {
                 ^
net/sched/act_ife.c:357:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc = 0;
     ^
net/sched/act_ife.c:869:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/sched/act_ife.c:838:48: portability: 'ife_meta' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   err = e->ops->encode(skb, (void *)(ife_meta + skboff),
                                               ^
net/sched/act_ife.c:461:10: style: Variable 'len' is assigned a value that is never used. [unreadVariable]
 int len = 0;
         ^
net/sched/act_nat.c:166:43: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
 switch (iph->frag_off & htons(IP_OFFSET) ? 0 : iph->protocol) {
                                          ^
net/sched/act_sample.c:162:6: style: The scope of the variable 'size' can be reduced. [variableScope]
 int size;
     ^
net/sched/act_sample.c:163:6: style: The scope of the variable 'iif' can be reduced. [variableScope]
 int iif;
     ^
net/sched/act_sample.c:164:6: style: The scope of the variable 'oif' can be reduced. [variableScope]
 int oif;
     ^
net/sched/cls_api.c:495:23: warning: Either the condition 'chain' is redundant or there is possible null pointer dereference: chain. [nullPointerRedundantCheck]
 is_first_reference = chain->refcnt - chain->action_refcnt == 1;
                      ^
net/sched/cls_api.c:483:6: note: Assuming that condition 'chain' is not redundant
 if (chain) {
     ^
net/sched/cls_api.c:495:23: note: Null pointer dereference
 is_first_reference = chain->refcnt - chain->action_refcnt == 1;
                      ^
net/sched/cls_api.c:1940:6: warning: Either the condition 'if(tp&&!IS_ERR(tp))' is redundant or there is possible null pointer dereference: tp. [nullPointerRedundantCheck]
 if (tp->ops->put && fh)
     ^
net/sched/cls_api.c:2441:6: note: Assuming that condition 'if(tp&&!IS_ERR(tp))' is not redundant
  if (tp && !IS_ERR(tp))
     ^
net/sched/cls_api.c:2438:14: note: Calling function 'tfilter_put', 1st argument 'tp' value is 0
 tfilter_put(tp, fh);
             ^
net/sched/cls_api.c:1940:6: note: Null pointer dereference
 if (tp->ops->put && fh)
     ^
net/sched/cls_api.c:3244:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/sched/cls_api.c:2130:40: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
         n->nlmsg_flags & NLM_F_CREATE ? TCA_ACT_NOREPLACE : TCA_ACT_REPLACE,
                                       ^
net/sched/cls_api.c:955:11: style: Variable 'prio' is assigned a value that is never used. [unreadVariable]
 u32 prio = 0;
          ^
net/sched/cls_flower.c:886:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/sched/cls_fw.c:55:6: style: The scope of the variable 'r' can be reduced. [variableScope]
 int r;
     ^
net/sched/cls_route.c:219:24: style: The scope of the variable 'f' can be reduced. [variableScope]
 struct route4_filter *f;
                       ^
net/sched/cls_route.c:388:24: style: The scope of the variable 'fp' can be reduced. [variableScope]
 struct route4_filter *fp;
                       ^
net/sched/cls_tcindex.c:392:10: warning: Either the condition 'if(oldp)' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
 cp->h = p->h;
         ^
net/sched/cls_tcindex.c:506:5: note: Assuming that condition 'if(oldp)' is not redundant
 if (oldp)
    ^
net/sched/cls_tcindex.c:482:9: note: Assignment to 'oldp=p'
 oldp = p;
        ^
net/sched/cls_tcindex.c:392:10: note: Null pointer dereference
 cp->h = p->h;
         ^
net/sched/cls_tcindex.c:304:13: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int i, err = 0;
            ^
net/sched/em_canid.c:99:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/sched/ematch.c:98:15: warning:inconclusive: Possible null pointer dereference: e [nullPointer]
  if (kind == e->kind) {
              ^
net/sched/ematch.c:94:29: note: Assignment 'e=NULL', assigned value is 0
 struct tcf_ematch_ops *e = NULL;
                            ^
net/sched/ematch.c:98:15: note: Null pointer dereference
  if (kind == e->kind) {
              ^
net/sched/ematch.c:176:31: portability: '(void*)em_hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 void *data = (void *) em_hdr + sizeof(*em_hdr);
                              ^
net/sched/sch_api.c:656:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/sched/sch_api.c:769:7: style: The scope of the variable 'notify' can be reduced. [variableScope]
 bool notify;
      ^
net/sched/sch_api.c:1380:12: style: Variable 'arg.depth' is assigned a value that is never used. [unreadVariable]
 arg.depth = depth;
           ^
net/sched/sch_api.c:1381:8: style: Variable 'arg.p' is assigned a value that is never used. [unreadVariable]
 arg.p = p;
       ^
net/sched/sch_api.c:2154:10: style: Variable 'arg.skb' is assigned a value that is never used. [unreadVariable]
 arg.skb = skb;
         ^
net/sched/sch_api.c:2155:9: style: Variable 'arg.cb' is assigned a value that is never used. [unreadVariable]
 arg.cb = cb;
        ^
net/sched/sch_api.c:1969:14: style: Variable 'args.portid' is assigned a value that is never used. [unreadVariable]
 args.portid = portid;
             ^
net/sched/sch_api.c:1970:12: style: Variable 'args.clid' is assigned a value that is never used. [unreadVariable]
 args.clid = clid;
           ^
net/sched/sch_api.c:1971:14: style: Variable 'args.new_cl' is assigned a value that is never used. [unreadVariable]
 args.new_cl = new_cl;
             ^
net/sched/sch_atm.c:435:27: warning: Either the condition 'if(flow)' is redundant or there is possible null pointer dereference: flow. [nullPointerRedundantCheck]
 ret = qdisc_enqueue(skb, flow->q, to_free);
                          ^
net/sched/sch_atm.c:440:7: note: Assuming that condition 'if(flow)' is not redundant
   if (flow)
      ^
net/sched/sch_atm.c:435:27: note: Null pointer dereference
 ret = qdisc_enqueue(skb, flow->q, to_free);
                          ^
net/sched/sch_atm.c:271:17: style: The scope of the variable 'cl' can be reduced. [variableScope]
  unsigned long cl;
                ^
net/sched/sch_atm.c:437:1: style: Label 'drop' is not used. There is #if in function body so the label might be used in code that is removed by the preprocessor. [unusedLabelConfiguration]
drop: __maybe_unused
^
net/sched/sch_cake.c:907:22: style: The scope of the variable 'iph' can be reduced. [variableScope]
 const struct iphdr *iph;
                     ^
net/sched/sch_cake.c:1933:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/sched/sch_cake.c:1828:8: style: Local variable 'b' shadows outer variable [shadowVariable]
   u64 b = q->avg_window_bytes * (u64)NSEC_PER_SEC;
       ^
net/sched/sch_cake.c:1698:24: note: Shadowed declaration
 struct cake_tin_data *b;
                       ^
net/sched/sch_cake.c:1828:8: note: Shadow variable
   u64 b = q->avg_window_bytes * (u64)NSEC_PER_SEC;
       ^
net/sched/sch_cbq.c:278:11: style: Variable 'cl' is reassigned a value before the old one has been used. [redundantAssignment]
     !(cl = head->defaults[prio & TC_PRIO_MAX]) &&
          ^
net/sched/sch_cbq.c:272:5: note: cl is assigned
 cl = head;
    ^
net/sched/sch_cbq.c:278:11: note: cl is overwritten
     !(cl = head->defaults[prio & TC_PRIO_MAX]) &&
          ^
net/sched/sch_cbq.c:697:16: style: Redundant initialization for 'borrow'. The initialized value is overwritten before it is read. [redundantInitialization]
       (borrow = cbq_under_limit(cl)) == NULL)
               ^
net/sched/sch_cbq.c:694:29: note: borrow is initialized
   struct cbq_class *borrow = cl;
                            ^
net/sched/sch_cbq.c:697:16: note: borrow is overwritten
       (borrow = cbq_under_limit(cl)) == NULL)
               ^
net/sched/sch_cbq.c:785:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/sched/sch_cbq.c:802:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/sched/sch_cbq.c:980:26: style: The scope of the variable 'clp' can be reduced. [variableScope]
 struct cbq_class *cl, **clp;
                         ^
net/sched/sch_cbs.c:336:21: style: The scope of the variable 'qdev' can be reduced. [variableScope]
 struct net_device *qdev;
                    ^
net/sched/sch_choke.c:183:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/sched/sch_ets.c:113:15: style: The scope of the variable 'quantum' can be reduced. [variableScope]
 unsigned int quantum;
              ^
net/sched/sch_ets.c:114:15: style: The scope of the variable 'w_psum' can be reduced. [variableScope]
 unsigned int w_psum;
              ^
net/sched/sch_ets.c:115:15: style: The scope of the variable 'weight' can be reduced. [variableScope]
 unsigned int weight;
              ^
net/sched/sch_fifo.c:254:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = -ENOMEM;
         ^
net/sched/sch_fq.c:407:25: style: The scope of the variable 'aux' can be reduced. [variableScope]
 struct sk_buff *head, *aux;
                        ^
net/sched/sch_fq.c:665:18: style: The scope of the variable 'root' can be reduced. [variableScope]
 struct rb_root *root;
                 ^
net/sched/sch_fq.c:666:18: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct rb_node *p;
                 ^
net/sched/sch_fq.c:701:18: style: The scope of the variable 'op' can be reduced. [variableScope]
 struct rb_node *op, **np, *parent;
                 ^
net/sched/sch_fq.c:702:18: style: The scope of the variable 'oroot' can be reduced. [variableScope]
 struct rb_root *oroot, *nroot;
                 ^
net/sched/sch_fq_codel.c:141:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/sched/sch_generic.c:395:16: style: The scope of the variable 'val' can be reduced. [variableScope]
 unsigned long val, res;
               ^
net/sched/sch_generic.c:424:18: style: The scope of the variable 'trans_start' can be reduced. [variableScope]
   unsigned long trans_start;
                 ^
net/sched/sch_generic.c:679:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, band;
     ^
net/sched/sch_hfsc.c:190:21: style: The scope of the variable 'cl1' can be reduced. [variableScope]
 struct hfsc_class *cl1;
                    ^
net/sched/sch_hfsc.c:255:21: style: The scope of the variable 'cl1' can be reduced. [variableScope]
 struct hfsc_class *cl1;
                    ^
net/sched/sch_hfsc.c:285:21: style: The scope of the variable 'p' can be reduced. [variableScope]
 struct hfsc_class *p;
                    ^
net/sched/sch_hfsc.c:324:21: style: The scope of the variable 'cl1' can be reduced. [variableScope]
 struct hfsc_class *cl1;
                    ^
net/sched/sch_hfsc.c:851:15: style: The scope of the variable 'level' can be reduced. [variableScope]
 unsigned int level;
              ^
net/sched/sch_hfsc.c:1585:15: style: The scope of the variable 'next_len' can be reduced. [variableScope]
 unsigned int next_len;
              ^
net/sched/sch_hfsc.c:856:17: style: Unsigned expression 'p->level' can't be negative so it is unnecessary to test it. [unsignedPositive]
   if (p->level >= level)
                ^
net/sched/sch_hfsc.c:854:11: note: Assignment 'level=0', assigned value is 0
  level = 0;
          ^
net/sched/sch_hfsc.c:856:17: note: Unsigned positive
   if (p->level >= level)
                ^
net/sched/sch_hhf.c:581:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/sched/sch_htb.c:0:0: information: This file is not analyzed. Cppcheck failed to extract a valid configuration. Use -v for more details. [noValidConfiguration]

^
net/sched/sch_mq.c:72:23: style: The scope of the variable 'dev_queue' can be reduced. [variableScope]
 struct netdev_queue *dev_queue;
                      ^
net/sched/sch_mq.c:133:13: style: Variable 'qlen' is assigned a value that is never used. [unreadVariable]
 __u32 qlen = 0;
            ^
net/sched/sch_mqprio.c:226:9: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]
 for (i = 0; i < dev->num_tx_queues; i++) {
        ^
net/sched/sch_mqprio.c:198:6: note: i is assigned
    i++;
     ^
net/sched/sch_mqprio.c:226:9: note: i is overwritten
 for (i = 0; i < dev->num_tx_queues; i++) {
        ^
net/sched/sch_mqprio.c:226:9: style: Variable 'i' is reassigned a value before the old one has been used. [redundantAssignment]
 for (i = 0; i < dev->num_tx_queues; i++) {
        ^
net/sched/sch_mqprio.c:214:6: note: i is assigned
    i++;
     ^
net/sched/sch_mqprio.c:226:9: note: i is overwritten
 for (i = 0; i < dev->num_tx_queues; i++) {
        ^
net/sched/sch_mqprio.c:34:15: style: The scope of the variable 'ntx' can be reduced. [variableScope]
 unsigned int ntx;
              ^
net/sched/sch_mqprio.c:138:23: style: The scope of the variable 'dev_queue' can be reduced. [variableScope]
 struct netdev_queue *dev_queue;
                      ^
net/sched/sch_mqprio.c:143:17: style: The scope of the variable 'attr' can be reduced. [variableScope]
 struct nlattr *attr;
                ^
net/sched/sch_mqprio.c:144:6: style: The scope of the variable 'rem' can be reduced. [variableScope]
 int rem;
     ^
net/sched/sch_mqprio.c:293:16: style: The scope of the variable 'qdisc' can be reduced. [variableScope]
 struct Qdisc *qdisc, *old;
               ^
net/sched/sch_mqprio.c:293:24: style: The scope of the variable 'old' can be reduced. [variableScope]
 struct Qdisc *qdisc, *old;
                       ^
net/sched/sch_multiq.c:214:26: style: The scope of the variable 'old' can be reduced. [variableScope]
   struct Qdisc *child, *old;
                         ^
net/sched/sch_multiq.c:39:6: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 err = tcf_classify(skb, fl, &res, false);
     ^
net/sched/sch_netem.c:596:21: style: The scope of the variable 'last_len' can be reduced. [variableScope]
  unsigned int len, last_len;
                    ^
net/sched/sch_qfq.c:751:20: style: The scope of the variable 'next' can be reduced. [variableScope]
 struct qfq_group *next;
                   ^
net/sched/sch_qfq.c:779:20: style: The scope of the variable 'next' can be reduced. [variableScope]
 struct qfq_group *next;
                   ^
net/sched/sch_qfq.c:1033:16: style: The scope of the variable 'mask' can be reduced. [variableScope]
 unsigned long mask;
               ^
net/sched/sch_qfq.c:1357:16: style: The scope of the variable 'mask' can be reduced. [variableScope]
 unsigned long mask;
               ^
net/sched/sch_sfb.c:496:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/sched/sch_sfq.c:645:14: style: Checking if unsigned expression 'scaled' is less than zero. [unsignedLessThanZero]
  if (scaled <= 0 || scaled > SHRT_MAX)
             ^
net/sched/sch_sfq.c:762:7: style: Local variable 'err' shadows outer variable [shadowVariable]
  int err = sfq_change(sch, opt);
      ^
net/sched/sch_sfq.c:736:6: note: Shadowed declaration
 int err;
     ^
net/sched/sch_sfq.c:762:7: note: Shadow variable
  int err = sfq_change(sch, opt);
      ^
net/sched/sch_taprio.c:162:38: warning:inconclusive: Possible null pointer dereference: entry [nullPointer]
 intv_end = ktime_add_ns(intv_start, entry->interval);
                                     ^
net/sched/sch_taprio.c:195:30: note: Assignment 'entry=NULL', assigned value is 0
 struct sched_entry *entry = NULL, *entry_found = NULL;
                             ^
net/sched/sch_taprio.c:208:6: note: Assuming condition is false
 if (!sched)
     ^
net/sched/sch_taprio.c:218:55: note: Calling function 'get_interval_end_time', 3rd argument 'entry' value is 0
  curr_intv_end = get_interval_end_time(sched, admin, entry,
                                                      ^
net/sched/sch_taprio.c:162:38: note: Null pointer dereference
 intv_end = ktime_add_ns(intv_start, entry->interval);
                                     ^
net/sched/sch_taprio.c:297:22: style: The scope of the variable 'iph' can be reduced. [variableScope]
 const struct iphdr *iph;
                     ^
net/sched/sch_taprio.c:1078:21: style: The scope of the variable 'qdev' can be reduced. [variableScope]
 struct net_device *qdev;
                    ^
net/sched/sch_taprio.c:1603:15: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int i;
              ^
net/sched/sch_tbf.c:197:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret, nb;
     ^
net/sched/sch_teql.c:363:8: style: Redundant initialization for 'flags'. The initialized value is overwritten before it is read. [redundantInitialization]
 flags = FMASK;
       ^
net/sched/sch_teql.c:358:21: note: flags is initialized
 unsigned int flags = IFF_NOARP | IFF_MULTICAST;
                    ^
net/sched/sch_teql.c:363:8: note: flags is overwritten
 flags = FMASK;
       ^
net/sched/sch_teql.c:238:7: style: Local variable 'err' shadows outer variable [shadowVariable]
  int err;
      ^
net/sched/sch_teql.c:221:6: note: Shadowed declaration
 int err = 0;
     ^
net/sched/sch_teql.c:238:7: note: Shadow variable
  int err;
      ^
net/sched/sch_teql.c:246:8: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
   err = -EINVAL;
       ^
net/sctp/associola.c:316:25: style: The scope of the variable 'transport' can be reduced. [variableScope]
 struct sctp_transport *transport;
                        ^
net/sctp/associola.c:1466:21: style: The scope of the variable 'sack' can be reduced. [variableScope]
 struct sctp_chunk *sack;
                    ^
net/sctp/associola.c:1467:21: style: The scope of the variable 'timer' can be reduced. [variableScope]
 struct timer_list *timer;
                    ^
net/sctp/auth.c:152:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/sctp/auth.c:153:14: style: The scope of the variable 'longer' can be reduced. [variableScope]
 const __u8 *longer;
             ^
net/sctp/bind_addr.c:440:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   addr_buf += af->sockaddr_len;
            ^
net/sctp/diag.c:90:15: portability: 'info' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memset(info + sizeof(laddr->a), 0, addrlen - sizeof(laddr->a));
              ^
net/sctp/diag.c:91:8: portability: 'info' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  info += addrlen;
       ^
net/sctp/diag.c:114:15: portability: 'info' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  memset(info + sizeof(from->ipaddr), 0,
              ^
net/sctp/diag.c:116:8: portability: 'info' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  info += addrlen;
       ^
net/sctp/input.c:1106:18: style: The scope of the variable 'af' can be reduced. [variableScope]
 struct sctp_af *af;
                 ^
net/sctp/input.c:831:29: style:inconclusive: Function '__sctp_rcv_lookup_endpoint' argument 4 names different: declaration 'daddr' definition 'paddr'. [funcArgNamesDifferent]
     const union sctp_addr *paddr)
                            ^
net/sctp/input.c:57:29: note: Function '__sctp_rcv_lookup_endpoint' argument 4 names different: declaration 'daddr' definition 'paddr'.
     const union sctp_addr *daddr);
                            ^
net/sctp/input.c:831:29: note: Function '__sctp_rcv_lookup_endpoint' argument 4 names different: declaration 'daddr' definition 'paddr'.
     const union sctp_addr *paddr)
                            ^
net/sctp/ipv6.c:927:22: style: The scope of the variable 'dev' can be reduced. [variableScope]
  struct net_device *dev;
                     ^
net/sctp/ipv6.c:963:22: style: The scope of the variable 'dev' can be reduced. [variableScope]
  struct net_device *dev;
                     ^
net/sctp/output.c:620:31: style: The statement 'if (asoc->peer.last_sent_to!=tp) asoc->peer.last_sent_to=tp' is logically equivalent to 'asoc->peer.last_sent_to=tp'. [duplicateConditionalAssign]
  if (asoc->peer.last_sent_to != tp)
                              ^
net/sctp/output.c:621:28: note: Assignment 'asoc->peer.last_sent_to=tp'
   asoc->peer.last_sent_to = tp;
                           ^
net/sctp/output.c:620:31: note: Condition 'asoc->peer.last_sent_to!=tp' is redundant
  if (asoc->peer.last_sent_to != tp)
                              ^
net/sctp/output.c:506:6: style: Condition 'gso' is always true [knownConditionTrueFalse]
 if (gso) {
     ^
net/sctp/output.c:417:6: note: Assuming that condition 'gso' is not redundant
 if (gso) {
     ^
net/sctp/output.c:506:6: note: Condition 'gso' is always true
 if (gso) {
     ^
net/sctp/outqueue.c:322:30: style: The scope of the variable 'lchunk' can be reduced. [variableScope]
 struct sctp_chunk *nchunk, *lchunk;
                             ^
net/sctp/outqueue.c:452:21: style: The scope of the variable 'chunk' can be reduced. [variableScope]
 struct sctp_chunk *chunk;
                    ^
net/sctp/outqueue.c:873:6: style: The scope of the variable 'one_packet' can be reduced. [variableScope]
 int one_packet, error;
     ^
net/sctp/outqueue.c:1139:22: style: The scope of the variable 'packet' can be reduced. [variableScope]
 struct sctp_packet *packet;
                     ^
net/sctp/outqueue.c:1411:15: style:inconclusive: Function 'sctp_check_transmitted' argument 6 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'. [funcArgNamesDifferent]
       __u32 *highest_new_tsn_in_sack)
              ^
net/sctp/outqueue.c:48:15: note: Function 'sctp_check_transmitted' argument 6 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'.
       __u32 *highest_new_tsn);
              ^
net/sctp/outqueue.c:1411:15: note: Function 'sctp_check_transmitted' argument 6 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'.
       __u32 *highest_new_tsn_in_sack)
              ^
net/sctp/outqueue.c:1683:16: style:inconclusive: Function 'sctp_mark_missing' argument 4 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'. [funcArgNamesDifferent]
         __u32 highest_new_tsn_in_sack,
               ^
net/sctp/outqueue.c:53:16: note: Function 'sctp_mark_missing' argument 4 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'.
         __u32 highest_new_tsn,
               ^
net/sctp/outqueue.c:1683:16: note: Function 'sctp_mark_missing' argument 4 names different: declaration 'highest_new_tsn' definition 'highest_new_tsn_in_sack'.
         __u32 highest_new_tsn_in_sack,
               ^
net/sctp/outqueue.c:1141:12: style: Variable 'error' is assigned a value that is never used. [unreadVariable]
 int error = 0;
           ^
net/sctp/proc.c:116:19: style: The scope of the variable 'addr' can be reduced. [variableScope]
 union sctp_addr *addr, *primary;
                  ^
net/sctp/proc.c:117:18: style: The scope of the variable 'af' can be reduced. [variableScope]
 struct sctp_af *af;
                 ^
net/sctp/proc.c:165:24: style: The scope of the variable 'ep' can be reduced. [variableScope]
 struct sctp_endpoint *ep;
                       ^
net/sctp/proc.c:166:15: style: The scope of the variable 'sk' can be reduced. [variableScope]
 struct sock *sk;
              ^
net/sctp/protocol.c:1617:24: error: There is an unknown macro here somewhere. Configuration is required. If __stringify is a macro then please configure it. [unknownMacro]
MODULE_ALIAS("net-pf-" __stringify(PF_INET) "-proto-132");
                       ^
net/sctp/sm_make_chunk.c:3837:13: style: Condition 'cnt++>2' is always false [knownConditionTrueFalse]
  if (cnt++ > 2)
            ^
net/sctp/sm_make_chunk.c:3830:14: note: Assignment 'cnt=0', assigned value is 0
 __u16 cnt = 0;
             ^
net/sctp/sm_make_chunk.c:3837:13: note: Condition 'cnt++>2' is always false
  if (cnt++ > 2)
            ^
net/sctp/sm_make_chunk.c:2245:6: style: The scope of the variable 'result' can be reduced. [variableScope]
 int result;
     ^
net/sctp/sm_make_chunk.c:2833:12: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf += af->sockaddr_len;
           ^
net/sctp/sm_make_chunk.c:2864:12: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf += af->sockaddr_len;
           ^
net/sctp/sm_make_chunk.c:3016:36: portability: '(void*)asconf_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 addr_param = (void *)asconf_param + sizeof(*asconf_param);
                                   ^
net/sctp/sm_make_chunk.c:3313:36: portability: '(void*)asconf_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 addr_param = (void *)asconf_param + sizeof(*asconf_param);
                                   ^
net/sctp/sm_make_chunk.c:3396:42: portability: '(void*)asconf_ack_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
    err_param = (void *)asconf_ack_param + length;
                                         ^
net/sctp/sm_make_chunk.c:3409:47: portability: '(void*)asconf_ack_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  asconf_ack_param = (void *)asconf_ack_param + length;
                                              ^
net/sctp/sm_make_chunk.c:3441:36: portability: '(void*)addr_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 asconf_param = (void *)addr_param + length;
                                   ^
net/sctp/sm_make_chunk.c:3492:39: portability: '(void*)asconf_param' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  asconf_param = (void *)asconf_param + length;
                                      ^
net/sctp/sm_make_chunk.c:2816:21: style: Variable 'addr_param_len' is assigned a value that is never used. [unreadVariable]
 int addr_param_len = 0;
                    ^
net/sctp/sm_make_chunk.c:3422:18: style: Variable 'err_code' is assigned a value that is never used. [unreadVariable]
 __be16 err_code = SCTP_ERROR_NO_ERROR;
                 ^
net/sctp/sm_sideeffect.c:620:21: style: The scope of the variable 'abort' can be reduced. [variableScope]
 struct sctp_chunk *abort;
                    ^
net/sctp/sm_sideeffect.c:955:22: style: The scope of the variable 'err_hdr' can be reduced. [variableScope]
 struct sctp_errhdr *err_hdr;
                     ^
net/sctp/sm_sideeffect.c:956:24: style: The scope of the variable 'ev' can be reduced. [variableScope]
 struct sctp_ulpevent *ev;
                       ^
net/sctp/sm_statefuns.c:512:22: style: The scope of the variable 'packet' can be reduced. [variableScope]
 struct sctp_packet *packet;
                     ^
net/sctp/sm_statefuns.c:5760:25: style: The scope of the variable 'bp' can be reduced. [variableScope]
 struct sctp_bind_addr *bp;
                        ^
net/sctp/sm_statefuns.c:6179:21: style: The scope of the variable 'abort' can be reduced. [variableScope]
 struct sctp_chunk *abort;
                    ^
net/sctp/sm_statefuns.c:6301:22: style: The scope of the variable 'packet' can be reduced. [variableScope]
 struct sctp_packet *packet;
                     ^
net/sctp/socket.c:6079:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  to += addrlen;
  ^
net/sctp/socket.c:6081:3: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
  space_left -= addrlen;
  ^
net/sctp/socket.c:3649:15: style: Condition '!ret' is always true [knownConditionTrueFalse]
   if (res && !ret)
              ^
net/sctp/socket.c:3642:8: note: Assignment 'ret=0', assigned value is 0
 ret = 0;
       ^
net/sctp/socket.c:3649:15: note: Condition '!ret' is always true
   if (res && !ret)
              ^
net/sctp/socket.c:4195:14: style: Condition '!retval' is always true [knownConditionTrueFalse]
  if (ret && !retval) /* try to return the 1st error. */
             ^
net/sctp/socket.c:4189:11: note: Assignment 'retval=0', assigned value is 0
 retval = 0;
          ^
net/sctp/socket.c:4195:14: note: Condition '!retval' is always true
  if (ret && !retval) /* try to return the 1st error. */
             ^
net/sctp/socket.c:639:10: style: Variable 'retval' is reassigned a value before the old one has been used. [redundantAssignment]
  retval = sctp_send_asconf(asoc, chunk);
         ^
net/sctp/socket.c:618:11: note: retval is assigned
   retval = sctp_add_bind_addr(bp, &saveaddr,
          ^
net/sctp/socket.c:639:10: note: retval is overwritten
  retval = sctp_send_asconf(asoc, chunk);
         ^
net/sctp/socket.c:9115:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = 0;
      ^
net/sctp/socket.c:9111:7: note: err is assigned
  err = -EINVAL;
      ^
net/sctp/socket.c:9115:7: note: err is overwritten
  err = 0;
      ^
net/sctp/socket.c:9123:7: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
  err = -EAGAIN;
      ^
net/sctp/socket.c:9119:7: note: err is assigned
  err = sock_intr_errno(timeo);
      ^
net/sctp/socket.c:9123:7: note: err is overwritten
  err = -EAGAIN;
      ^
net/sctp/socket.c:988:19: style: The scope of the variable 'sa_addr' can be reduced. [variableScope]
 struct sockaddr *sa_addr;
                  ^
net/sctp/socket.c:990:18: style: The scope of the variable 'af' can be reduced. [variableScope]
 struct sctp_af *af;
                 ^
net/sctp/socket.c:1881:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/sctp/socket.c:2034:6: style: The scope of the variable 'rlen' can be reduced. [variableScope]
 int rlen;
     ^
net/sctp/socket.c:2218:25: style: The scope of the variable 'event' can be reduced. [variableScope]
  struct sctp_ulpevent *event;
                        ^
net/sctp/socket.c:2410:6: style: The scope of the variable 'error' can be reduced. [variableScope]
 int error;
     ^
net/sctp/socket.c:4245:24: style: The scope of the variable 'event' can be reduced. [variableScope]
 struct sctp_ulpevent *event;
                       ^
net/sctp/socket.c:6004:6: style: The scope of the variable 'addrlen' can be reduced. [variableScope]
 int addrlen;
     ^
net/sctp/socket.c:6466:20: style: The scope of the variable 'pos' can be reduced. [variableScope]
 struct list_head *pos;
                   ^
net/sctp/socket.c:6467:6: style: The scope of the variable 'cnt' can be reduced. [variableScope]
 int cnt = 0;
     ^
net/sctp/socket.c:8237:7: style: The scope of the variable 'alg' can be reduced. [variableScope]
 char alg[32];
      ^
net/sctp/socket.c:9133:55: style:inconclusive: Function 'sctp_wait_for_close' argument 2 names different: declaration 'timeo' definition 'timeout'. [funcArgNamesDifferent]
static void sctp_wait_for_close(struct sock *sk, long timeout)
                                                      ^
net/sctp/socket.c:78:55: note: Function 'sctp_wait_for_close' argument 2 names different: declaration 'timeo' definition 'timeout'.
static void sctp_wait_for_close(struct sock *sk, long timeo);
                                                      ^
net/sctp/socket.c:9133:55: note: Function 'sctp_wait_for_close' argument 2 names different: declaration 'timeo' definition 'timeout'.
static void sctp_wait_for_close(struct sock *sk, long timeout)
                                                      ^
net/sctp/socket.c:4081:11: warning:inconclusive: Multiplying sizeof() with sizeof() indicates a logic error. [multiplySizeof]
          sizeof(__u16) * sizeof(*params));
          ^
net/sctp/socket.c:514:12: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf += af->sockaddr_len;
           ^
net/sctp/socket.c:592:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   addr_buf += af->sockaddr_len;
            ^
net/sctp/socket.c:621:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   addr_buf += af->sockaddr_len;
            ^
net/sctp/socket.c:717:12: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf += af->sockaddr_len;
           ^
net/sctp/socket.c:796:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   addr_buf += af->sockaddr_len;
            ^
net/sctp/socket.c:869:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   addr_buf += af->sockaddr_len;
            ^
net/sctp/socket.c:1012:12: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf += af->sockaddr_len;
           ^
net/sctp/socket.c:1185:11: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 addr_buf += af->sockaddr_len;
          ^
net/sctp/socket.c:1204:13: portability: 'addr_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr_buf  += af->sockaddr_len;
            ^
net/sctp/socket.c:6079:6: portability: 'to' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  to += addrlen;
     ^
net/sctp/socket.c:6167:7: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  buf += addrlen;
      ^
net/sctp/socket.c:1388:18: style: Variable 'param.assoc_id' is assigned a value that is never used. [unreadVariable]
  param.assoc_id = param32.assoc_id;
                 ^
net/sctp/stream.c:740:60: portability: Shifting signed 32-bit value by 31 bits is implementation-defined behaviour [shiftTooManyBitsSigned]
 init_tsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map) + (1 << 31);
                                                           ^
net/sctp/stream_interleave.c:75:57: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
   mid = lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG ?
                                                        ^
net/sctp/stream_interleave.c:79:57: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
   mid = lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG ?
                                                        ^
net/sctp/stream_interleave.c:1196:2: portability: '(void*)(chunk)->subh.ifwdtsn_hdr->skip' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sctp_walk_ifwdtsn(skip, chunk)
 ^
net/sctp/stream_interleave.c:1291:2: portability: '(void*)(chunk)->subh.ifwdtsn_hdr->skip' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 sctp_walk_ifwdtsn(skip, chunk)
 ^
net/sctp/stream_sched.c:154:6: portability: 'p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   p += offsetofend(struct sctp_stream_out_ext, outq);
     ^
net/sctp/stream_sched_prio.c:297:26: style: The scope of the variable 'sout' can be reduced. [variableScope]
 struct sctp_stream_out *sout;
                         ^
net/sctp/stream_sched_rr.c:153:30: style: The scope of the variable 'soute' can be reduced. [variableScope]
 struct sctp_stream_out_ext *soute;
                             ^
net/sctp/tsnmap.c:284:4: style: Redundant initialization for 'i'. The initialized value is overwritten before it is read. [redundantInitialization]
 i = find_next_bit(map, len, off);
   ^
net/sctp/tsnmap.c:275:8: note: i is initialized
 int i = off;
       ^
net/sctp/tsnmap.c:284:4: note: i is overwritten
 i = find_next_bit(map, len, off);
   ^
net/sctp/ulpqueue.c:149:26: style: The scope of the variable 'event' can be reduced. [variableScope]
   struct sctp_ulpevent *event;
                         ^
net/sctp/ulpqueue.c:1028:24: style: The scope of the variable 'event' can be reduced. [variableScope]
 struct sctp_ulpevent *event;
                       ^
net/smc/af_smc.c:537:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/smc/af_smc.c:1191:15: style: The scope of the variable 'new_sk' can be reduced. [variableScope]
 struct sock *new_sk;
              ^
net/smc/af_smc.c:1784:9: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 int rc = 0;
        ^
net/smc/smc_cdc.c:255:9: warning: Identical condition and return expression 'rc', return value is always 0 [identicalConditionAfterEarlyExit]
 return rc;
        ^
net/smc/smc_cdc.c:240:6: note: If condition 'rc' is true, the function will return/exit
 if (rc)
     ^
net/smc/smc_cdc.c:255:9: note: Returning identical expression 'rc'
 return rc;
        ^
net/smc/smc_cdc.c:234:21: style: Variable 'curs.acurs.counter' is reassigned a value before the old one has been used. [redundantAssignment]
 curs.acurs.counter = atomic64_read(&conn->local_tx_ctrl.cons.acurs);
                    ^
net/smc/smc_cdc.c:231:21: note: curs.acurs.counter is assigned
 curs.acurs.counter = atomic64_read(&conn->local_tx_ctrl.prod.acurs);
                    ^
net/smc/smc_cdc.c:234:21: note: curs.acurs.counter is overwritten
 curs.acurs.counter = atomic64_read(&conn->local_tx_ctrl.cons.acurs);
                    ^
net/smc/smc_cdc.c:32:6: style: The scope of the variable 'diff' can be reduced. [variableScope]
 int diff;
     ^
net/smc/smc_clc.c:240:6: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
  rc = smc_clc_prfx_set4_rcu(dst, addr->sin_addr.s_addr, prop);
     ^
net/smc/smc_clc.c:222:9: note: rc is initialized
 int rc = -ENOENT;
        ^
net/smc/smc_clc.c:240:6: note: rc is overwritten
  rc = smc_clc_prfx_set4_rcu(dst, addr->sin_addr.s_addr, prop);
     ^
net/smc/smc_clc.c:683:8: style: Redundant initialization for 'link'. The initialized value is overwritten before it is read. [redundantInitialization]
  link = conn->lnk;
       ^
net/smc/smc_clc.c:680:25: note: link is initialized
  struct smc_link *link = conn->lnk;
                        ^
net/smc/smc_clc.c:683:8: note: link is overwritten
  link = conn->lnk;
       ^
net/smc/smc_clc.c:490:20: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int len, i, plen, rc;
                   ^
net/smc/smc_clc.c:759:42: style:inconclusive: Function 'smc_clc_send_accept' argument 1 names different: declaration 'smc' definition 'new_smc'. [funcArgNamesDifferent]
int smc_clc_send_accept(struct smc_sock *new_smc, bool srv_first_contact,
                                         ^
net/smc/smc_clc.h:329:42: note: Function 'smc_clc_send_accept' argument 1 names different: declaration 'smc' definition 'new_smc'.
int smc_clc_send_accept(struct smc_sock *smc, bool srv_first_contact,
                                         ^
net/smc/smc_clc.c:759:42: note: Function 'smc_clc_send_accept' argument 1 names different: declaration 'smc' definition 'new_smc'.
int smc_clc_send_accept(struct smc_sock *new_smc, bool srv_first_contact,
                                         ^
net/smc/smc_clc.c:46:36: style: Variable 'smcd_v2_ext' is not assigned a value. [unassignedVariable]
 struct smc_clc_smcd_v2_extension *smcd_v2_ext;
                                   ^
net/smc/smc_close.c:140:20: style: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false [knownConditionTrueFalse]
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:138:16: note: sk->sk_state is assigned value 26
  sk->sk_state = SMC_PEERABORTWAIT;
               ^
net/smc/smc_close.c:140:20: note: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:150:20: style: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false [knownConditionTrueFalse]
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:148:16: note: sk->sk_state is assigned value 26
  sk->sk_state = SMC_PEERABORTWAIT;
               ^
net/smc/smc_close.c:150:20: note: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:161:20: style: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false [knownConditionTrueFalse]
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:159:16: note: sk->sk_state is assigned value 26
  sk->sk_state = SMC_PEERABORTWAIT;
               ^
net/smc/smc_close.c:161:20: note: Condition 'sk->sk_state!=SMC_PEERABORTWAIT' is always false
  if (sk->sk_state != SMC_PEERABORTWAIT)
                   ^
net/smc/smc_close.c:26:17: style: The scope of the variable 'tcp' can be reduced. [variableScope]
 struct socket *tcp;
                ^
net/smc/smc_core.c:1844:14: error: Array 'lgr->rtokens[255][3]' accessed at index lgr->rtokens[*][3], which is out of bounds. [arrayIndexOutOfBounds]
 lgr->rtokens[rtok_idx][link_idx].rkey = rkey;
             ^
net/smc/smc_core.c:1836:2: note: After for loop, link_idx has value 3
 for (link_idx = 0; link_idx < SMC_LINKS_PER_LGR_MAX; link_idx++) {
 ^
net/smc/smc_core.c:1842:6: note: Assuming condition is false
 if (!found)
     ^
net/smc/smc_core.c:1844:14: note: Array index out of bounds
 lgr->rtokens[rtok_idx][link_idx].rkey = rkey;
             ^
net/smc/smc_core.c:1845:14: error: Array 'lgr->rtokens[255][3]' accessed at index lgr->rtokens[*][3], which is out of bounds. [arrayIndexOutOfBounds]
 lgr->rtokens[rtok_idx][link_idx].dma_addr = dma_addr;
             ^
net/smc/smc_core.c:1836:2: note: After for loop, link_idx has value 3
 for (link_idx = 0; link_idx < SMC_LINKS_PER_LGR_MAX; link_idx++) {
 ^
net/smc/smc_core.c:1842:6: note: Assuming condition is false
 if (!found)
     ^
net/smc/smc_core.c:1845:14: note: Array index out of bounds
 lgr->rtokens[rtok_idx][link_idx].dma_addr = dma_addr;
             ^
net/smc/smc_core.c:154:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/smc/smc_core.c:485:6: style: The scope of the variable 'diff' can be reduced. [variableScope]
 int diff;
     ^
net/smc/smc_core.c:608:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/smc/smc_core.c:813:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/smc/smc_core.c:906:25: style: The scope of the variable 'conn' can be reduced. [variableScope]
 struct smc_connection *conn;
                        ^
net/smc/smc_core.c:1008:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/smc/smc_core.c:1511:9: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int i, rc = 0;
        ^
net/smc/smc_core.c:1605:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/smc/smc_core.c:980:46: style:inconclusive: Function 'smc_smcd_terminate_all' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
void smc_smcd_terminate_all(struct smcd_dev *smcd)
                                             ^
net/smc/smc_core.h:375:46: note: Function 'smc_smcd_terminate_all' argument 1 names different: declaration 'dev' definition 'smcd'.
void smc_smcd_terminate_all(struct smcd_dev *dev);
                                             ^
net/smc/smc_core.c:980:46: note: Function 'smc_smcd_terminate_all' argument 1 names different: declaration 'dev' definition 'smcd'.
void smc_smcd_terminate_all(struct smcd_dev *smcd)
                                             ^
net/smc/smc_core.c:1895:25: style:inconclusive: Function 'smc_rmb_rtoken_handling' argument 2 names different: declaration 'link' definition 'lnk'. [funcArgNamesDifferent]
       struct smc_link *lnk,
                        ^
net/smc/smc_core.h:379:75: note: Function 'smc_rmb_rtoken_handling' argument 2 names different: declaration 'link' definition 'lnk'.
int smc_rmb_rtoken_handling(struct smc_connection *conn, struct smc_link *link,
                                                                          ^
net/smc/smc_core.c:1895:25: note: Function 'smc_rmb_rtoken_handling' argument 2 names different: declaration 'link' definition 'lnk'.
       struct smc_link *lnk,
                        ^
net/smc/smc_core.c:374:9: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 int rc = 0;
        ^
net/smc/smc_core.c:1511:12: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
 int i, rc = 0;
           ^
net/smc/smc_ism.c:27:76: style:inconclusive: Function 'smc_ism_cantalk' argument 3 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
int smc_ism_cantalk(u64 peer_gid, unsigned short vlan_id, struct smcd_dev *smcd)
                                                                           ^
net/smc/smc_ism.h:42:76: note: Function 'smc_ism_cantalk' argument 3 names different: declaration 'dev' definition 'smcd'.
int smc_ism_cantalk(u64 peer_gid, unsigned short vlan_id, struct smcd_dev *dev);
                                                                           ^
net/smc/smc_ism.c:27:76: note: Function 'smc_ism_cantalk' argument 3 names different: declaration 'dev' definition 'smcd'.
int smc_ism_cantalk(u64 peer_gid, unsigned short vlan_id, struct smcd_dev *smcd)
                                                                           ^
net/smc/smc_ism.c:33:36: style:inconclusive: Function 'smc_ism_write' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
int smc_ism_write(struct smcd_dev *smcd, const struct smc_ism_position *pos,
                                   ^
net/smc/smc_ism.h:50:36: note: Function 'smc_ism_write' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_write(struct smcd_dev *dev, const struct smc_ism_position *pos,
                                   ^
net/smc/smc_ism.c:33:36: note: Function 'smc_ism_write' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_write(struct smcd_dev *smcd, const struct smc_ism_position *pos,
                                   ^
net/smc/smc_ism.c:44:46: style:inconclusive: Function 'smc_ism_get_system_eid' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
void smc_ism_get_system_eid(struct smcd_dev *smcd, u8 **eid)
                                             ^
net/smc/smc_ism.h:53:46: note: Function 'smc_ism_get_system_eid' argument 1 names different: declaration 'dev' definition 'smcd'.
void smc_ism_get_system_eid(struct smcd_dev *dev, u8 **eid);
                                             ^
net/smc/smc_ism.c:44:46: note: Function 'smc_ism_get_system_eid' argument 1 names different: declaration 'dev' definition 'smcd'.
void smc_ism_get_system_eid(struct smcd_dev *smcd, u8 **eid)
                                             ^
net/smc/smc_ism.c:49:39: style:inconclusive: Function 'smc_ism_get_chid' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
u16 smc_ism_get_chid(struct smcd_dev *smcd)
                                      ^
net/smc/smc_ism.h:54:39: note: Function 'smc_ism_get_chid' argument 1 names different: declaration 'dev' definition 'smcd'.
u16 smc_ism_get_chid(struct smcd_dev *dev);
                                      ^
net/smc/smc_ism.c:49:39: note: Function 'smc_ism_get_chid' argument 1 names different: declaration 'dev' definition 'smcd'.
u16 smc_ism_get_chid(struct smcd_dev *smcd)
                                      ^
net/smc/smc_ism.c:81:39: style:inconclusive: Function 'smc_ism_get_vlan' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
int smc_ism_get_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                      ^
net/smc/smc_ism.h:45:39: note: Function 'smc_ism_get_vlan' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_get_vlan(struct smcd_dev *dev, unsigned short vlan_id);
                                      ^
net/smc/smc_ism.c:81:39: note: Function 'smc_ism_get_vlan' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_get_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                      ^
net/smc/smc_ism.c:81:60: style:inconclusive: Function 'smc_ism_get_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'. [funcArgNamesDifferent]
int smc_ism_get_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                                           ^
net/smc/smc_ism.h:45:59: note: Function 'smc_ism_get_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'.
int smc_ism_get_vlan(struct smcd_dev *dev, unsigned short vlan_id);
                                                          ^
net/smc/smc_ism.c:81:60: note: Function 'smc_ism_get_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'.
int smc_ism_get_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                                           ^
net/smc/smc_ism.c:125:39: style:inconclusive: Function 'smc_ism_put_vlan' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
int smc_ism_put_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                      ^
net/smc/smc_ism.h:46:39: note: Function 'smc_ism_put_vlan' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_put_vlan(struct smcd_dev *dev, unsigned short vlan_id);
                                      ^
net/smc/smc_ism.c:125:39: note: Function 'smc_ism_put_vlan' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_put_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                      ^
net/smc/smc_ism.c:125:60: style:inconclusive: Function 'smc_ism_put_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'. [funcArgNamesDifferent]
int smc_ism_put_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                                           ^
net/smc/smc_ism.h:46:59: note: Function 'smc_ism_put_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'.
int smc_ism_put_vlan(struct smcd_dev *dev, unsigned short vlan_id);
                                                          ^
net/smc/smc_ism.c:125:60: note: Function 'smc_ism_put_vlan' argument 2 names different: declaration 'vlan_id' definition 'vlanid'.
int smc_ism_put_vlan(struct smcd_dev *smcd, unsigned short vlanid)
                                                           ^
net/smc/smc_ism.c:159:45: style:inconclusive: Function 'smc_ism_unregister_dmb' argument 1 names different: declaration 'dev' definition 'smcd'. [funcArgNamesDifferent]
int smc_ism_unregister_dmb(struct smcd_dev *smcd, struct smc_buf_desc *dmb_desc)
                                            ^
net/smc/smc_ism.h:49:45: note: Function 'smc_ism_unregister_dmb' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_unregister_dmb(struct smcd_dev *dev, struct smc_buf_desc *dmb_desc);
                                            ^
net/smc/smc_ism.c:159:45: note: Function 'smc_ism_unregister_dmb' argument 1 names different: declaration 'dev' definition 'smcd'.
int smc_ism_unregister_dmb(struct smcd_dev *smcd, struct smc_buf_desc *dmb_desc)
                                            ^
net/smc/smc_ism.c:182:58: style:inconclusive: Function 'smc_ism_register_dmb' argument 2 names different: declaration 'buf_size' definition 'dmb_len'. [funcArgNamesDifferent]
int smc_ism_register_dmb(struct smc_link_group *lgr, int dmb_len,
                                                         ^
net/smc/smc_ism.h:47:58: note: Function 'smc_ism_register_dmb' argument 2 names different: declaration 'buf_size' definition 'dmb_len'.
int smc_ism_register_dmb(struct smc_link_group *lgr, int buf_size,
                                                         ^
net/smc/smc_ism.c:182:58: note: Function 'smc_ism_register_dmb' argument 2 names different: declaration 'buf_size' definition 'dmb_len'.
int smc_ism_register_dmb(struct smc_link_group *lgr, int dmb_len,
                                                         ^
net/smc/smc_llc.c:174:25: style: The scope of the variable 'qentry' can be reduced. [variableScope]
 struct smc_llc_qentry *qentry;
                        ^
net/smc/smc_llc.c:628:23: style: The scope of the variable 'buf_pos' can be reduced. [variableScope]
 struct smc_buf_desc *buf_pos;
                      ^
net/smc/smc_llc.c:672:23: style: The scope of the variable 'rmb' can be reduced. [variableScope]
 struct smc_buf_desc *rmb;
                      ^
net/smc/smc_llc.c:378:48: style:inconclusive: Function 'smc_llc_send_confirm_link' argument 1 names different: declaration 'lnk' definition 'link'. [funcArgNamesDifferent]
int smc_llc_send_confirm_link(struct smc_link *link,
                                               ^
net/smc/smc_llc.h:72:48: note: Function 'smc_llc_send_confirm_link' argument 1 names different: declaration 'lnk' definition 'link'.
int smc_llc_send_confirm_link(struct smc_link *lnk,
                                               ^
net/smc/smc_llc.c:378:48: note: Function 'smc_llc_send_confirm_link' argument 1 names different: declaration 'lnk' definition 'link'.
int smc_llc_send_confirm_link(struct smc_link *link,
                                               ^
net/smc/smc_llc.c:776:6: style: Variable 'rc' is assigned a value that is never used. [unreadVariable]
  rc = smc_llc_send_delete_link(link, link_new->link_id,
     ^
net/smc/smc_pnet.c:1149:47: style:inconclusive: Function 'smc_pnetid_by_table_smcd' argument 1 names different: declaration 'smcd' definition 'smcddev'. [funcArgNamesDifferent]
int smc_pnetid_by_table_smcd(struct smcd_dev *smcddev)
                                              ^
net/smc/smc_pnet.h:64:47: note: Function 'smc_pnetid_by_table_smcd' argument 1 names different: declaration 'smcd' definition 'smcddev'.
int smc_pnetid_by_table_smcd(struct smcd_dev *smcd);
                                              ^
net/smc/smc_pnet.c:1149:47: note: Function 'smc_pnetid_by_table_smcd' argument 1 names different: declaration 'smcd' definition 'smcddev'.
int smc_pnetid_by_table_smcd(struct smcd_dev *smcddev)
                                              ^
net/smc/smc_rx.c:226:42: style: Redundant condition: If 'EXPR == 3', the comparison '!(EXPR == 1)' is always true. [redundantCondition]
     !(conn->urg_state == SMC_URG_VALID) ||
                                         ^
net/smc/smc_rx.c:59:6: style: The scope of the variable 'diff' can be reduced. [variableScope]
 int diff, rc = 0;
     ^
net/smc/smc_rx.c:223:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc = 0;
     ^
net/smc/smc_rx.c:307:29: portability: 'conn->rmb_desc->cpu_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 rcvbuf_base = conn->rx_off + conn->rmb_desc->cpu_addr;
                            ^
net/smc/smc_tx.c:319:6: style: The scope of the variable 'num_sges' can be reduced. [variableScope]
 int num_sges;
     ^
net/smc/smc_tx.c:320:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/smc/smc_tx.c:370:45: portability: 'conn->sndbuf_desc->cpu_addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
   void *data = conn->sndbuf_desc->cpu_addr + src_off;
                                            ^
net/smc/smc_wr.c:90:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/smc/smc_wr.c:355:24: style: The scope of the variable 'wr_tx' can be reduced. [variableScope]
 struct smc_wr_rx_hdr *wr_tx;
                       ^
net/smc/smc_wr.c:413:19: style: The scope of the variable 'link' can be reduced. [variableScope]
 struct smc_link *link;
                  ^
net/smc/smc_wr.c:196:29: style:inconclusive: Function 'smc_wr_tx_get_free_slot' argument 4 names different: declaration 'wrs' definition 'wr_rdma_buf'. [funcArgNamesDifferent]
       struct smc_rdma_wr **wr_rdma_buf,
                            ^
net/smc/smc_wr.h:98:29: note: Function 'smc_wr_tx_get_free_slot' argument 4 names different: declaration 'wrs' definition 'wr_rdma_buf'.
       struct smc_rdma_wr **wrs,
                            ^
net/smc/smc_wr.c:196:29: note: Function 'smc_wr_tx_get_free_slot' argument 4 names different: declaration 'wrs' definition 'wr_rdma_buf'.
       struct smc_rdma_wr **wr_rdma_buf,
                            ^
net/smc/smc_wr.c:267:71: style:inconclusive: Function 'smc_wr_tx_send' argument 2 names different: declaration 'wr_pend_priv' definition 'priv'. [funcArgNamesDifferent]
int smc_wr_tx_send(struct smc_link *link, struct smc_wr_tx_pend_priv *priv)
                                                                      ^
net/smc/smc_wr.h:103:34: note: Function 'smc_wr_tx_send' argument 2 names different: declaration 'wr_pend_priv' definition 'priv'.
     struct smc_wr_tx_pend_priv *wr_pend_priv);
                                 ^
net/smc/smc_wr.c:267:71: note: Function 'smc_wr_tx_send' argument 2 names different: declaration 'wr_pend_priv' definition 'priv'.
int smc_wr_tx_send(struct smc_link *link, struct smc_wr_tx_pend_priv *priv)
                                                                      ^
net/smc/smc_wr.c:349:47: style:inconclusive: Function 'smc_wr_tx_dismiss_slots' argument 1 names different: declaration 'lnk' definition 'link'. [funcArgNamesDifferent]
void smc_wr_tx_dismiss_slots(struct smc_link *link, u8 wr_tx_hdr_type,
                                              ^
net/smc/smc_wr.h:107:47: note: Function 'smc_wr_tx_dismiss_slots' argument 1 names different: declaration 'lnk' definition 'link'.
void smc_wr_tx_dismiss_slots(struct smc_link *lnk, u8 wr_rx_hdr_type,
                                              ^
net/smc/smc_wr.c:349:47: note: Function 'smc_wr_tx_dismiss_slots' argument 1 names different: declaration 'lnk' definition 'link'.
void smc_wr_tx_dismiss_slots(struct smc_link *link, u8 wr_tx_hdr_type,
                                              ^
net/smc/smc_wr.c:349:56: style:inconclusive: Function 'smc_wr_tx_dismiss_slots' argument 2 names different: declaration 'wr_rx_hdr_type' definition 'wr_tx_hdr_type'. [funcArgNamesDifferent]
void smc_wr_tx_dismiss_slots(struct smc_link *link, u8 wr_tx_hdr_type,
                                                       ^
net/smc/smc_wr.h:107:55: note: Function 'smc_wr_tx_dismiss_slots' argument 2 names different: declaration 'wr_rx_hdr_type' definition 'wr_tx_hdr_type'.
void smc_wr_tx_dismiss_slots(struct smc_link *lnk, u8 wr_rx_hdr_type,
                                                      ^
net/smc/smc_wr.c:349:56: note: Function 'smc_wr_tx_dismiss_slots' argument 2 names different: declaration 'wr_rx_hdr_type' definition 'wr_tx_hdr_type'.
void smc_wr_tx_dismiss_slots(struct smc_link *link, u8 wr_tx_hdr_type,
                                                       ^
net/smc/smc_wr.c:614:44: style:inconclusive: Function 'smc_wr_alloc_link_mem' argument 1 names different: declaration 'lnk' definition 'link'. [funcArgNamesDifferent]
int smc_wr_alloc_link_mem(struct smc_link *link)
                                           ^
net/smc/smc_wr.h:89:44: note: Function 'smc_wr_alloc_link_mem' argument 1 names different: declaration 'lnk' definition 'link'.
int smc_wr_alloc_link_mem(struct smc_link *lnk);
                                           ^
net/smc/smc_wr.c:614:44: note: Function 'smc_wr_alloc_link_mem' argument 1 names different: declaration 'lnk' definition 'link'.
int smc_wr_alloc_link_mem(struct smc_link *link)
                                           ^
net/socket.c:533:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  buffer += len;
  ^
net/socket.c:2401:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 msg_sys->msg_name = &address;
 ^
net/socket.c:2563:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 msg_sys->msg_name = &addr;
 ^
net/socket.c:1128:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = f_setown(sock->file, pid, 1);
       ^
net/socket.c:1125:8: note: err is assigned
   err = -EFAULT;
       ^
net/socket.c:1128:8: note: err is overwritten
   err = f_setown(sock->file, pid, 1);
       ^
net/socket.c:1175:8: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
   err = open_related_ns(&net->ns, get_net_ns);
       ^
net/socket.c:1171:8: note: err is assigned
   err = -EPERM;
       ^
net/socket.c:1175:8: note: err is overwritten
   err = open_related_ns(&net->ns, get_net_ns);
       ^
net/socket.c:497:17: style: The scope of the variable 'sock' can be reduced. [variableScope]
 struct socket *sock;
                ^
net/socket.c:1680:6: style: The scope of the variable 'somaxconn' can be reduced. [variableScope]
 int somaxconn;
     ^
net/socket.c:2233:10: style: The scope of the variable 'err' can be reduced. [variableScope]
 ssize_t err;
         ^
net/socket.c:1275:57: style:inconclusive: Function 'sock_close' argument 2 names different: declaration 'file' definition 'filp'. [funcArgNamesDifferent]
static int sock_close(struct inode *inode, struct file *filp)
                                                        ^
net/socket.c:117:57: note: Function 'sock_close' argument 2 names different: declaration 'file' definition 'filp'.
static int sock_close(struct inode *inode, struct file *file);
                                                        ^
net/socket.c:1275:57: note: Function 'sock_close' argument 2 names different: declaration 'file' definition 'filp'.
static int sock_close(struct inode *inode, struct file *filp)
                                                        ^
net/strparser/strparser.c:104:20: style: The scope of the variable 'cand_len' can be reduced. [variableScope]
 size_t eaten = 0, cand_len;
                   ^
net/strparser/strparser.c:105:10: style: The scope of the variable 'extra' can be reduced. [variableScope]
 ssize_t extra;
         ^
net/strparser/strparser.c:40:46: portability: '(void*)skb->cb' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 return (struct _strp_msg *)((void *)skb->cb +
                                             ^
net/sunrpc/addr.c:290:6: warning: %u in format string (no. 1) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 if (snprintf(portbuf, sizeof(portbuf),
     ^
net/sunrpc/addr.c:290:6: warning: %u in format string (no. 2) requires 'unsigned int' but the argument type is 'signed int'. [invalidPrintfArgType_uint]
 if (snprintf(portbuf, sizeof(portbuf),
     ^
net/sunrpc/auth.c:835:8: warning: Either the condition 'cred==NULL' is redundant or there is possible null pointer dereference: cred. [nullPointerRedundantCheck]
 err = cred->cr_ops->crrefresh(task);
       ^
net/sunrpc/auth.c:828:11: note: Assuming that condition 'cred==NULL' is not redundant
 if (cred == NULL) {
          ^
net/sunrpc/auth.c:835:8: note: Null pointer dereference
 err = cred->cr_ops->crrefresh(task);
       ^
net/sunrpc/auth.c:384:21: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct hlist_head *head;
                    ^
net/sunrpc/auth_gss/auth_gss.c:521:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/sunrpc/auth_gss/auth_gss.c:1283:19: style: The scope of the variable 'task' can be reduced. [variableScope]
 struct rpc_task *task;
                  ^
net/sunrpc/auth_gss/gss_generic_token.c:230:9: warning: Identical condition and return expression 'ret', return value is always 0 [identicalConditionAfterEarlyExit]
 return ret;
        ^
net/sunrpc/auth_gss/gss_generic_token.c:222:6: note: If condition 'ret' is true, the function will return/exit
 if (ret)
     ^
net/sunrpc/auth_gss/gss_generic_token.c:230:9: note: Returning identical expression 'ret'
 return ret;
        ^
net/sunrpc/auth_gss/gss_generic_token.c:225:6: style: Condition '!ret' is always true [knownConditionTrueFalse]
 if (!ret) {
     ^
net/sunrpc/auth_gss/gss_generic_token.c:222:6: note: Assuming that condition 'ret' is not redundant
 if (ret)
     ^
net/sunrpc/auth_gss/gss_generic_token.c:225:6: note: Condition '!ret' is always true
 if (!ret) {
     ^
net/sunrpc/auth_gss/gss_krb5_keys.c:77:15: style: The scope of the variable 'msbit' can be reduced. [variableScope]
 int byte, i, msbit;
              ^
net/sunrpc/auth_gss/gss_krb5_mech.c:254:38: warning: Invalid test for overflow 'p+20<p'. Condition is always false unless there is overflow, and overflow is undefined behaviour. [invalidTestForOverflow]
 if (unlikely(p + 20 > end || p + 20 < p)) {
                                     ^
net/sunrpc/auth_gss/gss_krb5_mech.c:254:17: portability: 'p' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 if (unlikely(p + 20 > end || p + 20 < p)) {
                ^
net/sunrpc/auth_gss/gss_krb5_mech.c:258:4: portability: 'p' is of type 'const void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 p += 20;
   ^
net/sunrpc/auth_gss/gss_krb5_seal.c:154:13: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memcpy(ptr + GSS_KRB5_TOK_HDR_LEN, md5cksum.data, md5cksum.len);
            ^
net/sunrpc/auth_gss/gss_krb5_seal.c:159:24: portability: 'ptr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
         seq_send, ptr + GSS_KRB5_TOK_HDR_LEN, ptr + 8))
                       ^
net/sunrpc/auth_gss/gss_krb5_seal.c:185:18: portability: 'krb5_hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memcpy(krb5_hdr + 8, (char *) &seq_send_be64, 8);
                 ^
net/sunrpc/auth_gss/gss_krb5_seal.c:199:18: portability: 'krb5_hdr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memcpy(krb5_hdr + GSS_KRB5_TOK_HDR_LEN, cksumobj.data, cksumobj.len);
                 ^
net/sunrpc/auth_gss/gss_krb5_wrap.c:374:15: style: The scope of the variable 'this_len' can be reduced. [variableScope]
 unsigned int this_len, i;
              ^
net/sunrpc/auth_gss/gss_krb5_wrap.c:390:6: style: The scope of the variable 'this_shift' can be reduced. [variableScope]
 int this_shift;
     ^
net/sunrpc/auth_gss/gss_mech_switch.c:35:18: style: The scope of the variable 'pf' can be reduced. [variableScope]
 struct pf_desc *pf;
                 ^
net/sunrpc/auth_gss/gss_rpc_xdr.c:372:6: style: Variable 'err' is reassigned a value before the old one has been used. [redundantAssignment]
 err = gssx_enc_option(xdr, &opt);
     ^
net/sunrpc/auth_gss/gss_rpc_xdr.c:365:6: note: err is assigned
 err = gssx_enc_option(xdr, &opt);
     ^
net/sunrpc/auth_gss/gss_rpc_xdr.c:372:6: note: err is overwritten
 err = gssx_enc_option(xdr, &opt);
     ^
net/sunrpc/auth_gss/svcauth_gss.c:1423:2: style: Non-boolean value returned from function returning bool [returnNonBoolInBooleanFunction]
 return sn->use_gss_proxy;
 ^
net/sunrpc/auth_gss/svcauth_gss.c:1282:9: style: Redundant initialization for 'status'. The initialized value is overwritten before it is read. [redundantInitialization]
 status = -ENOMEM;
        ^
net/sunrpc/auth_gss/svcauth_gss.c:1278:13: note: status is initialized
 int status = -EINVAL;
            ^
net/sunrpc/auth_gss/svcauth_gss.c:1282:9: note: status is overwritten
 status = -ENOMEM;
        ^
net/sunrpc/auth_gss/svcauth_gss.c:1318:10: style: Variable 'status' is reassigned a value before the old one has been used. [redundantAssignment]
  status = gss_import_sec_context(ud->out_handle.data,
         ^
net/sunrpc/auth_gss/svcauth_gss.c:1316:10: note: status is assigned
  status = -EINVAL;
         ^
net/sunrpc/auth_gss/svcauth_gss.c:1318:10: note: status is overwritten
  status = gss_import_sec_context(ud->out_handle.data,
         ^
net/sunrpc/auth_gss/svcauth_gss.c:1150:23: style: The scope of the variable 'pgto_offs' can be reduced. [variableScope]
 unsigned int length, pgto_offs, pgfrom_offs;
                      ^
net/sunrpc/auth_gss/svcauth_gss.c:1150:34: style: The scope of the variable 'pgfrom_offs' can be reduced. [variableScope]
 unsigned int length, pgto_offs, pgfrom_offs;
                                 ^
net/sunrpc/auth_gss/svcauth_gss.c:1151:21: style: The scope of the variable 'pgto' can be reduced. [variableScope]
 int pages, i, res, pgto, pgfrom;
                    ^
net/sunrpc/auth_gss/svcauth_gss.c:1151:27: style: The scope of the variable 'pgfrom' can be reduced. [variableScope]
 int pages, i, res, pgto, pgfrom;
                          ^
net/sunrpc/cache.c:472:36: warning:inconclusive: Possible null pointer dereference: ch [nullPointer]
   if (current_detail->nextcheck > ch->expiry_time)
                                   ^
net/sunrpc/cache.c:461:27: note: Assignment 'ch=NULL', assigned value is 0
  struct cache_head *ch = NULL;
                          ^
net/sunrpc/cache.c:472:36: note: Null pointer dereference
   if (current_detail->nextcheck > ch->expiry_time)
                                   ^
net/sunrpc/cache.c:1357:13: style: Variable 'entry' is assigned a value that is never used. [unreadVariable]
  if (!entry--)
            ^
net/sunrpc/clnt.c:150:17: style: The scope of the variable 'dentry' can be reduced. [variableScope]
 struct dentry *dentry;
                ^
net/sunrpc/rpcb_clnt.c:385:2: error: Address of local auto-variable assigned to a function parameter. [autoVariables]
 msg->rpc_resp = &result;
 ^
net/sunrpc/sched.c:156:20: style: The scope of the variable 'q' can be reduced. [variableScope]
 struct list_head *q;
                   ^
net/sunrpc/sched.c:742:30: style: The scope of the variable 'timeo' can be reduced. [variableScope]
 unsigned long expires, now, timeo;
                             ^
net/sunrpc/stats.c:85:28: style: The scope of the variable 'vers' can be reduced. [variableScope]
 const struct svc_version *vers;
                           ^
net/sunrpc/stats.c:122:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/sunrpc/svc.c:710:19: style: The scope of the variable 'rqstp' can be reduced. [variableScope]
 struct svc_rqst *rqstp;
                  ^
net/sunrpc/svc.c:712:19: style: The scope of the variable 'chosen_pool' can be reduced. [variableScope]
 struct svc_pool *chosen_pool;
                  ^
net/sunrpc/svc.c:714:6: style: The scope of the variable 'node' can be reduced. [variableScope]
 int node;
     ^
net/sunrpc/svc.c:750:22: style: The scope of the variable 'task' can be reduced. [variableScope]
 struct task_struct *task;
                     ^
net/sunrpc/svc.c:803:22: style: The scope of the variable 'task' can be reduced. [variableScope]
 struct task_struct *task;
                     ^
net/sunrpc/svc.c:178:15: style: Checking if unsigned expression 'maxpools' is less than zero. [unsignedLessThanZero]
  BUG_ON(pidx >= maxpools);
              ^
net/sunrpc/svc.c:169:22: note: Assignment 'pidx=0', assigned value is 0
 unsigned int pidx = 0;
                     ^
net/sunrpc/svc.c:174:6: note: Assuming condition is false
 if (err)
     ^
net/sunrpc/svc.c:178:15: note: Unsigned less than zero
  BUG_ON(pidx >= maxpools);
              ^
net/sunrpc/svc.c:207:15: style: Checking if unsigned expression 'maxpools' is less than zero. [unsignedLessThanZero]
  BUG_ON(pidx > maxpools);
              ^
net/sunrpc/svc.c:197:22: note: Assignment 'pidx=0', assigned value is 0
 unsigned int pidx = 0;
                     ^
net/sunrpc/svc.c:202:6: note: Assuming condition is false
 if (err)
     ^
net/sunrpc/svc.c:207:15: note: Unsigned less than zero
  BUG_ON(pidx > maxpools);
              ^
net/sunrpc/svc_xprt.c:1330:6: style: The scope of the variable 'len' can be reduced. [variableScope]
 int len, totlen;
     ^
net/sunrpc/svcauth.c:115:19: style: The scope of the variable 'old' can be reduced. [variableScope]
 struct auth_ops *old;
                  ^
net/sunrpc/svcauth_unix.c:348:21: style: The scope of the variable 'sn' can be reduced. [variableScope]
 struct sunrpc_net *sn;
                    ^
net/sunrpc/svcauth_unix.c:214:20: style: Variable 'sin6.sin6_family' is assigned a value that is never used. [unreadVariable]
  sin6.sin6_family = AF_INET6;
                   ^
net/sunrpc/svcauth_unix.c:295:12: style: Variable 'ip.m_addr' is assigned a value that is never used. [unreadVariable]
 ip.m_addr = *addr;
           ^
net/sunrpc/svcauth_unix.c:321:14: style: Variable 'ip.m_client' is assigned a value that is never used. [unreadVariable]
 ip.m_client = udom;
             ^
net/sunrpc/svcauth_unix.c:632:9: style: Variable 'ug.uid' is assigned a value that is never used. [unreadVariable]
 ug.uid = uid;
        ^
net/sunrpc/svcsock.c:439:9: style: union member 'Anonymous0::all' is never used. [unusedStructMember]
  long  all[SVC_PKTINFO_SPACE / sizeof(long)];
        ^
net/sunrpc/svcsock.c:558:9: style: union member 'Anonymous1::all' is never used. [unusedStructMember]
  long  all[SVC_PKTINFO_SPACE / sizeof(long)];
        ^
net/sunrpc/xdr.c:148:9: style: The scope of the variable 'i' can be reduced. [variableScope]
 size_t i, n = xdr_buf_pagecount(buf);
        ^
net/sunrpc/xdr.c:226:16: style: The scope of the variable 'vto' can be reduced. [variableScope]
 char *vfrom, *vto;
               ^
net/sunrpc/xdr.c:308:16: style: The scope of the variable 'vto' can be reduced. [variableScope]
 char *vfrom, *vto;
               ^
net/sunrpc/xdr.c:360:9: style: The scope of the variable 'copy' can be reduced. [variableScope]
 size_t copy;
        ^
net/sunrpc/xdr.c:408:8: style: The scope of the variable 'vto' can be reduced. [variableScope]
 char *vto;
       ^
net/sunrpc/xdr.c:409:9: style: The scope of the variable 'copy' can be reduced. [variableScope]
 size_t copy;
        ^
net/sunrpc/xdr.c:452:8: style: The scope of the variable 'vfrom' can be reduced. [variableScope]
 char *vfrom;
       ^
net/sunrpc/xdr.c:488:8: style: The scope of the variable 'vpage' can be reduced. [variableScope]
 char *vpage;
       ^
net/sunrpc/xdr.c:523:15: style: The scope of the variable 'offs' can be reduced. [variableScope]
 size_t copy, offs;
              ^
net/sunrpc/xdr.c:809:6: style: The scope of the variable 'thislen' can be reduced. [variableScope]
 int thislen;
     ^
net/sunrpc/xdr.c:1181:15: style: The scope of the variable 'copied' can be reduced. [variableScope]
 unsigned int copied, offset;
              ^
net/sunrpc/xdr.c:1181:23: style: The scope of the variable 'offset' can be reduced. [variableScope]
 unsigned int copied, offset;
                      ^
net/sunrpc/xdr.c:1265:15: style: The scope of the variable 'shift' can be reduced. [variableScope]
 unsigned int shift = 0;
              ^
net/sunrpc/xdr.c:715:21: portability: 'page' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memmove(page, page + shift, (void *)xdr->p - page);
                    ^
net/sunrpc/xdr.c:753:21: portability: '(void*)p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 xdr->p = (void *)p + frag2bytes;
                    ^
net/sunrpc/xdr.c:755:23: portability: '(void*)p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 xdr->end = (void *)p + min_t(int, space_left, PAGE_SIZE);
                      ^
net/sunrpc/xdr.c:893:29: portability: '(void*)xdr->p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  xdr->end = (void *)xdr->p + PAGE_SIZE;
                            ^
net/sunrpc/xdr.c:894:27: portability: '(void*)xdr->p' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  xdr->p = (void *)xdr->p + (new % PAGE_SIZE);
                          ^
net/sunrpc/xdr.c:932:31: portability: '(void*)xdr->end' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  xdr->end = (void *)xdr->end + newbuflen - end_offset;
                              ^
net/sunrpc/xdr.c:932:43: portability: '(void*)xdr->end+newbuflen' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  xdr->end = (void *)xdr->end + newbuflen - end_offset;
                                          ^
net/sunrpc/xdr.c:1007:27: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 xdr->p = (__be32*)(kaddr + pgoff);
                          ^
net/sunrpc/xdr.c:1012:29: portability: 'kaddr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 xdr->end = (__be32*)(kaddr + pgend);
                            ^
net/sunrpc/xdr.c:1479:6: portability: 'obj' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 obj += this_len;
     ^
net/sunrpc/xdr.c:1484:6: portability: 'obj' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 obj += this_len;
     ^
net/sunrpc/xdr.c:1510:6: portability: 'obj' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 obj += this_len;
     ^
net/sunrpc/xdr.c:1515:6: portability: 'obj' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 obj += this_len;
     ^
net/sunrpc/xdr.c:1265:21: style: Variable 'shift' is assigned a value that is never used. [unreadVariable]
 unsigned int shift = 0;
                    ^
net/sunrpc/xprt.c:924:19: style: The scope of the variable 'req' can be reduced. [variableScope]
 struct rpc_rqst *req;
                  ^
net/sunrpc/xprt.c:947:19: style: The scope of the variable 'req' can be reduced. [variableScope]
 struct rpc_rqst *req;
                  ^
net/sunrpc/xprt.c:1514:19: style: The scope of the variable 'next' can be reduced. [variableScope]
 struct rpc_rqst *next, *req = task->tk_rqstp;
                  ^
net/sunrpc/xprt.c:1516:15: style: The scope of the variable 'status' can be reduced. [variableScope]
 int counter, status;
              ^
net/sunrpc/xprtmultipath.c:335:15: style: The scope of the variable 'nactive' can be reduced. [variableScope]
 unsigned int nactive;
              ^
net/sunrpc/xprtrdma/frwr_ops.c:171:24: style: The scope of the variable 'delta' can be reduced. [variableScope]
 int max_qp_wr, depth, delta;
                       ^
net/sunrpc/xprtrdma/rpc_rdma.c:270:3: warning: Assignment of function parameter has no effect outside the function. Did you forget dereferencing it? [uselessAssignmentPtrArg]
  seg = rpcrdma_convert_kvec(&xdrbuf->tail[0], seg, &n);
  ^
net/sunrpc/xprtrdma/rpc_rdma.c:135:15: style: The scope of the variable 'count' can be reduced. [variableScope]
 unsigned int count, remaining, offset;
              ^
net/sunrpc/xprtrdma/rpc_rdma.c:135:22: style: The scope of the variable 'remaining' can be reduced. [variableScope]
 unsigned int count, remaining, offset;
                     ^
net/sunrpc/xprtrdma/rpc_rdma.c:135:33: style: The scope of the variable 'offset' can be reduced. [variableScope]
 unsigned int count, remaining, offset;
                                ^
net/sunrpc/xprtrdma/rpc_rdma.c:680:15: style: The scope of the variable 'len' can be reduced. [variableScope]
 unsigned int len, page_base, remaining;
              ^
net/sunrpc/xprtrdma/rpc_rdma.c:682:17: style: The scope of the variable 'src' can be reduced. [variableScope]
 unsigned char *src, *dst;
                ^
net/sunrpc/xprtrdma/rpc_rdma.c:1037:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i, npages, curlen;
     ^
net/sunrpc/xprtrdma/rpc_rdma.c:1037:9: style: The scope of the variable 'npages' can be reduced. [variableScope]
 int i, npages, curlen;
        ^
net/sunrpc/xprtrdma/rpc_rdma.c:1038:8: style: The scope of the variable 'destp' can be reduced. [variableScope]
 char *destp;
       ^
net/sunrpc/xprtrdma/rpc_rdma.c:270:7: style: Variable 'seg' is assigned a value that is never used. [unreadVariable]
  seg = rpcrdma_convert_kvec(&xdrbuf->tail[0], seg, &n);
      ^
net/sunrpc/xprtrdma/svc_rdma_recvfrom.c:183:29: style: The scope of the variable 'ctxt' can be reduced. [variableScope]
 struct svc_rdma_recv_ctxt *ctxt;
                            ^
net/sunrpc/xprtrdma/svc_rdma_recvfrom.c:292:29: style: The scope of the variable 'ctxt' can be reduced. [variableScope]
 struct svc_rdma_recv_ctxt *ctxt;
                            ^
net/sunrpc/xprtrdma/svc_rdma_recvfrom.c:294:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/sunrpc/xprtrdma/svc_rdma_rw.c:407:23: style: The scope of the variable 'sge_bytes' can be reduced. [variableScope]
 unsigned int sge_no, sge_bytes, page_off, page_no;
                      ^
net/sunrpc/xprtrdma/svc_rdma_sendto.c:631:16: style: The scope of the variable 'len' can be reduced. [variableScope]
  unsigned int len, remaining;
               ^
net/sunrpc/xprtrdma/verbs.c:916:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
net/sunrpc/xprtrdma/verbs.c:1429:24: style: Local variable 'rep' shadows outer variable [shadowVariable]
   struct rpcrdma_rep *rep;
                       ^
net/sunrpc/xprtrdma/verbs.c:1388:22: note: Shadowed declaration
 struct rpcrdma_rep *rep;
                     ^
net/sunrpc/xprtrdma/verbs.c:1429:24: note: Shadow variable
   struct rpcrdma_rep *rep;
                       ^
net/sunrpc/xprtsock.c:1643:25: style: The statement 'if (transport->srcport!=0) transport->srcport=0' is logically equivalent to 'transport->srcport=0'. [duplicateConditionalAssign]
 if (transport->srcport != 0)
                        ^
net/sunrpc/xprtsock.c:1644:22: note: Assignment 'transport->srcport=0'
  transport->srcport = 0;
                     ^
net/sunrpc/xprtsock.c:1643:25: note: Condition 'transport->srcport!=0' is redundant
 if (transport->srcport != 0)
                        ^
net/sunrpc/xprtsock.c:2246:9: style: Redundant initialization for 'status'. The initialized value is overwritten before it is read. [redundantInitialization]
 status = xs_tcp_finish_connecting(xprt, sock);
        ^
net/sunrpc/xprtsock.c:2228:13: note: status is initialized
 int status = -EIO;
            ^
net/sunrpc/xprtsock.c:2246:9: note: status is overwritten
 status = xs_tcp_finish_connecting(xprt, sock);
        ^
net/sunrpc/xprtsock.c:1656:17: style: The scope of the variable 'last' can be reduced. [variableScope]
 unsigned short last;
                ^
net/sunrpc/xprtsock.c:2121:16: style: The scope of the variable 'initval' can be reduced. [variableScope]
 unsigned long initval;
               ^
net/sunrpc/xprtsock.c:2910:15: style: Local variable 'max_slot_table_size' shadows outer variable [shadowVariable]
 unsigned int max_slot_table_size = xprt_max_tcp_slot_table_entries;
              ^
net/sunrpc/xprtsock.c:87:21: note: Shadowed declaration
static unsigned int max_slot_table_size = RPC_MAX_SLOT_TABLE;
                    ^
net/sunrpc/xprtsock.c:2910:15: note: Shadow variable
 unsigned int max_slot_table_size = xprt_max_tcp_slot_table_entries;
              ^
net/tipc/trace.h:206:3: error: syntax error: keyword 'if' is not allowed in global scope [syntaxError]
  if (skb)
  ^
net/tipc/msg.c:217:24: style: The scope of the variable 'curr' can be reduced. [variableScope]
 int accounted, total, curr;
                       ^
net/tipc/msg.c:218:6: style: The scope of the variable 'mlen' can be reduced. [variableScope]
 int mlen, cpy, rem = dlen;
     ^
net/tipc/msg.c:218:12: style: The scope of the variable 'cpy' can be reduced. [variableScope]
 int mlen, cpy, rem = dlen;
           ^
net/tipc/msg.c:685:24: style: The scope of the variable '_skb' can be reduced. [variableScope]
 struct sk_buff *skb, *_skb;
                       ^
net/tipc/msg.c:806:24: style: The scope of the variable '_skb' can be reduced. [variableScope]
 struct sk_buff *skb, *_skb;
                       ^
net/tipc/msg.c:85:24: style:inconclusive: Function 'tipc_msg_init' argument 1 names different: declaration 'own_addr' definition 'own_node'. [funcArgNamesDifferent]
void tipc_msg_init(u32 own_node, struct tipc_msg *m, u32 user, u32 type,
                       ^
net/tipc/msg.h:1182:24: note: Function 'tipc_msg_init' argument 1 names different: declaration 'own_addr' definition 'own_node'.
void tipc_msg_init(u32 own_addr, struct tipc_msg *m, u32 user, u32 type,
                       ^
net/tipc/msg.c:85:24: note: Function 'tipc_msg_init' argument 1 names different: declaration 'own_addr' definition 'own_node'.
void tipc_msg_init(u32 own_node, struct tipc_msg *m, u32 user, u32 type,
                       ^
net/tipc/msg.c:86:21: style:inconclusive: Function 'tipc_msg_init' argument 6 names different: declaration 'destnode' definition 'dnode'. [funcArgNamesDifferent]
     u32 hsize, u32 dnode)
                    ^
net/tipc/msg.h:1183:21: note: Function 'tipc_msg_init' argument 6 names different: declaration 'destnode' definition 'dnode'.
     u32 hsize, u32 destnode);
                    ^
net/tipc/msg.c:86:21: note: Function 'tipc_msg_init' argument 6 names different: declaration 'destnode' definition 'dnode'.
     u32 hsize, u32 dnode)
                    ^
net/tipc/msg.c:213:38: style:inconclusive: Function 'tipc_msg_append' argument 1 names different: declaration 'hdr' definition '_hdr'. [funcArgNamesDifferent]
int tipc_msg_append(struct tipc_msg *_hdr, struct msghdr *m, int dlen,
                                     ^
net/tipc/msg.h:1195:38: note: Function 'tipc_msg_append' argument 1 names different: declaration 'hdr' definition '_hdr'.
int tipc_msg_append(struct tipc_msg *hdr, struct msghdr *m, int dlen,
                                     ^
net/tipc/msg.c:213:38: note: Function 'tipc_msg_append' argument 1 names different: declaration 'hdr' definition '_hdr'.
int tipc_msg_append(struct tipc_msg *_hdr, struct msghdr *m, int dlen,
                                     ^
net/tipc/msg.c:380:19: style:inconclusive: Function 'tipc_msg_build' argument 5 names different: declaration 'mtu' definition 'pktmax'. [funcArgNamesDifferent]
     int dsz, int pktmax, struct sk_buff_head *list)
                  ^
net/tipc/msg.h:1194:31: note: Function 'tipc_msg_build' argument 5 names different: declaration 'mtu' definition 'pktmax'.
     int offset, int dsz, int mtu, struct sk_buff_head *list);
                              ^
net/tipc/msg.c:380:19: note: Function 'tipc_msg_build' argument 5 names different: declaration 'mtu' definition 'pktmax'.
     int dsz, int pktmax, struct sk_buff_head *list)
                  ^
net/tipc/msg.c:631:27: style:inconclusive: Function 'tipc_msg_reverse' argument 1 names different: declaration 'own_addr' definition 'own_node'. [funcArgNamesDifferent]
bool tipc_msg_reverse(u32 own_node,  struct sk_buff **skb, int err)
                          ^
net/tipc/msg.h:1179:27: note: Function 'tipc_msg_reverse' argument 1 names different: declaration 'own_addr' definition 'own_node'.
bool tipc_msg_reverse(u32 own_addr, struct sk_buff **skb, int err);
                          ^
net/tipc/msg.c:631:27: note: Function 'tipc_msg_reverse' argument 1 names different: declaration 'own_addr' definition 'own_node'.
bool tipc_msg_reverse(u32 own_node,  struct sk_buff **skb, int err)
                          ^
net/tipc/name_distr.c:158:7: style: Condition '!skb' is always true [knownConditionTrueFalse]
  if (!skb) {
      ^
net/tipc/name_distr.c:149:24: note: Assignment 'skb=NULL', assigned value is 0
 struct sk_buff *skb = NULL;
                       ^
net/tipc/name_distr.c:158:7: note: Condition '!skb' is always true
  if (!skb) {
      ^
net/tipc/name_distr.c:73:19: style: The scope of the variable 'msg' can be reduced. [variableScope]
 struct tipc_msg *msg;
                  ^
net/tipc/name_distr.c:374:21: style: The scope of the variable 'item' can be reduced. [variableScope]
 struct distr_item *item;
                    ^
net/tipc/name_distr.c:375:19: style: The scope of the variable 'hdr' can be reduced. [variableScope]
 struct tipc_msg *hdr;
                  ^
net/tipc/name_table.c:426:13: style: Condition '!first' is always true [knownConditionTrueFalse]
   else if (!first || publication_after(first, p))
            ^
net/tipc/name_table.c:422:11: note: Assignment 'first=NULL', assigned value is 0
  first = NULL;
          ^
net/tipc/name_table.c:426:13: note: Condition '!first' is always true
   else if (!first || publication_after(first, p))
            ^
net/tipc/name_table.c:1039:4: style: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
   if (!service)
   ^
net/tipc/name_table.c:177:24: style: The scope of the variable 'sr' can be reduced. [variableScope]
 struct service_range *sr;
                       ^
net/tipc/name_table.c:178:22: style: The scope of the variable 'r' can be reduced. [variableScope]
 struct rb_node *p, *r;
                     ^
net/tipc/name_table.c:1019:21: style: The scope of the variable 'head' can be reduced. [variableScope]
 struct hlist_head *head;
                    ^
net/tipc/name_table.c:461:15: style:inconclusive: Function 'tipc_nametbl_insert_publ' argument 7 names different: declaration 'ref' definition 'port'. [funcArgNamesDifferent]
          u32 port, u32 key)
              ^
net/tipc/name_table.h:132:25: note: Function 'tipc_nametbl_insert_publ' argument 7 names different: declaration 'ref' definition 'port'.
          u32 node, u32 ref, u32 key);
                        ^
net/tipc/name_table.c:461:15: note: Function 'tipc_nametbl_insert_publ' argument 7 names different: declaration 'ref' definition 'port'.
          u32 port, u32 key)
              ^
net/tipc/name_table.c:545:74: style:inconclusive: Function 'tipc_nametbl_translate' argument 4 names different: declaration 'node' definition 'dnode'. [funcArgNamesDifferent]
u32 tipc_nametbl_translate(struct net *net, u32 type, u32 instance, u32 *dnode)
                                                                         ^
net/tipc/name_table.h:115:74: note: Function 'tipc_nametbl_translate' argument 4 names different: declaration 'node' definition 'dnode'.
u32 tipc_nametbl_translate(struct net *net, u32 type, u32 instance, u32 *node);
                                                                         ^
net/tipc/name_table.c:545:74: note: Function 'tipc_nametbl_translate' argument 4 names different: declaration 'node' definition 'dnode'.
u32 tipc_nametbl_translate(struct net *net, u32 type, u32 instance, u32 *dnode)
                                                                         ^
net/tipc/name_table.c:601:71: style:inconclusive: Function 'tipc_nametbl_lookup' argument 4 names different: declaration 'domain' definition 'scope'. [funcArgNamesDifferent]
bool tipc_nametbl_lookup(struct net *net, u32 type, u32 instance, u32 scope,
                                                                      ^
net/tipc/name_table.h:122:71: note: Function 'tipc_nametbl_lookup' argument 4 names different: declaration 'domain' definition 'scope'.
bool tipc_nametbl_lookup(struct net *net, u32 type, u32 instance, u32 domain,
                                                                      ^
net/tipc/name_table.c:601:71: note: Function 'tipc_nametbl_lookup' argument 4 names different: declaration 'domain' definition 'scope'.
bool tipc_nametbl_lookup(struct net *net, u32 type, u32 instance, u32 scope,
                                                                      ^
net/tipc/name_table.c:696:24: style:inconclusive: Function 'tipc_nametbl_build_group' argument 4 names different: declaration 'domain' definition 'scope'. [funcArgNamesDifferent]
         u32 type, u32 scope)
                       ^
net/tipc/name_table.h:119:24: note: Function 'tipc_nametbl_build_group' argument 4 names different: declaration 'domain' definition 'scope'.
         u32 type, u32 domain);
                       ^
net/tipc/name_table.c:696:24: note: Function 'tipc_nametbl_build_group' argument 4 names different: declaration 'domain' definition 'scope'.
         u32 type, u32 scope)
                       ^
net/tipc/name_table.c:795:55: style:inconclusive: Function 'tipc_nametbl_subscribe' argument 1 names different: declaration 's' definition 'sub'. [funcArgNamesDifferent]
bool tipc_nametbl_subscribe(struct tipc_subscription *sub)
                                                      ^
net/tipc/name_table.h:136:55: note: Function 'tipc_nametbl_subscribe' argument 1 names different: declaration 's' definition 'sub'.
bool tipc_nametbl_subscribe(struct tipc_subscription *s);
                                                      ^
net/tipc/name_table.c:795:55: note: Function 'tipc_nametbl_subscribe' argument 1 names different: declaration 's' definition 'sub'.
bool tipc_nametbl_subscribe(struct tipc_subscription *sub)
                                                      ^
net/tipc/name_table.c:825:57: style:inconclusive: Function 'tipc_nametbl_unsubscribe' argument 1 names different: declaration 's' definition 'sub'. [funcArgNamesDifferent]
void tipc_nametbl_unsubscribe(struct tipc_subscription *sub)
                                                        ^
net/tipc/name_table.h:137:57: note: Function 'tipc_nametbl_unsubscribe' argument 1 names different: declaration 's' definition 'sub'.
void tipc_nametbl_unsubscribe(struct tipc_subscription *s);
                                                        ^
net/tipc/name_table.c:825:57: note: Function 'tipc_nametbl_unsubscribe' argument 1 names different: declaration 's' definition 'sub'.
void tipc_nametbl_unsubscribe(struct tipc_subscription *sub)
                                                        ^
net/tipc/netlink_compat.c:428:17: style: The scope of the variable 'prop' can be reduced. [variableScope]
 struct nlattr *prop;
                ^
net/tipc/topsrv.c:457:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/tipc/topsrv.c:680:20: style: The scope of the variable 'con' can be reduced. [variableScope]
 struct tipc_conn *con;
                   ^
net/tipc/topsrv.c:465:8: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
   ret = PTR_ERR(con);
       ^
net/tipc/udp_media.c:382:6: style: Condition 'b' is always true [knownConditionTrueFalse]
 if (b && test_bit(0, &b->up)) {
     ^
net/tipc/udp_media.c:379:6: note: Assuming that condition '!b' is not redundant
 if (!b)
     ^
net/tipc/udp_media.c:382:6: note: Condition 'b' is always true
 if (b && test_bit(0, &b->up)) {
     ^
net/tls/tls_device.c:276:14: style: The scope of the variable 'frag' can be reduced. [variableScope]
 skb_frag_t *frag;
             ^
net/tls/tls_device.c:364:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/tls/tls_device.c:398:8: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
  addr += pre_copy;
       ^
net/tls/tls_device.c:405:7: portability: 'addr' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 addr += nocache;
      ^
net/tls/tls_device_fallback.c:172:22: style: The scope of the variable 'iph' can be reduced. [variableScope]
 const struct iphdr *iph;
                     ^
net/tls/tls_device_fallback.c:303:12: portability: 'dummy_buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 dummy_buf += sync_size;
           ^
net/tls/tls_device_fallback.c:337:12: portability: 'buf' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 aad = buf + TLS_CIPHER_AES_GCM_128_SALT_SIZE +
           ^
net/tls/tls_device_fallback.c:339:18: portability: 'aad' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 dummy_buf = aad + TLS_AAD_SPACE_SIZE;
                 ^
net/tls/tls_main.c:107:10: style: Variable 'ret' is assigned a value that is never used. [unreadVariable]
 int ret = 0;
         ^
net/tls/tls_sw.c:104:33: style: Assignment of function parameter has no effect outside the function. [uselessAssignmentArg]
                                offset += chunk;
                                ^
net/tls/tls_sw.c:50:25: style: The scope of the variable 'frag_iter' can be reduced. [variableScope]
        struct sk_buff *frag_iter;
                        ^
net/tls/tls_sw.c:87:34: style: The scope of the variable 'ret' can be reduced. [variableScope]
                        int end, ret;
                                 ^
net/tls/tls_sw.c:130:7: style: The scope of the variable 'err' can be reduced. [variableScope]
  int err;
      ^
net/tls/tls_sw.c:159:22: style: The scope of the variable 'sg' can be reduced. [variableScope]
 struct scatterlist *sg;
                     ^
net/tls/tls_sw.c:161:15: style: The scope of the variable 'pages' can be reduced. [variableScope]
 unsigned int pages;
              ^
net/tls/tls_sw.c:1539:6: style: The scope of the variable 'pad' can be reduced. [variableScope]
 int pad, err = 0;
     ^
net/tls/tls_sw.c:1334:16: style: Variable 'i' is assigned a value that is never used. [unreadVariable]
 int rc = 0, i = 0, num_elem = *pages_used, maxpages;
               ^
net/unix/af_unix.c:1578:9: warning: Identical condition and return expression 'err', return value is always 0 [identicalConditionAfterEarlyExit]
 return err;
        ^
net/unix/af_unix.c:1571:6: note: If condition 'err' is true, the function will return/exit
 if (err)
     ^
net/unix/af_unix.c:1578:9: note: Returning identical expression 'err'
 return err;
        ^
net/unix/af_unix.c:793:2: warning: Either the condition 'sk==NULL' is redundant or there is possible null pointer dereference: sk. [nullPointerRedundantCheck]
 sk->sk_allocation = GFP_KERNEL_ACCOUNT;
 ^
net/unix/af_unix.c:810:9: note: Assuming that condition 'sk==NULL' is not redundant
 if (sk == NULL)
        ^
net/unix/af_unix.c:793:2: note: Null pointer dereference
 sk->sk_allocation = GFP_KERNEL_ACCOUNT;
 ^
net/unix/af_unix.c:794:2: warning: Either the condition 'sk==NULL' is redundant or there is possible null pointer dereference: sk. [nullPointerRedundantCheck]
 sk->sk_write_space = unix_write_space;
 ^
net/unix/af_unix.c:810:9: note: Assuming that condition 'sk==NULL' is not redundant
 if (sk == NULL)
        ^
net/unix/af_unix.c:794:2: note: Null pointer dereference
 sk->sk_write_space = unix_write_space;
 ^
net/unix/af_unix.c:795:2: warning: Either the condition 'sk==NULL' is redundant or there is possible null pointer dereference: sk. [nullPointerRedundantCheck]
 sk->sk_max_ack_backlog = net->unx.sysctl_max_dgram_qlen;
 ^
net/unix/af_unix.c:810:9: note: Assuming that condition 'sk==NULL' is not redundant
 if (sk == NULL)
        ^
net/unix/af_unix.c:795:2: note: Null pointer dereference
 sk->sk_max_ack_backlog = net->unx.sysctl_max_dgram_qlen;
 ^
net/unix/af_unix.c:796:2: warning: Either the condition 'sk==NULL' is redundant or there is possible null pointer dereference: sk. [nullPointerRedundantCheck]
 sk->sk_destruct  = unix_sock_destructor;
 ^
net/unix/af_unix.c:810:9: note: Assuming that condition 'sk==NULL' is not redundant
 if (sk == NULL)
        ^
net/unix/af_unix.c:796:2: note: Null pointer dereference
 sk->sk_destruct  = unix_sock_destructor;
 ^
net/unix/af_unix.c:2192:18: style: The scope of the variable 'tail' can be reduced. [variableScope]
 struct sk_buff *tail;
                 ^
net/unix/af_unix.c:2684:31: style: The scope of the variable 'other' can be reduced. [variableScope]
 struct sock *sk = sock->sk, *other;
                              ^
net/unix/af_unix.c:1954:30: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  err = flags & MSG_DONTWAIT ? -EAGAIN : -ERESTARTSYS;
                             ^
net/unix/diag.c:45:6: style: The scope of the variable 'ino' can be reduced. [variableScope]
 int ino;
     ^
net/vmw_vsock/af_vsock.c:2007:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/vmw_vsock/af_vsock_tap.c:82:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/vmw_vsock/virtio_transport.c:251:6: style: The scope of the variable 'ret' can be reduced. [variableScope]
 int ret;
     ^
net/vmw_vsock/virtio_transport_common.c:640:33: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  .flags = (mode & RCV_SHUTDOWN ?
                                ^
net/vmw_vsock/virtio_transport_common.c:642:27: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
    (mode & SEND_SHUTDOWN ?
                          ^
net/vmw_vsock/virtio_transport_common.c:343:10: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 int err = -EFAULT;
         ^
net/vmw_vsock/vmci_transport.c:1966:24: style: Condition 'PROTOCOL_OVERRIDE!=-1' is always false [knownConditionTrueFalse]
 if (PROTOCOL_OVERRIDE != -1) {
                       ^
net/vmw_vsock/vmci_transport.c:1967:25: style: Condition 'PROTOCOL_OVERRIDE==0' is always false [knownConditionTrueFalse]
  if (PROTOCOL_OVERRIDE == 0)
                        ^
net/vmw_vsock/vmci_transport.c:2011:24: style: Condition 'PROTOCOL_OVERRIDE!=-1' is always false [knownConditionTrueFalse]
 if (PROTOCOL_OVERRIDE != -1)
                       ^
net/vmw_vsock/vmci_transport.c:845:38: style:inconclusive: Function 'vmci_transport_peer_detach_cb' argument 2 names different: declaration 'ed' definition 'e_data'. [funcArgNamesDifferent]
       const struct vmci_event_data *e_data,
                                     ^
net/vmw_vsock/vmci_transport.c:35:38: note: Function 'vmci_transport_peer_detach_cb' argument 2 names different: declaration 'ed' definition 'e_data'.
       const struct vmci_event_data *ed,
                                     ^
net/vmw_vsock/vmci_transport.c:845:38: note: Function 'vmci_transport_peer_detach_cb' argument 2 names different: declaration 'ed' definition 'e_data'.
       const struct vmci_event_data *e_data,
                                     ^
net/vmw_vsock/vmci_transport.c:1130:52: style:inconclusive: Function 'vmci_transport_recv_connecting_server' argument 1 names different: declaration 'sk' definition 'listener'. [funcArgNamesDifferent]
vmci_transport_recv_connecting_server(struct sock *listener,
                                                   ^
net/vmw_vsock/vmci_transport.c:42:19: note: Function 'vmci_transport_recv_connecting_server' argument 1 names different: declaration 'sk' definition 'listener'.
     struct sock *sk,
                  ^
net/vmw_vsock/vmci_transport.c:1130:52: note: Function 'vmci_transport_recv_connecting_server' argument 1 names different: declaration 'sk' definition 'listener'.
vmci_transport_recv_connecting_server(struct sock *listener,
                                                   ^
net/vmw_vsock/vmci_transport_notify_qstate.c:262:7: style: The scope of the variable 'was_full' can be reduced. [variableScope]
 bool was_full = false;
      ^
net/vmw_vsock/vmci_transport_notify_qstate.c:262:16: style: Variable 'was_full' is assigned a value that is never used. [unreadVariable]
 bool was_full = false;
               ^
net/wimax/id-table.c:80:7: warning:inconclusive: Possible null pointer dereference: wimax_dev [nullPointer]
  if (wimax_dev->net_dev->ifindex == ifindex) {
      ^
net/wimax/id-table.c:75:32: note: Assignment 'wimax_dev=NULL', assigned value is 0
 struct wimax_dev *wimax_dev = NULL;
                               ^
net/wimax/id-table.c:80:7: note: Null pointer dereference
  if (wimax_dev->net_dev->ifindex == ifindex) {
      ^
net/wimax/id-table.c:123:2: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
 spin_lock(&wimax_id_table_lock);
 ^
net/wimax/op-msg.c:302:10: style: Redundant initialization for 'result'. The initialized value is overwritten before it is read. [redundantInitialization]
  result = PTR_ERR(skb);
         ^
net/wimax/op-msg.c:297:13: note: result is initialized
 int result = -ENOMEM;
            ^
net/wimax/op-msg.c:302:10: note: result is overwritten
  result = PTR_ERR(skb);
         ^
net/wireless/trace.h:3185:2: error: There is an unknown macro here somewhere. Configuration is required. If TP_fast_assign is a macro then please configure it. [unknownMacro]
 TP_fast_assign(
 ^
net/wireless/lib80211_crypt_tkip.c:218:9: style: The scope of the variable 'j' can be reduced. [variableScope]
 int i, j;
        ^
net/wireless/lib80211_crypt_tkip.c:669:8: style: Variable 'iv32' is assigned a value that is never used. [unreadVariable]
   iv32--;
       ^
net/wireless/lib80211_crypt_tkip.c:670:7: style: Variable 'iv16' is assigned a value that is never used. [unreadVariable]
  iv16--;
      ^
net/wireless/reg.c:783:0: information: Skipping configuration 'CONFIG_CFG80211_EXTRA_REGDB_KEYDIR;CONFIG_CFG80211_REQUIRE_SIGNED_REGDB' since the value of 'CONFIG_CFG80211_EXTRA_REGDB_KEYDIR' is unknown. Use -D if you want to check it. You can use -U to skip it explicitly. [ConfigurationNotChecked]
 if (CONFIG_CFG80211_EXTRA_REGDB_KEYDIR[0] != '\0')
^
net/wireless/wext-core.c:698:6: style: Condition '!handlers' is always true [knownConditionTrueFalse]
 if (!handlers)
     ^
net/wireless/wext-core.c:687:42: note: Assignment 'handlers=NULL', assigned value is 0
 const struct iw_handler_def *handlers = NULL;
                                         ^
net/wireless/wext-core.c:698:6: note: Condition '!handlers' is always true
 if (!handlers)
     ^
net/wireless/wext-core.c:1016:7: style: Redundant initialization for 'ret'. The initialized value is overwritten before it is read. [redundantInitialization]
  ret = handler(dev, info, &(iwr->u), NULL);
      ^
net/wireless/wext-core.c:1005:14: note: ret is initialized
 int     ret = -EINVAL;
             ^
net/wireless/wext-core.c:1016:7: note: ret is overwritten
  ret = handler(dev, info, &(iwr->u), NULL);
      ^
net/wireless/wext-core.c:347:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/wireless/wext-priv.c:199:7: style: Redundant initialization for 'ret'. The initialized value is overwritten before it is read. [redundantInitialization]
  ret = handler(dev, info, &(iwr->u), (char *) &(iwr->u));
      ^
net/wireless/wext-priv.c:191:26: note: ret is initialized
 int extra_size = 0, ret = -EINVAL;
                         ^
net/wireless/wext-priv.c:199:7: note: ret is overwritten
  ret = handler(dev, info, &(iwr->u), (char *) &(iwr->u));
      ^
net/wireless/wext-proc.c:102:10: style: Variable 'off' is assigned a value that is never used. [unreadVariable]
  if (off++ == *pos)
         ^
net/wireless/wext-sme.c:23:11: style: The scope of the variable 'i' can be reduced. [variableScope]
 int err, i;
          ^
net/wireless/wext-sme.c:67:26: style:inconclusive: Function 'cfg80211_mgd_wext_siwfreq' argument 3 names different: declaration 'freq' definition 'wextfreq'. [funcArgNamesDifferent]
         struct iw_freq *wextfreq, char *extra)
                         ^
net/wireless/wext-compat.h:35:26: note: Function 'cfg80211_mgd_wext_siwfreq' argument 3 names different: declaration 'freq' definition 'wextfreq'.
         struct iw_freq *freq, char *extra);
                         ^
net/wireless/wext-sme.c:67:26: note: Function 'cfg80211_mgd_wext_siwfreq' argument 3 names different: declaration 'freq' definition 'wextfreq'.
         struct iw_freq *wextfreq, char *extra)
                         ^
net/x25/af_x25.c:726:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = sock_error(sk);
     ^
net/x25/af_x25.c:723:6: note: rc is assigned
  rc = -ERESTARTSYS;
     ^
net/x25/af_x25.c:726:6: note: rc is overwritten
  rc = sock_error(sk);
     ^
net/x25/af_x25.c:855:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EAGAIN;
     ^
net/x25/af_x25.c:852:6: note: rc is assigned
  rc = -ERESTARTSYS;
     ^
net/x25/af_x25.c:855:6: note: rc is overwritten
  rc = -EAGAIN;
     ^
net/x25/af_x25.c:858:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = 0;
     ^
net/x25/af_x25.c:855:6: note: rc is assigned
  rc = -EAGAIN;
     ^
net/x25/af_x25.c:858:6: note: rc is overwritten
  rc = 0;
     ^
net/x25/af_x25.c:1425:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = x25_route_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1422:6: note: rc is assigned
  rc = -EPERM;
     ^
net/x25/af_x25.c:1425:6: note: rc is overwritten
  rc = x25_route_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1434:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = x25_subscr_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1431:6: note: rc is assigned
  rc = -EPERM;
     ^
net/x25/af_x25.c:1434:6: note: rc is overwritten
  rc = x25_subscr_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1450:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1447:6: note: rc is assigned
  rc = -EFAULT;
     ^
net/x25/af_x25.c:1450:6: note: rc is overwritten
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1503:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1500:6: note: rc is assigned
  rc = -EFAULT;
     ^
net/x25/af_x25.c:1503:6: note: rc is overwritten
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1534:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1531:6: note: rc is assigned
  rc = -EFAULT;
     ^
net/x25/af_x25.c:1534:6: note: rc is overwritten
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1540:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = 0;
     ^
net/x25/af_x25.c:1534:6: note: rc is assigned
  rc = -EINVAL;
     ^
net/x25/af_x25.c:1540:6: note: rc is overwritten
  rc = 0;
     ^
net/x25/af_x25.c:1560:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = 0;
     ^
net/x25/af_x25.c:1554:6: note: rc is assigned
  rc = -EFAULT;
     ^
net/x25/af_x25.c:1560:6: note: rc is overwritten
  rc = 0;
     ^
net/x25/af_x25.c:1635:5: style: Redundant initialization for 'rc'. The initialized value is overwritten before it is read. [redundantInitialization]
 rc = -EFAULT;
    ^
net/x25/af_x25.c:1633:9: note: rc is initialized
 int rc = -EINVAL;
        ^
net/x25/af_x25.c:1635:5: note: rc is overwritten
 rc = -EFAULT;
    ^
net/x25/af_x25.c:1703:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = x25_route_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1700:6: note: rc is assigned
  rc = -EPERM;
     ^
net/x25/af_x25.c:1703:6: note: rc is overwritten
  rc = x25_route_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1712:6: style: Variable 'rc' is reassigned a value before the old one has been used. [redundantAssignment]
  rc = compat_x25_subscr_ioctl(cmd, argp);
     ^
net/x25/af_x25.c:1709:6: note: rc is assigned
  rc = -EPERM;
     ^
net/x25/af_x25.c:1712:6: note: rc is overwritten
  rc = compat_x25_subscr_ioctl(cmd, argp);
     ^
net/x25/x25_in.c:44:6: style: Condition '!more' is always true [knownConditionTrueFalse]
 if (!more && x25->fraglen > 0) { /* End of fragment */
     ^
net/x25/x25_in.c:37:6: note: Assuming that condition 'more' is not redundant
 if (more) {
     ^
net/x25/x25_in.c:44:6: note: Condition '!more' is always true
 if (!more && x25->fraglen > 0) { /* End of fragment */
     ^
net/x25/x25_in.c:34:18: style: The scope of the variable 'skbo' can be reduced. [variableScope]
 struct sk_buff *skbo, *skbn = skb;
                 ^
net/x25/x25_link.c:72:18: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skbn;
                 ^
net/x25/x25_link.c:294:20: style: The scope of the variable 'nb' can be reduced. [variableScope]
 struct x25_neigh *nb;
                   ^
net/x25/x25_out.c:49:18: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skbn;
                 ^
net/x25/x25_out.c:50:16: style: The scope of the variable 'header' can be reduced. [variableScope]
 unsigned char header[X25_EXT_MIN_LEN];
               ^
net/x25/x25_out.c:51:11: style: The scope of the variable 'frontlen' can be reduced. [variableScope]
 int err, frontlen, len;
          ^
net/x25/x25_out.c:51:21: style: The scope of the variable 'len' can be reduced. [variableScope]
 int err, frontlen, len;
                    ^
net/x25/x25_out.c:138:24: style: The scope of the variable 'skbn' can be reduced. [variableScope]
 struct sk_buff *skb, *skbn;
                       ^
net/x25/x25_proc.c:94:30: style: Variable 'dev' is assigned a value that is never used. [unreadVariable]
 if (!x25->neighbour || (dev = x25->neighbour->dev) == NULL)
                             ^
net/x25/x25_route.c:160:8: style: Condition '!use' is always true [knownConditionTrueFalse]
   if (!use)
       ^
net/x25/x25_route.c:151:31: note: Assignment 'use=NULL', assigned value is 0
 struct x25_route *rt, *use = NULL;
                              ^
net/x25/x25_route.c:160:8: note: Condition '!use' is always true
   if (!use)
       ^
net/x25/x25_route.c:106:20: style: The scope of the variable 'rt' can be reduced. [variableScope]
 struct x25_route *rt;
                   ^
net/x25/x25_route.c:212:20: style: The scope of the variable 'rt' can be reduced. [variableScope]
 struct x25_route *rt;
                   ^
net/x25/x25_subr.c:53:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/xdp/xsk.c:686:18: style: Local variable 'sock' shadows outer argument [shadowArgument]
  struct socket *sock;
                 ^
net/xdp/xsk.c:645:36: note: Shadowed declaration
static int xsk_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
                                   ^
net/xdp/xsk.c:686:18: note: Shadow variable
  struct socket *sock;
                 ^
net/xdp/xsk_buff_pool.c:107:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/xdp/xsk_buff_pool.c:310:14: style: The scope of the variable 'dma' can be reduced. [variableScope]
 dma_addr_t *dma;
             ^
net/xdp/xsk_buff_pool.c:448:7: style: The scope of the variable 'ok' can be reduced. [variableScope]
 bool ok;
      ^
net/xdp/xsk_queue.c:15:24: style: The scope of the variable 'umem_ring' can be reduced. [variableScope]
 struct xdp_umem_ring *umem_ring;
                       ^
net/xdp/xsk_queue.c:50:37: style:inconclusive: Function 'xskq_destroy' argument 1 names different: declaration 'q_ops' definition 'q'. [funcArgNamesDifferent]
void xskq_destroy(struct xsk_queue *q)
                                    ^
net/xdp/xsk_queue.h:368:37: note: Function 'xskq_destroy' argument 1 names different: declaration 'q_ops' definition 'q'.
void xskq_destroy(struct xsk_queue *q_ops);
                                    ^
net/xdp/xsk_queue.c:50:37: note: Function 'xskq_destroy' argument 1 names different: declaration 'q_ops' definition 'q'.
void xskq_destroy(struct xsk_queue *q)
                                    ^
net/xfrm/espintcp.c:271:31: style: Clarify calculation precedence for '&' and '?'. [clarifyCalculation]
  return flags & MSG_DONTWAIT ? -EAGAIN : 0;
                              ^
net/xfrm/espintcp.c:377:6: style: Variable 'err' is assigned a value that is never used. [unreadVariable]
 err = espintcp_push_msgs(sk, msg->msg_flags & MSG_DONTWAIT);
     ^
net/xfrm/xfrm_algo.c:784:30: style: The statement 'if (aalg_list[i].available!=status) aalg_list[i].available=status' is logically equivalent to 'aalg_list[i].available=status'. [duplicateConditionalAssign]
  if (aalg_list[i].available != status)
                             ^
net/xfrm/xfrm_algo.c:785:27: note: Assignment 'aalg_list[i].available=status'
   aalg_list[i].available = status;
                          ^
net/xfrm/xfrm_algo.c:784:30: note: Condition 'aalg_list[i].available!=status' is redundant
  if (aalg_list[i].available != status)
                             ^
net/xfrm/xfrm_algo.c:790:30: style: The statement 'if (ealg_list[i].available!=status) ealg_list[i].available=status' is logically equivalent to 'ealg_list[i].available=status'. [duplicateConditionalAssign]
  if (ealg_list[i].available != status)
                             ^
net/xfrm/xfrm_algo.c:791:27: note: Assignment 'ealg_list[i].available=status'
   ealg_list[i].available = status;
                          ^
net/xfrm/xfrm_algo.c:790:30: note: Condition 'ealg_list[i].available!=status' is redundant
  if (ealg_list[i].available != status)
                             ^
net/xfrm/xfrm_algo.c:797:30: style: The statement 'if (calg_list[i].available!=status) calg_list[i].available=status' is logically equivalent to 'calg_list[i].available=status'. [duplicateConditionalAssign]
  if (calg_list[i].available != status)
                             ^
net/xfrm/xfrm_algo.c:798:27: note: Assignment 'calg_list[i].available=status'
   calg_list[i].available = status;
                          ^
net/xfrm/xfrm_algo.c:797:30: note: Condition 'calg_list[i].available!=status' is redundant
  if (calg_list[i].available != status)
                             ^
net/xfrm/xfrm_compat.c:405:6: style: The scope of the variable 'err' can be reduced. [variableScope]
 int err;
     ^
net/xfrm/xfrm_compat.c:386:12: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 nla = dst + *pos;
           ^
net/xfrm/xfrm_compat.c:393:13: portability: 'dst' is of type 'void *'. When using void pointers in calculations, the behaviour is undefined. [arithOperationsOnVoidPointer]
 memset(dst + *pos, 0, payload - copy_len);
            ^
net/xfrm/xfrm_device.c:218:18: style: The scope of the variable 'saddr' can be reduced. [variableScope]
 xfrm_address_t *saddr;
                 ^
net/xfrm/xfrm_device.c:219:18: style: The scope of the variable 'daddr' can be reduced. [variableScope]
 xfrm_address_t *daddr;
                 ^
net/xfrm/xfrm_device.c:319:16: style: The scope of the variable 'flags' can be reduced. [variableScope]
 unsigned long flags;
               ^
net/xfrm/xfrm_device.c:344:18: style: The scope of the variable 'skb' can be reduced. [variableScope]
 struct sk_buff *skb;
                 ^
net/xfrm/xfrm_interface.c:212:26: style: The scope of the variable 'inner_mode' can be reduced. [variableScope]
 const struct xfrm_mode *inner_mode;
                         ^
net/xfrm/xfrm_ipcomp.c:202:18: warning:inconclusive: Found suspicious operator '*' [constStatement]
 void * __percpu *scratches;
                 ^
net/xfrm/xfrm_ipcomp.c:219:18: warning:inconclusive: Found suspicious operator '*' [constStatement]
 void * __percpu *scratches;
                 ^
net/xfrm/xfrm_ipcomp.c:274:32: warning:inconclusive: Found suspicious operator '*' [constStatement]
 struct crypto_comp * __percpu *tfms;
                               ^
net/xfrm/xfrm_policy.c:2317:28: style: The scope of the variable 'p' can be reduced. [variableScope]
 const struct xfrm_policy *p;
                           ^
net/xfrm/xfrm_policy.c:3791:44: style:inconclusive: Function 'xfrm_bundle_ok' argument 1 names different: declaration 'xdst' definition 'first'. [funcArgNamesDifferent]
static int xfrm_bundle_ok(struct xfrm_dst *first)
                                           ^
net/xfrm/xfrm_policy.c:165:44: note: Function 'xfrm_bundle_ok' argument 1 names different: declaration 'xdst' definition 'first'.
static int xfrm_bundle_ok(struct xfrm_dst *xdst);
                                           ^
net/xfrm/xfrm_policy.c:3791:44: note: Function 'xfrm_bundle_ok' argument 1 names different: declaration 'xdst' definition 'first'.
static int xfrm_bundle_ok(struct xfrm_dst *first)
                                           ^
net/xfrm/xfrm_policy.c:3808:20: style: Local variable 'xdst' shadows outer variable [shadowVariable]
  struct xfrm_dst *xdst = (struct xfrm_dst *)dst;
                   ^
net/xfrm/xfrm_policy.c:3795:19: note: Shadowed declaration
 struct xfrm_dst *xdst;
                  ^
net/xfrm/xfrm_policy.c:3808:20: note: Shadow variable
  struct xfrm_dst *xdst = (struct xfrm_dst *)dst;
                   ^
net/xfrm/xfrm_replay.c:233:26: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int bitnr, nr, i;
                         ^
net/xfrm/xfrm_replay.c:498:26: style: The scope of the variable 'i' can be reduced. [variableScope]
 unsigned int bitnr, nr, i;
                         ^
net/xfrm/xfrm_state.c:1199:7: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
  if (x->props.family == family &&
      ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1199:7: note: Null pointer dereference
  if (x->props.family == family &&
      ^
net/xfrm/xfrm_state.c:1200:7: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      x->props.reqid == reqid &&
      ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1200:7: note: Null pointer dereference
      x->props.reqid == reqid &&
      ^
net/xfrm/xfrm_state.c:1201:15: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      (mark & x->mark.m) == x->mark.v &&
              ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1201:15: note: Null pointer dereference
      (mark & x->mark.m) == x->mark.v &&
              ^
net/xfrm/xfrm_state.c:1202:7: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      x->if_id == if_id &&
      ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1202:7: note: Null pointer dereference
      x->if_id == if_id &&
      ^
net/xfrm/xfrm_state.c:1203:9: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      !(x->props.flags & XFRM_STATE_WILDRECV) &&
        ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1203:9: note: Null pointer dereference
      !(x->props.flags & XFRM_STATE_WILDRECV) &&
        ^
net/xfrm/xfrm_state.c:1205:15: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      mode == x->props.mode &&
              ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1205:15: note: Null pointer dereference
      mode == x->props.mode &&
              ^
net/xfrm/xfrm_state.c:1206:16: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      proto == x->id.proto &&
               ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1206:16: note: Null pointer dereference
      proto == x->id.proto &&
               ^
net/xfrm/xfrm_state.c:1207:7: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
      x->km.state == XFRM_STATE_VALID) {
      ^
net/xfrm/xfrm_state.c:1194:37: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *rx = NULL, *x = NULL;
                                    ^
net/xfrm/xfrm_state.c:1207:7: note: Null pointer dereference
      x->km.state == XFRM_STATE_VALID) {
      ^
net/xfrm/xfrm_state.c:1225:21: style: The scope of the variable 'x' can be reduced. [variableScope]
 struct xfrm_state *x;
                    ^
net/xfrm/xfrm_state.c:2196:21: style: The scope of the variable 'acqret' can be reduced. [variableScope]
 int err = -EINVAL, acqret;
                    ^
net/xfrm/xfrm_state.c:2027:11: style: Variable 'spi' is assigned a value that is never used. [unreadVariable]
  u32 spi = 0;
          ^
net/xfrm/xfrm_state.c:730:30: style: The scope of the variable 'xso' can be reduced. [variableScope]
  struct xfrm_state_offload *xso;
                             ^
net/xfrm/xfrm_state.c:1581:8: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
   if (x->props.mode != m->mode ||
       ^
net/xfrm/xfrm_state.c:1573:25: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *x = NULL;
                        ^
net/xfrm/xfrm_state.c:1581:8: note: Null pointer dereference
   if (x->props.mode != m->mode ||
       ^
net/xfrm/xfrm_state.c:1582:8: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
       x->id.proto != m->proto)
       ^
net/xfrm/xfrm_state.c:1573:25: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *x = NULL;
                        ^
net/xfrm/xfrm_state.c:1582:8: note: Null pointer dereference
       x->id.proto != m->proto)
       ^
net/xfrm/xfrm_state.c:1598:8: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
   if (x->props.mode != m->mode ||
       ^
net/xfrm/xfrm_state.c:1573:25: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *x = NULL;
                        ^
net/xfrm/xfrm_state.c:1598:8: note: Null pointer dereference
   if (x->props.mode != m->mode ||
       ^
net/xfrm/xfrm_state.c:1599:8: warning:inconclusive: Possible null pointer dereference: x [nullPointer]
       x->id.proto != m->proto)
       ^
net/xfrm/xfrm_state.c:1573:25: note: Assignment 'x=NULL', assigned value is 0
 struct xfrm_state *x = NULL;
                        ^
net/xfrm/xfrm_state.c:1599:8: note: Null pointer dereference
       x->id.proto != m->proto)
       ^
net/xfrm/xfrm_state.c:1905:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/xfrm/xfrm_state.c:1919:6: style: The scope of the variable 'i' can be reduced. [variableScope]
 int i;
     ^
net/xfrm/xfrm_user.c:2222:6: style: Redundant initialization for 'err'. The initialized value is overwritten before it is read. [redundantInitialization]
 err = copy_from_user_policy_type(&type, attrs);
     ^
net/xfrm/xfrm_user.c:2218:10: note: err is initialized
 int err = -ENOENT;
         ^
net/xfrm/xfrm_user.c:2222:6: note: err is overwritten
 err = copy_from_user_policy_type(&type, attrs);
     ^
security/lockdown.c:129:6: style: Variable 'len' is assigned a value that is never used. [unreadVariable]
  len--;
     ^
security/security.c:180:6: style: The scope of the variable 'offset' can be reduced. [variableScope]
 int offset;
     ^
security/security.c:808:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
security/security.c:1363:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
security/security.c:1381:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
security/security.c:1419:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
security/security.c:1809:6: style: The scope of the variable 'thisrc' can be reduced. [variableScope]
 int thisrc;
     ^
security/security.c:2017:6: style: The scope of the variable 'rc' can be reduced. [variableScope]
 int rc;
     ^
memory/ksm.c:1338:12: warning: Null pointer dereference: stable_node [ctunullpointer]
 VM_BUG_ON(stable_node->rmap_hlist_len < 0);
           ^
memory/ksm.c:1726:6: note: Assuming that condition 'if(page_node)' is not redundant

     ^
memory/ksm.c:1707:31: note: Calling function is_page_sharing_candidate, 1st argument is null
 if (is_page_sharing_candidate(page_node)) {
                              ^
memory/ksm.c:1352:9: note: Calling function __is_page_sharing_candidate, 1st argument is null
 return __is_page_sharing_candidate(stable_node, 0);
        ^
memory/ksm.c:1338:12: note: Dereferencing argument stable_node that is null
 VM_BUG_ON(stable_node->rmap_hlist_len < 0);
           ^
net/ipv4/fib_trie.c:1369:17: warning: Null pointer dereference: n [ctunullpointer]
 t_key prefix = n->key;
                ^
net/ipv4/fib_trie.c:1483:8: note: Assuming that condition '!n' is not redundant

       ^
net/ipv4/fib_trie.c:1468:31: note: Calling function prefix_mismatch, 2nd argument is null
  if (unlikely(prefix_mismatch(key, n)) || (n->slen == n->pos))
                              ^
net/ipv4/fib_trie.c:1369:17: note: Dereferencing argument n that is null
 t_key prefix = n->key;
                ^
net/ipv4/inet_diag.c:496:6: warning: Null pointer dereference: sk [ctunullpointer]
 if (sk->sk_state == TCP_TIME_WAIT)
     ^
net/ipv4/inet_diag.c:583:5: note: Assuming that condition 'if(sk)' is not redundant

    ^
net/ipv4/inet_diag.c:571:20: note: Calling function sk_diag_fill, 1st argument is null
 err = sk_diag_fill(sk, rep, cb, req, 0, net_admin);
                   ^
net/ipv4/inet_diag.c:496:6: note: Dereferencing argument sk that is null
 if (sk->sk_state == TCP_TIME_WAIT)
     ^
net/ipv6/ip6_output.c:223:7: warning: Null pointer dereference: np [ctunullpointer]
 if (!np->autoflowlabel_set)
      ^
net/ipv6/ip6_output.c:285:6: note: Assuming that condition 'np' is not redundant

     ^
net/ipv6/ip6_output.c:291:22: note: Calling function ip6_autoflowlabel, 2nd argument is null
    ip6_autoflowlabel(net, np), fl6));
                     ^
net/ipv6/ip6_output.c:223:7: note: Dereferencing argument np that is null
 if (!np->autoflowlabel_set)
      ^
net/sched/cls_api.c:1940:6: warning: Null pointer dereference: tp [ctunullpointer]
 if (tp->ops->put && fh)
     ^
net/sched/cls_api.c:2441:6: note: Assuming that condition 'if(tp&&!IS_ERR(tp))' is not redundant

     ^
net/sched/cls_api.c:2438:13: note: Calling function tfilter_put, 1st argument is null
 tfilter_put(tp, fh);
            ^
net/sched/cls_api.c:1940:6: note: Dereferencing argument tp that is null
 if (tp->ops->put && fh)
     ^
memory/kasan/report.c:83:35: error: Using argument flags that points at uninitialized variable flags [ctuuninitvar]
 spin_lock_irqsave(&report_lock, *flags);
                                  ^
memory/kasan/report.c:351:14: note: Calling function start_report, 1st argument is uninitialized
 start_report(&flags);
             ^
memory/kasan/report.c:83:35: note: Using argument flags
 spin_lock_irqsave(&report_lock, *flags);
                                  ^
memory/slab.c:627:0: style: The function '____cache_alloc_node' is never used. [unusedFunction]

^
memory/memory_hotplug.c:309:0: style: The function '__add_pages' is never used. [unusedFunction]

^
memory/hugetlb.c:2387:0: style: The function '__alloc_bootmem_huge_page' is never used. [unusedFunction]

^
memory/percpu.c:1926:0: style: The function '__alloc_reserved_percpu' is never used. [unusedFunction]

^
memory/rmap.c:182:0: style: The function '__anon_vma_prepare' is never used. [unusedFunction]

^
memory/hugetlb.c:1591:0: style: The function '__basepage_index' is never used. [unusedFunction]

^
net/sunrpc/cache.c:1344:0: style: The function '__cache_seq_start' is never used. [unusedFunction]

^
net/ipv4/raw_diag.c:228:0: style: The function '__check_inet_diag_req_raw' is never used. [unusedFunction]

^
memory/page_owner.c:228:0: style: The function '__copy_page_owner' is never used. [unusedFunction]

^
net/decnet/dn_route.c:938:0: style: The function '__dn_fib_res_prefsrc' is never used. [unusedFunction]

^
memory/page_owner.c:409:0: style: The function '__dump_page_owner' is never used. [unusedFunction]

^
memory/memory.c:1616:0: style: The function '__get_locked_pte' is never used. [unusedFunction]

^
memory/vmalloc.c:2109:0: style: The function '__get_vm_area_caller' is never used. [unusedFunction]

^
memory/kasan/common.c:100:0: style: The function '__kasan_alloc_pages' is never used. [unusedFunction]

^
memory/kasan/common.c:138:0: style: The function '__kasan_cache_create' is never used. [unusedFunction]

^
memory/kasan/common.c:114:0: style: The function '__kasan_free_pages' is never used. [unusedFunction]

^
memory/kasan/common.c:312:0: style: The function '__kasan_init_slab_obj' is never used. [unusedFunction]

^
memory/kasan/common.c:488:0: style: The function '__kasan_kfree_large' is never used. [unusedFunction]

^
memory/kasan/common.c:472:0: style: The function '__kasan_krealloc' is never used. [unusedFunction]

^
memory/kasan/common.c:214:0: style: The function '__kasan_metadata_size' is never used. [unusedFunction]

^
memory/kasan/common.c:93:0: style: The function '__kasan_never_merge' is never used. [unusedFunction]

^
memory/kasan/common.c:258:0: style: The function '__kasan_poison_object_data' is never used. [unusedFunction]

^
memory/kasan/common.c:243:0: style: The function '__kasan_poison_slab' is never used. [unusedFunction]

^
memory/kasan/common.c:434:0: style: The function '__kasan_slab_alloc' is never used. [unusedFunction]

^
memory/kasan/common.c:367:0: style: The function '__kasan_slab_free' is never used. [unusedFunction]

^
memory/kasan/common.c:372:0: style: The function '__kasan_slab_free_mempool' is never used. [unusedFunction]

^
memory/kasan/common.c:253:0: style: The function '__kasan_unpoison_object_data' is never used. [unusedFunction]

^
memory/kasan/common.c:61:0: style: The function '__kasan_unpoison_range' is never used. [unusedFunction]

^
memory/page_poison.c:98:0: style: The function '__kernel_map_pages' is never used. [unusedFunction]

^
memory/page_poison.c:33:0: style: The function '__kernel_poison_pages' is never used. [unusedFunction]

^
memory/page_poison.c:89:0: style: The function '__kernel_unpoison_pages' is never used. [unusedFunction]

^
memory/khugepaged.c:464:0: style: The function '__khugepaged_enter' is never used. [unusedFunction]

^
memory/khugepaged.c:517:0: style: The function '__khugepaged_exit' is never used. [unusedFunction]

^
memory/highmem.c:197:0: style: The function '__kmap_flush_unused' is never used. [unusedFunction]

^
memory/highmem.c:637:0: style: The function '__kmap_local_sched_in' is never used. [unusedFunction]

^
memory/highmem.c:601:0: style: The function '__kmap_local_sched_out' is never used. [unusedFunction]

^
memory/ksm.c:2531:0: style: The function '__ksm_exit' is never used. [unusedFunction]

^
memory/filemap.c:1553:0: style: The function '__lock_page_async' is never used. [unusedFunction]

^
memory/filemap.c:1569:0: style: The function '__lock_page_or_retry' is never used. [unusedFunction]

^
memory/mmu_notifier.c:427:0: style: The function '__mmu_notifier_change_pte' is never used. [unusedFunction]

^
memory/mmu_notifier.c:365:0: style: The function '__mmu_notifier_clear_flush_young' is never used. [unusedFunction]

^
memory/mmu_notifier.c:385:0: style: The function '__mmu_notifier_clear_young' is never used. [unusedFunction]

^
memory/mmu_notifier.c:584:0: style: The function '__mmu_notifier_invalidate_range' is never used. [unusedFunction]

^
memory/mmu_notifier.c:569:0: style: The function '__mmu_notifier_invalidate_range_end' is never used. [unusedFunction]

^
memory/mmu_notifier.c:513:0: style: The function '__mmu_notifier_invalidate_range_start' is never used. [unusedFunction]

^
memory/mmu_notifier.c:348:0: style: The function '__mmu_notifier_release' is never used. [unusedFunction]

^
memory/mmu_notifier.c:780:0: style: The function '__mmu_notifier_subscriptions_destroy' is never used. [unusedFunction]

^
memory/mmu_notifier.c:405:0: style: The function '__mmu_notifier_test_young' is never used. [unusedFunction]

^
memory/memcontrol.c:869:0: style: The function '__mod_lruvec_kmem_state' is never used. [unusedFunction]

^
memory/mempolicy.c:2297:0: style: The function '__mpol_dup' is never used. [unusedFunction]

^
memory/mempolicy.c:2321:0: style: The function '__mpol_equal' is never used. [unusedFunction]

^
memory/mempolicy.c:313:0: style: The function '__mpol_put' is never used. [unusedFunction]

^
memory/memblock.c:1199:0: style: The function '__next_mem_pfn_range' is never used. [unusedFunction]

^
memory/memblock.c:1278:0: style: The function '__next_mem_pfn_range_in_zone' is never used. [unusedFunction]

^
memory/memblock.c:1115:0: style: The function '__next_mem_range_rev' is never used. [unusedFunction]

^
memory/mmzone.c:56:0: style: The function '__next_zones_zonelist' is never used. [unusedFunction]

^
memory/highmem.c:107:0: style: The function '__nr_free_highpages' is never used. [unusedFunction]

^
net/netrom/nr_subr.c:211:0: style: The function '__nr_transmit_reply' is never used. [unusedFunction]

^
net/sched/sch_generic.c:379:0: style: The function '__qdisc_run' is never used. [unusedFunction]

^
memory/memory_hotplug.c:1760:0: style: The function '__remove_memory' is never used. [unusedFunction]

^
memory/page_owner.c:145:0: style: The function '__reset_page_owner' is never used. [unusedFunction]

^
memory/page_owner.c:187:0: style: The function '__set_page_owner' is never used. [unusedFunction]

^
memory/page_owner.c:200:0: style: The function '__set_page_owner_migrate_reason' is never used. [unusedFunction]

^
memory/page_owner.c:212:0: style: The function '__split_page_owner' is never used. [unusedFunction]

^
net/socket.c:2627:0: style: The function '__sys_recvmsg_sock' is never used. [unusedFunction]

^
net/socket.c:2416:0: style: The function '__sys_sendmsg_sock' is never used. [unusedFunction]

^
net/tipc/monitor.c:793:0: style: The function '__tipc_nl_add_monitor' is never used. [unusedFunction]

^
net/tipc/msg.c:825:0: style: The function '__tipc_skb_queue_sorted' is never used. [unusedFunction]

^
memory/mmu_gather.c:66:0: style: The function '__tlb_remove_page_size' is never used. [unusedFunction]

^
net/xfrm/xfrm_policy.c:2315:0: style: The function '__xfrm_sk_clone_policy' is never used. [unusedFunction]

^
net/xdp/xsk.c:275:0: style: The function '__xsk_map_flush' is never used. [unusedFunction]

^
net/xdp/xsk.c:260:0: style: The function '__xsk_map_redirect' is never used. [unusedFunction]

^
memory/mmap.c:3535:0: style: The function '_install_special_mapping' is never used. [unusedFunction]

^
memory/page_alloc.c:6649:0: style: The function 'absent_pages_in_range' is never used. [unusedFunction]

^
net/ipv6/anycast.c:531:0: style: The function 'ac6_get_idx' is never used. [unusedFunction]

^
memory/memory.c:4941:0: style: The function 'access_remote_vm' is never used. [unusedFunction]

^
command lines/bash/alias.c:110:0: style: The function 'add_alias' is never used. [unusedFunction]

^
net/mac80211/aead_api.c:49:0: style: The function 'aead_decrypt' is never used. [unusedFunction]

^
net/mac80211/aead_api.c:18:0: style: The function 'aead_encrypt' is never used. [unusedFunction]

^
net/mac80211/aead_api.c:109:0: style: The function 'aead_key_free' is never used. [unusedFunction]

^
net/mac80211/aead_api.c:85:0: style: The function 'aead_key_setup_encrypt' is never used. [unusedFunction]

^
command lines/bash/alias.c:473:0: style: The function 'alias_expand' is never used. [unusedFunction]

^
command lines/bash/alias.c:278:0: style: The function 'alias_expand_word' is never used. [unusedFunction]

^
command lines/bash/alias.c:264:0: style: The function 'all_aliases' is never used. [unusedFunction]

^
memory/page_alloc.c:8740:0: style: The function 'alloc_contig_pages' is never used. [unusedFunction]

^
memory/slab.c:621:0: style: The function 'alternate_node_alloc' is never used. [unusedFunction]

^
memory/rmap.c:328:0: style: The function 'anon_vma_fork' is never used. [unusedFunction]

^
memory/rmap.c:445:0: style: The function 'anon_vma_init' is never used. [unusedFunction]

^
memory/interval_tree.c:92:0: style: The function 'anon_vma_interval_tree_iter_first' is never used. [unusedFunction]

^
memory/interval_tree.c:99:0: style: The function 'anon_vma_interval_tree_iter_next' is never used. [unusedFunction]

^
memory/util.c:409:0: style: The function 'arch_pick_mmap_layout' is never used. [unusedFunction]

^
memory/util.c:347:0: style: The function 'arch_randomize_brk' is never used. [unusedFunction]

^
memory/backing-dev.c:46:0: style: The function 'bdi_debug_stats_show' is never used. [unusedFunction]

^
memory/backing-dev.c:785:0: style: The function 'bdi_get_by_id' is never used. [unusedFunction]

^
memory/backing-dev.c:848:0: style: The function 'bdi_set_owner' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/chatwidget.cpp:97:0: style: The function 'bindTo' is never used. [unusedFunction]

^
net/ipv4/bpfilter/sockopt.c:60:0: style: The function 'bpfilter_ip_get_sockopt' is never used. [unusedFunction]

^
net/ipv4/bpfilter/sockopt.c:54:0: style: The function 'bpfilter_ip_set_sockopt' is never used. [unusedFunction]

^
memory/migrate.c:851:0: style: The function 'buffer_migrate_page_norefs' is never used. [unusedFunction]

^
net/netlabel/netlabel_calipso.c:641:0: style: The function 'calipso_getattr' is never used. [unusedFunction]

^
net/netlabel/netlabel_calipso.c:621:0: style: The function 'calipso_optptr' is never used. [unusedFunction]

^
net/dccp/ccid.c:212:0: style: The function 'ccid_cleanup_builtins' is never used. [unusedFunction]

^
net/dccp/ccid.c:60:0: style: The function 'ccid_getsockopt_builtin_ccids' is never used. [unusedFunction]

^
net/dccp/ccid.c:191:0: style: The function 'ccid_initialize_builtins' is never used. [unusedFunction]

^
net/wireless/debugfs.c:105:0: style: The function 'cfg80211_debugfs_rdev_add' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:290:0: style: The function 'cfg80211_mgd_wext_giwap' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:200:0: style: The function 'cfg80211_mgd_wext_giwessid' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:116:0: style: The function 'cfg80211_mgd_wext_giwfreq' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:239:0: style: The function 'cfg80211_mgd_wext_siwap' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:144:0: style: The function 'cfg80211_mgd_wext_siwessid' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:65:0: style: The function 'cfg80211_mgd_wext_siwfreq' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:312:0: style: The function 'cfg80211_wext_siwgenie' is never used. [unusedFunction]

^
net/wireless/wext-sme.c:362:0: style: The function 'cfg80211_wext_siwmlme' is never used. [unusedFunction]

^
net/ieee802154/core.c:241:0: style: The function 'cfg802154_dev_free' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:297:0: style: The function 'cipso_v4_cache_add' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:1726:0: style: The function 'cipso_v4_error' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:1507:0: style: The function 'cipso_v4_optptr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:2076:0: style: The function 'cipso_v4_req_delattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:1922:0: style: The function 'cipso_v4_req_setattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:2248:0: style: The function 'cipso_v4_skbuff_delattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:2170:0: style: The function 'cipso_v4_skbuff_setattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:2053:0: style: The function 'cipso_v4_sock_delattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:2143:0: style: The function 'cipso_v4_sock_getattr' is never used. [unusedFunction]

^
net/ipv4/cipso_ipv4.c:1837:0: style: The function 'cipso_v4_sock_setattr' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/mainwindow.cpp:120:0: style: The function 'closeEvent' is never used. [unusedFunction]

^
memory/cma.c:529:0: style: The function 'cma_for_each_area' is never used. [unusedFunction]

^
memory/cma.c:42:0: style: The function 'cma_get_base' is never used. [unusedFunction]

^
memory/cma.c:52:0: style: The function 'cma_get_name' is never used. [unusedFunction]

^
memory/cma.c:47:0: style: The function 'cma_get_size' is never used. [unusedFunction]

^
memory/compaction.c:2693:0: style: The function 'compaction_register_node' is never used. [unusedFunction]

^
memory/compaction.c:2698:0: style: The function 'compaction_unregister_node' is never used. [unusedFunction]

^
memory/vmalloc.c:475:0: style: The function 'compute_subtree_max_size' is never used. [unusedFunction]

^
memory/early_ioremap.c:254:0: style: The function 'copy_from_early_mem' is never used. [unusedFunction]

^
memory/memory.c:1127:0: style: The function 'copy_page_range' is never used. [unusedFunction]

^
memory/swapfile.c:1867:0: style: The function 'count_swap_pages' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/controller.cpp:48:0: style: The function 'createAI' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/spritefactory.cpp:51:0: style: The function 'createMiss' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/controller.cpp:34:0: style: The function 'createPlayer' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/controller.cpp:59:0: style: The function 'createRemotePlayer' is never used. [unusedFunction]

^
net/dccp/ackvec.c:401:0: style: The function 'dccp_ackvec_exit' is never used. [unusedFunction]

^
net/dccp/ackvec.c:377:0: style: The function 'dccp_ackvec_init' is never used. [unusedFunction]

^
net/dccp/feat.c:1453:0: style: The function 'dccp_feat_init' is never used. [unusedFunction]

^
net/dccp/feat.c:756:0: style: The function 'dccp_feat_register_sp' is never used. [unusedFunction]

^
net/dccp/output.c:311:0: style: The function 'dccp_flush_write_queue' is never used. [unusedFunction]

^
net/dccp/qpolicy.c:100:0: style: The function 'dccp_qpolicy_full' is never used. [unusedFunction]

^
net/dccp/qpolicy.c:130:0: style: The function 'dccp_qpolicy_param_ok' is never used. [unusedFunction]

^
net/dccp/qpolicy.c:95:0: style: The function 'dccp_qpolicy_push' is never used. [unusedFunction]

^
net/dccp/sysctl.c:107:0: style: The function 'dccp_sysctl_exit' is never used. [unusedFunction]

^
net/dccp/sysctl.c:99:0: style: The function 'dccp_sysctl_init' is never used. [unusedFunction]

^
net/dccp/timer.c:269:0: style: The function 'dccp_timestamping_init' is never used. [unusedFunction]

^
net/dccp/output.c:197:0: style: The function 'dccp_write_space' is never used. [unusedFunction]

^
command lines/bash/alias.c:198:0: style: The function 'delete_all_aliases' is never used. [unusedFunction]

^
net/ethtool/ioctl.c:2563:0: style: The function 'dev_ethtool' is never used. [unusedFunction]

^
net/sched/sch_generic.c:1292:0: style: The function 'dev_init_scheduler' is never used. [unusedFunction]

^
net/sched/sch_generic.c:1260:0: style: The function 'dev_qdisc_change_tx_queue_len' is never used. [unusedFunction]

^
net/sched/sch_generic.c:1317:0: style: The function 'dev_shutdown' is never used. [unusedFunction]

^
memory/page-writeback.c:523:0: style: The function 'dirty_background_bytes_handler' is never used. [unusedFunction]

^
memory/page-writeback.c:512:0: style: The function 'dirty_background_ratio_handler' is never used. [unusedFunction]

^
memory/page-writeback.c:548:0: style: The function 'dirty_bytes_handler' is never used. [unusedFunction]

^
memory/page-writeback.c:534:0: style: The function 'dirty_ratio_handler' is never used. [unusedFunction]

^
memory/page-writeback.c:1986:0: style: The function 'dirty_writeback_centisecs_handler' is never used. [unusedFunction]

^
net/decnet/dn_dev.c:1422:0: style: The function 'dn_dev_cleanup' is never used. [unusedFunction]

^
net/decnet/dn_fib.c:779:0: style: The function 'dn_fib_cleanup' is never used. [unusedFunction]

^
net/decnet/dn_neigh.c:601:0: style: The function 'dn_neigh_cleanup' is never used. [unusedFunction]

^
net/decnet/dn_route.c:1916:0: style: The function 'dn_route_cleanup' is never used. [unusedFunction]

^
net/decnet/sysctl_net_decnet.c:355:0: style: The function 'dn_unregister_sysctl' is never used. [unusedFunction]

^
memory/vmscan.c:711:0: style: The function 'drop_slab' is never used. [unusedFunction]

^
net/dsa/tag_dsa.c:162:0: style: The function 'dsa_rcv_ll' is never used. [unusedFunction]

^
net/dsa/tag_dsa.c:125:0: style: The function 'dsa_xmit_ll' is never used. [unusedFunction]

^
memory/debug.c:215:0: style: The function 'dump_mm' is never used. [unusedFunction]

^
memory/early_ioremap.c:276:0: style: The function 'early_ioremap' is never used. [unusedFunction]

^
memory/early_ioremap.c:45:0: style: The function 'early_ioremap_reset' is never used. [unusedFunction]

^
memory/early_ioremap.c:75:0: style: The function 'early_ioremap_setup' is never used. [unusedFunction]

^
memory/early_ioremap.c:244:0: style: The function 'early_memremap_prot' is never used. [unusedFunction]

^
memory/early_ioremap.c:288:0: style: The function 'early_memremap_ro' is never used. [unusedFunction]

^
memory/memtest.c:100:0: style: The function 'early_memtest' is never used. [unusedFunction]

^
security/security.c:362:0: style: The function 'early_security_init' is never used. [unusedFunction]

^
command lines/bash/examples/loadables/mypid.c:69:0: style: The function 'enable_mypid_builtin_unload' is never used. [unusedFunction]

^
command lines/bash/support/man2html.c:240:0: style: The function 'escape_input' is never used. [unusedFunction]

^
net/ethtool/common.c:373:0: style: The function 'ethtool_check_ops' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/chatwidget.cpp:57:0: style: The function 'eventFilter' is never used. [unusedFunction]

^
memory/mmap.c:3167:0: style: The function 'exit_mmap' is never used. [unusedFunction]

^
memory/oom_kill.c:729:0: style: The function 'exit_oom_victim' is never used. [unusedFunction]

^
command lines/bash/braces.c:495:0: style: The function 'expand_seqterm' is never used. [unusedFunction]

^
net/ipv4/fib_trie.c:2796:0: style: The function 'fib_route_get_idx' is never used. [unusedFunction]

^
net/ipv4/fib_trie.c:2615:0: style: The function 'fib_trie_get_idx' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/seaview.cpp:126:0: style: The function 'fieldAt' is never used. [unusedFunction]

^
memory/swapfile.c:1829:0: style: The function 'find_first_swap' is never used. [unusedFunction]

^
memory/page_alloc.c:7507:0: style: The function 'free_area_init' is never used. [unusedFunction]

^
memory/page_alloc.c:7073:0: style: The function 'free_area_init_memoryless_node' is never used. [unusedFunction]

^
memory/hugetlb.c:1479:0: style: The function 'free_huge_page' is never used. [unusedFunction]

^
memory/hugetlb.c:2880:0: style: The function 'free_hugepages_show' is never used. [unusedFunction]

^
memory/page_alloc.c:7662:0: style: The function 'free_reserved_area' is never used. [unusedFunction]

^
memory/huge_memory.c:2782:0: style: The function 'free_transhuge_page' is never used. [unusedFunction]

^
memory/khugepaged.c:215:0: style: The function 'full_scans_show' is never used. [unusedFunction]

^
command lines/bash/alias.c:95:0: style: The function 'get_alias_value' is never used. [unusedFunction]

^
memory/util.c:924:0: style: The function 'get_cmdline' is never used. [unusedFunction]

^
memory/gup.c:1526:0: style: The function 'get_dump_page' is never used. [unusedFunction]

^
memory/page_alloc.c:501:0: style: The function 'get_pfnblock_flags_mask' is never used. [unusedFunction]

^
memory/slab.c:4010:0: style: The function 'get_slabinfo' is never used. [unusedFunction]

^
memory/swapfile.c:1120:0: style: The function 'get_swap_page_of_type' is never used. [unusedFunction]

^
kernel/panic.c:428:0: style: The function 'get_taint' is never used. [unusedFunction]

^
memory/vmalloc.c:2128:0: style: The function 'get_vm_area' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/seaview.cpp:231:0: style: The function 'globalScreen' is never used. [unusedFunction]

^
memory/z3fold.c:287:0: style: The function 'handle_to_z3fold_header' is never used. [unusedFunction]

^
net/rfkill/core.c:759:0: style: The function 'hard_block_reasons_show' is never used. [unusedFunction]

^
net/rfkill/core.c:717:0: style: The function 'hard_show' is never used. [unusedFunction]

^
command lines/bash/examples/loadables/hello.c:60:0: style: The function 'hello_builtin_load' is never used. [unusedFunction]

^
command lines/bash/examples/loadables/hello.c:69:0: style: The function 'hello_builtin_unload' is never used. [unusedFunction]

^
net/netfilter/xt_HMARK.c:49:0: style: The function 'hmark_addr_mask' is never used. [unusedFunction]

^
net/hsr/hsr_debugfs.c:27:0: style: The function 'hsr_node_table_show' is never used. [unusedFunction]

^
memory/hugetlb.c:102:0: style: The function 'hugepage_new_subpool' is never used. [unusedFunction]

^
memory/hugetlb.c:126:0: style: The function 'hugepage_put_subpool' is never used. [unusedFunction]

^
memory/hugetlb.c:5625:0: style: The function 'hugetlb_cma_reserve' is never used. [unusedFunction]

^
memory/hugetlb.c:708:0: style: The function 'hugetlb_fix_reserve_counts' is never used. [unusedFunction]

^
memory/hugetlb.c:3466:0: style: The function 'hugetlb_report_meminfo' is never used. [unusedFunction]

^
memory/hugetlb.c:3496:0: style: The function 'hugetlb_report_node_meminfo' is never used. [unusedFunction]

^
memory/hugetlb.c:3530:0: style: The function 'hugetlb_report_usage' is never used. [unusedFunction]

^
memory/hugetlb.c:5027:0: style: The function 'hugetlb_reserve_pages' is never used. [unusedFunction]

^
memory/hugetlb.c:5177:0: style: The function 'hugetlb_unreserve_pages' is never used. [unusedFunction]

^
net/mac80211/aes_cmac.c:24:0: style: The function 'ieee80211_aes_cmac' is never used. [unusedFunction]

^
net/mac80211/aes_cmac.c:48:0: style: The function 'ieee80211_aes_cmac_256' is never used. [unusedFunction]

^
net/mac80211/aes_cmac.c:82:0: style: The function 'ieee80211_aes_cmac_key_free' is never used. [unusedFunction]

^
net/mac80211/aes_cmac.c:70:0: style: The function 'ieee80211_aes_cmac_key_setup' is never used. [unusedFunction]

^
net/mac80211/aes_gmac.c:17:0: style: The function 'ieee80211_aes_gmac' is never used. [unusedFunction]

^
net/mac80211/aes_gmac.c:88:0: style: The function 'ieee80211_aes_gmac_key_free' is never used. [unusedFunction]

^
net/mac80211/aes_gmac.c:68:0: style: The function 'ieee80211_aes_gmac_key_setup' is never used. [unusedFunction]

^
net/ieee802154/netlink.c:55:0: style: The function 'ieee802154_nl_new_reply' is never used. [unusedFunction]

^
net/ipv6/mcast.c:2718:0: style: The function 'igmp6_mc_get_idx' is never used. [unusedFunction]

^
net/rfkill/core.c:699:0: style: The function 'index_show' is never used. [unusedFunction]

^
net/ipv6/addrconf.c:949:0: style: The function 'inet6_ifa_finish_destroy' is never used. [unusedFunction]

^
memory/page_alloc.c:765:0: style: The function 'init_mem_debugging_and_hardening' is never used. [unusedFunction]

^
memory/vmstat.c:2018:0: style: The function 'init_mm_internals' is never used. [unusedFunction]

^
command lines/bash/siglist.c:41:0: style: The function 'initialize_siglist' is never used. [unusedFunction]

^
memory/mmap.c:3544:0: style: The function 'install_special_mapping' is never used. [unusedFunction]

^
memory/ioremap.c:31:0: style: The function 'ioremap_huge_init' is never used. [unusedFunction]

^
net/ipv6/ip6_gre.c:861:0: style: The function 'ip6gre_tnl_addr_conflict' is never used. [unusedFunction]

^
net/sunrpc/svcauth_unix.c:306:0: style: The function 'ip_map_lookup' is never used. [unusedFunction]

^
net/ipv4/route.c:1403:0: style: The function 'ip_mtu_from_fib_result' is never used. [unusedFunction]

^
net/ipv6/sysctl_net_ipv6.c:300:0: style: The function 'ipv6_sysctl_unregister' is never used. [unusedFunction]

^
memory/percpu.c:2163:0: style: The function 'is_kernel_percpu_address' is never used. [unusedFunction]

^
memory/kasan/hw_tags.c:122:0: style: The function 'kasan_init_hw_tags' is never used. [unusedFunction]

^
memory/kasan/hw_tags.c:106:0: style: The function 'kasan_init_hw_tags_cpu' is never used. [unusedFunction]

^
memory/kasan/sw_tags.c:38:0: style: The function 'kasan_init_sw_tags' is never used. [unusedFunction]

^
memory/kasan/shadow.c:467:0: style: The function 'kasan_module_alloc' is never used. [unusedFunction]

^
memory/kasan/report.c:431:0: style: The function 'kasan_non_canonical_hook' is never used. [unusedFunction]

^
memory/kasan/generic.c:327:0: style: The function 'kasan_record_aux_stack' is never used. [unusedFunction]

^
memory/kasan/common.c:68:0: style: The function 'kasan_unpoison_task_stack' is never used. [unusedFunction]

^
memory/kasan/common.c:76:0: style: The function 'kasan_unpoison_task_stack_below' is never used. [unusedFunction]

^
net/kcm/kcmproc.c:35:0: style: The function 'kcm_get_idx' is never used. [unusedFunction]

^
memory/slub.c:1506:0: style: The function 'kmalloc_large_node_hook' is never used. [unusedFunction]

^
memory/highmem.c:297:0: style: The function 'kmap_high_get' is never used. [unusedFunction]

^
memory/highmem.c:665:0: style: The function 'kmap_local_fork' is never used. [unusedFunction]

^
memory/slab.c:1202:0: style: The function 'kmem_cache_init' is never used. [unusedFunction]

^
memory/slab.c:1283:0: style: The function 'kmem_cache_init_late' is never used. [unusedFunction]

^
memory/kmemleak.c:1928:0: style: The function 'kmemleak_init' is never used. [unusedFunction]

^
memory/nommu.c:73:0: style: The function 'kobjsize' is never used. [unusedFunction]

^
net/l3mdev/l3mdev.c:246:0: style: The function 'l3mdev_fib_rule_match' is never used. [unusedFunction]

^
memory/page-writeback.c:2022:0: style: The function 'laptop_io_completion' is never used. [unusedFunction]

^
memory/page-writeback.c:2009:0: style: The function 'laptop_mode_timer_fn' is never used. [unusedFunction]

^
memory/page-writeback.c:2032:0: style: The function 'laptop_sync_completion' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:336:0: style: The function 'leaveEvent' is never used. [unusedFunction]

^
memory/list_lru.c:274:0: style: The function 'list_lru_walk_one_irq' is never used. [unusedFunction]

^
memory/page_alloc.c:8142:0: style: The function 'lowmem_reserve_ratio_sysctl_handler' is never used. [unusedFunction]

^
net/mac802154/llsec.c:41:0: style: The function 'mac802154_llsec_destroy' is never used. [unusedFunction]

^
net/mac802154/llsec.c:350:0: style: The function 'mac802154_llsec_dev_add' is never used. [unusedFunction]

^
net/mac802154/llsec.c:388:0: style: The function 'mac802154_llsec_dev_del' is never used. [unusedFunction]

^
net/mac802154/llsec.c:421:0: style: The function 'mac802154_llsec_devkey_add' is never used. [unusedFunction]

^
net/mac802154/llsec.c:445:0: style: The function 'mac802154_llsec_devkey_del' is never used. [unusedFunction]

^
net/mac802154/llsec.c:701:0: style: The function 'mac802154_llsec_encrypt' is never used. [unusedFunction]

^
net/mac802154/llsec.c:73:0: style: The function 'mac802154_llsec_get_params' is never used. [unusedFunction]

^
net/mac802154/llsec.c:27:0: style: The function 'mac802154_llsec_init' is never used. [unusedFunction]

^
net/mac802154/llsec.c:212:0: style: The function 'mac802154_llsec_key_add' is never used. [unusedFunction]

^
net/mac802154/llsec.c:268:0: style: The function 'mac802154_llsec_key_del' is never used. [unusedFunction]

^
net/mac802154/llsec.c:487:0: style: The function 'mac802154_llsec_seclevel_add' is never used. [unusedFunction]

^
net/mac802154/llsec.c:506:0: style: The function 'mac802154_llsec_seclevel_del' is never used. [unusedFunction]

^
net/mac802154/llsec.c:83:0: style: The function 'mac802154_llsec_set_params' is never used. [unusedFunction]

^
memory/backing-dev.c:199:0: style: The function 'max_ratio_show' is never used. [unusedFunction]

^
memory/backing-dev.c:182:0: style: The function 'max_ratio_store' is never used. [unusedFunction]

^
memory/userfaultfd.c:625:0: style: The function 'mcopy_atomic' is never used. [unusedFunction]

^
memory/memcontrol.c:535:0: style: The function 'mem_cgroup_css_from_page' is never used. [unusedFunction]

^
memory/memcontrol.c:2634:0: style: The function 'mem_cgroup_handle_over_high' is never used. [unusedFunction]

^
memory/memcontrol.c:6994:0: style: The function 'mem_cgroup_sk_free' is never used. [unusedFunction]

^
memory/memcontrol.c:4655:0: style: The function 'mem_cgroup_track_foreign_dirty_slowpath' is never used. [unusedFunction]

^
memory/memcontrol.c:7042:0: style: The function 'mem_cgroup_uncharge_skmem' is never used. [unusedFunction]

^
memory/memcontrol.c:1410:0: style: The function 'mem_cgroup_update_lru_size' is never used. [unusedFunction]

^
memory/page_alloc.c:7710:0: style: The function 'mem_init_print_info' is never used. [unusedFunction]

^
memory/memblock.c:717:0: style: The function 'memblock_add' is never used. [unusedFunction]

^
memory/memblock.c:1919:0: style: The function 'memblock_allow_resize' is never used. [unusedFunction]

^
memory/memblock.c:960:0: style: The function 'memblock_clear_nomap' is never used. [unusedFunction]

^
memory/memblock.c:2108:0: style: The function 'memblock_debug_show' is never used. [unusedFunction]

^
memory/memblock.c:1913:0: style: The function 'memblock_dump_all' is never used. [unusedFunction]

^
memory/memblock.c:1684:0: style: The function 'memblock_enforce_memory_limit' is never used. [unusedFunction]

^
memory/memblock.c:2093:0: style: The function 'memblock_free_all' is never used. [unusedFunction]

^
memory/memblock.c:1868:0: style: The function 'memblock_get_current_limit' is never used. [unusedFunction]

^
memory/memblock.c:1776:0: style: The function 'memblock_is_map_memory' is never used. [unusedFunction]

^
memory/memblock.c:1771:0: style: The function 'memblock_is_memory' is never used. [unusedFunction]

^
memory/memblock.c:1810:0: style: The function 'memblock_is_region_memory' is never used. [unusedFunction]

^
memory/memblock.c:1766:0: style: The function 'memblock_is_reserved' is never used. [unusedFunction]

^
memory/memblock.c:910:0: style: The function 'memblock_mark_hotplug' is never used. [unusedFunction]

^
memory/memblock.c:934:0: style: The function 'memblock_mark_mirror' is never used. [unusedFunction]

^
memory/memblock.c:948:0: style: The function 'memblock_mark_nomap' is never used. [unusedFunction]

^
memory/memblock.c:1732:0: style: The function 'memblock_mem_limit_remove_map' is never used. [unusedFunction]

^
memory/memblock.c:1417:0: style: The function 'memblock_phys_alloc_range' is never used. [unusedFunction]

^
memory/memblock.c:1442:0: style: The function 'memblock_phys_alloc_try_nid' is never used. [unusedFunction]

^
memory/memblock.c:1640:0: style: The function 'memblock_phys_mem_size' is never used. [unusedFunction]

^
memory/memblock.c:858:0: style: The function 'memblock_physmem_add' is never used. [unusedFunction]

^
memory/memblock.c:1645:0: style: The function 'memblock_reserved_size' is never used. [unusedFunction]

^
memory/memblock.c:1785:0: style: The function 'memblock_search_pfn_nid' is never used. [unusedFunction]

^
memory/memblock.c:1863:0: style: The function 'memblock_set_current_limit' is never used. [unusedFunction]

^
memory/memblock.c:1242:0: style: The function 'memblock_set_node' is never used. [unusedFunction]

^
memory/memblock.c:1838:0: style: The function 'memblock_trim_memory' is never used. [unusedFunction]

^
memory/memfd.c:221:0: style: The function 'memfd_fcntl' is never used. [unusedFunction]

^
memory/memory-failure.c:1635:0: style: The function 'memory_failure_queue_kick' is never used. [unusedFunction]

^
memory/mempolicy.c:2092:0: style: The function 'mempolicy_nodemask_intersects' is never used. [unusedFunction]

^
memory/mempolicy.c:1913:0: style: The function 'mempolicy_slab_node' is never used. [unusedFunction]

^
memory/userfaultfd.c:633:0: style: The function 'mfill_zeropage' is never used. [unusedFunction]

^
memory/migrate.c:520:0: style: The function 'migrate_huge_page_move_mapping' is never used. [unusedFunction]

^
memory/backing-dev.c:180:0: style: The function 'min_ratio_show' is never used. [unusedFunction]

^
memory/backing-dev.c:163:0: style: The function 'min_ratio_store' is never used. [unusedFunction]

^
net/mac80211/rc80211_minstrel_ht_debugfs.c:317:0: style: The function 'minstrel_ht_add_sta_debugfs' is never used. [unusedFunction]

^
memory/huge_memory.c:130:0: style: The function 'mm_put_huge_zero_page' is never used. [unusedFunction]

^
memory/memory.c:159:0: style: The function 'mm_trace_rss_stat' is never used. [unusedFunction]

^
memory/mmap.c:3737:0: style: The function 'mmap_init' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:317:0: style: The function 'mouseMoveEvent' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:288:0: style: The function 'mousePressEvent' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/battlefieldview.cpp:308:0: style: The function 'mouseReleaseEvent' is never used. [unusedFunction]

^
memory/mempolicy.c:2531:0: style: The function 'mpol_put_task_policy' is never used. [unusedFunction]

^
memory/mempolicy.c:404:0: style: The function 'mpol_rebind_mm' is never used. [unusedFunction]

^
memory/mempolicy.c:393:0: style: The function 'mpol_rebind_task' is never used. [unusedFunction]

^
memory/mempolicy.c:3002:0: style: The function 'mpol_to_str' is never used. [unusedFunction]

^
net/mptcp/diag.c:100:0: style: The function 'mptcp_diag_subflow_init' is never used. [unusedFunction]

^
net/mptcp/ctrl.c:28:0: style: The function 'mptcp_is_enabled' is never used. [unusedFunction]

^
net/mptcp/mib.c:42:0: style: The function 'mptcp_mib_alloc' is never used. [unusedFunction]

^
net/mptcp/options.c:978:0: style: The function 'mptcp_write_options' is never used. [unusedFunction]

^
memory/userfaultfd.c:639:0: style: The function 'mwriteprotect_range' is never used. [unusedFunction]

^
net/rfkill/core.c:681:0: style: The function 'name_show' is never used. [unusedFunction]

^
net/netlabel/netlabel_calipso.c:360:0: style: The function 'netlbl_calipso_genl_init' is never used. [unusedFunction]

^
net/netlabel/netlabel_cipso_v4.c:781:0: style: The function 'netlbl_cipsov4_genl_init' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:563:0: style: The function 'netlbl_domhsh_add_default' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:857:0: style: The function 'netlbl_domhsh_getentry' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:875:0: style: The function 'netlbl_domhsh_getentry_af4' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:362:0: style: The function 'netlbl_domhsh_init' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:660:0: style: The function 'netlbl_domhsh_remove_af4' is never used. [unusedFunction]

^
net/netlabel/netlabel_domainhash.c:840:0: style: The function 'netlbl_domhsh_remove_default' is never used. [unusedFunction]

^
net/netlink/af_netlink.c:1263:0: style: The function 'netlink_detachskb' is never used. [unusedFunction]

^
net/netlink/af_netlink.c:1153:0: style: The function 'netlink_getsockbyfilp' is never used. [unusedFunction]

^
memory/mmzone.c:30:0: style: The function 'next_zone' is never used. [unusedFunction]

^
net/netfilter/utils.c:201:0: style: The function 'nf_reroute' is never used. [unusedFunction]

^
net/nfc/hci/llc.c:77:0: style: The function 'nfc_llc_unregister' is never used. [unusedFunction]

^
net/netfilter/nft_set_pipapo_avx2.c:1087:0: style: The function 'nft_pipapo_avx2_estimate' is never used. [unusedFunction]

^
net/netfilter/nft_set_pipapo_avx2.c:1122:0: style: The function 'nft_pipapo_avx2_lookup' is never used. [unusedFunction]

^
memory/page_alloc.c:7192:0: style: The function 'node_map_pfn_alignment' is never used. [unusedFunction]

^
memory/slub.c:1488:0: style: The function 'node_nr_slabs' is never used. [unusedFunction]

^
memory/nommu.c:1762:0: style: The function 'nommu_shrink_inode_mappings' is never used. [unusedFunction]

^
fs/ntfs/attrib.c:1396:0: style: The function 'ntfs_attr_can_be_resident' is never used. [unusedFunction]

^
fs/ntfs/mft.c:2773:0: style: The function 'ntfs_extent_mft_record_free' is never used. [unusedFunction]

^
fs/ntfs/unistr.c:210:0: style: The function 'ntfs_file_compare_values' is never used. [unusedFunction]

^
fs/ntfs/unistr.c:203:0: style: The function 'ntfs_file_upcase_value' is never used. [unusedFunction]

^
fs/ntfs/mft.c:2238:0: style: The function 'ntfs_mft_record_alloc' is never used. [unusedFunction]

^
net/ipv4/ipconfig.c:1358:0: style: The function 'ntp_servers_show' is never used. [unusedFunction]

^
memory/mempolicy.c:2837:0: style: The function 'numa_default_policy' is never used. [unusedFunction]

^
memory/mempolicy.c:2783:0: style: The function 'numa_policy_init' is never used. [unusedFunction]

^
memory/sparse.c:628:0: style: The function 'offline_mem_sections' is never used. [unusedFunction]

^
memory/memory_hotplug.c:1451:0: style: The function 'offline_pages' is never used. [unusedFunction]

^
memory/memory_hotplug.c:779:0: style: The function 'online_pages' is never used. [unusedFunction]

^
memory/oom_kill.c:761:0: style: The function 'oom_killer_disable' is never used. [unusedFunction]

^
kernel/panic.c:527:0: style: The function 'oops_enter' is never used. [unusedFunction]

^
kernel/panic.c:564:0: style: The function 'oops_exit' is never used. [unusedFunction]

^
kernel/panic.c:508:0: style: The function 'oops_may_print' is never used. [unusedFunction]

^
memory/util.c:803:0: style: The function 'overcommit_kbytes_handler' is never used. [unusedFunction]

^
memory/util.c:767:0: style: The function 'overcommit_policy_handler' is never used. [unusedFunction]

^
memory/util.c:751:0: style: The function 'overcommit_ratio_handler' is never used. [unusedFunction]

^
net/openvswitch/flow.c:824:0: style: The function 'ovs_flow_key_update_l3l4' is never used. [unusedFunction]

^
memory/pgtable-generic.c:28:0: style: The function 'p4d_clear_bad' is never used. [unusedFunction]

^
memory/highmem.c:773:0: style: The function 'page_address_init' is never used. [unusedFunction]

^
memory/page_alloc.c:7816:0: style: The function 'page_alloc_init' is never used. [unusedFunction]

^
memory/page_alloc.c:2097:0: style: The function 'page_alloc_init_late' is never used. [unusedFunction]

^
memory/page_ext.c:369:0: style: The function 'page_ext_init' is never used. [unusedFunction]

^
memory/page_ext.c:173:0: style: The function 'page_ext_init_flatmem' is never used. [unusedFunction]

^
memory/page_ext.c:103:0: style: The function 'page_ext_init_flatmem_late' is never used. [unusedFunction]

^
memory/util.c:717:0: style: The function 'page_mapping_file' is never used. [unusedFunction]

^
memory/filemap.c:1001:0: style: The function 'pagecache_init' is never used. [unusedFunction]

^
memory/oom_kill.c:1127:0: style: The function 'pagefault_out_of_memory' is never used. [unusedFunction]

^
memory/khugepaged.c:206:0: style: The function 'pages_collapsed_show' is never used. [unusedFunction]

^
memory/ksm.c:3049:0: style: The function 'pages_shared_show' is never used. [unusedFunction]

^
memory/ksm.c:3056:0: style: The function 'pages_sharing_show' is never used. [unusedFunction]

^
memory/ksm.c:3063:0: style: The function 'pages_unshared_show' is never used. [unusedFunction]

^
memory/ksm.c:3070:0: style: The function 'pages_volatile_show' is never used. [unusedFunction]

^
memory/page_owner.c:260:0: style: The function 'pagetypeinfo_showmixedcount_print' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/statswidget.cpp:25:0: style: The function 'paintEvent' is never used. [unusedFunction]

^
memory/percpu.c:3166:0: style: The function 'pcpu_nr_pages' is never used. [unusedFunction]

^
memory/percpu.c:2963:0: style: The function 'pcpu_page_first_chunk' is never used. [unusedFunction]

^
memory/percpu.c:2191:0: style: The function 'per_cpu_ptr_to_phys' is never used. [unusedFunction]

^
memory/page_alloc.c:8163:0: style: The function 'percpu_pagelist_fraction_sysctl_handler' is never used. [unusedFunction]

^
memory/percpu-stats.c:142:0: style: The function 'percpu_stats_show' is never used. [unusedFunction]

^
net/rfkill/core.c:708:0: style: The function 'persistent_show' is never used. [unusedFunction]

^
memory/pgtable-generic.c:21:0: style: The function 'pgd_clear_bad' is never used. [unusedFunction]

^
memory/pgtable-generic.c:120:0: style: The function 'pmdp_clear_flush_young' is never used. [unusedFunction]

^
memory/memory.c:4973:0: style: The function 'print_vma_addr' is never used. [unusedFunction]

^
memory/ptdump.c:143:0: style: The function 'ptdump_walk_pgd' is never used. [unusedFunction]

^
memory/pgtable-generic.c:78:0: style: The function 'ptep_clear_flush_young' is never used. [unusedFunction]

^
memory/pgtable-generic.c:36:0: style: The function 'pud_clear_bad' is never used. [unusedFunction]

^
memory/pgtable-generic.c:146:0: style: The function 'pudp_huge_clear_flush' is never used. [unusedFunction]

^
net/compat.c:228:0: style: The function 'put_cmsg_compat' is never used. [unusedFunction]

^
net/sched/sch_api.c:194:0: style: The function 'qdisc_get_default' is never used. [unusedFunction]

^
memory/util.c:330:0: style: The function 'randomize_stack_top' is never used. [unusedFunction]

^
memory/backing-dev.c:161:0: style: The function 'read_ahead_kb_show' is never used. [unusedFunction]

^
memory/backing-dev.c:132:0: style: The function 'read_ahead_kb_store' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/playerentity.cpp:179:0: style: The function 'registerHit' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/playerentity.cpp:186:0: style: The function 'registerMiss' is never used. [unusedFunction]

^
memory/memory_hotplug.c:231:0: style: The function 'register_page_bootmem_info_node' is never used. [unusedFunction]

^
command lines/bash/alias.c:174:0: style: The function 'remove_alias' is never used. [unusedFunction]

^
memory/hugetlb.c:955:0: style: The function 'reset_vma_resv_huge_pages' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/chatwidget.cpp:105:0: style: The function 'resizeEvent' is never used. [unusedFunction]

^
memory/hugetlb.c:2897:0: style: The function 'resv_hugepages_show' is never used. [unusedFunction]

^
memory/rodata_test.c:16:0: style: The function 'rodata_test' is never used. [unusedFunction]

^
net/sunrpc/rpc_pipe.c:1268:0: style: The function 'rpc_dummy_info_show' is never used. [unusedFunction]

^
net/sunrpc/xprtmultipath.c:80:0: style: The function 'rpc_xprt_switch_remove_xprt' is never used. [unusedFunction]

^
net/ipv6/route.c:4307:0: style: The function 'rt6_purge_dflt_routers' is never used. [unusedFunction]

^
net/rxrpc/conn_object.c:305:0: style: The function 'rxrpc_get_connection_maybe' is never used. [unusedFunction]

^
net/compat.c:291:0: style: The function 'scm_detach_fds_compat' is never used. [unusedFunction]

^
net/sctp/socket.c:892:0: style: The function 'sctp_asconf_mgmt' is never used. [unusedFunction]

^
net/sctp/associola.c:734:0: style: The function 'sctp_assoc_del_peer' is never used. [unusedFunction]

^
net/sctp/sm_make_chunk.c:119:0: style: The function 'sctp_chunk_iif' is never used. [unusedFunction]

^
net/sctp/objcnt.c:97:0: style: The function 'sctp_dbg_objcnt_init' is never used. [unusedFunction]

^
net/sctp/offload.c:97:0: style: The function 'sctp_offload_init' is never used. [unusedFunction]

^
net/sctp/proc.c:370:0: style: The function 'sctp_proc_init' is never used. [unusedFunction]

^
net/sctp/stream_sched.c:122:0: style: The function 'sctp_sched_ops_init' is never used. [unusedFunction]

^
net/sctp/socket.c:8903:0: style: The function 'sctp_sock_rfree' is never used. [unusedFunction]

^
net/sctp/sysctl.c:480:0: style: The function 'sctp_sysctl_net_register' is never used. [unusedFunction]

^
net/sctp/sysctl.c:500:0: style: The function 'sctp_sysctl_net_unregister' is never used. [unusedFunction]

^
net/sctp/sysctl.c:512:0: style: The function 'sctp_sysctl_register' is never used. [unusedFunction]

^
net/sctp/sysctl.c:518:0: style: The function 'sctp_sysctl_unregister' is never used. [unusedFunction]

^
net/sctp/input.c:926:0: style: The function 'sctp_transport_hashtable_destroy' is never used. [unusedFunction]

^
net/sctp/input.c:921:0: style: The function 'sctp_transport_hashtable_init' is never used. [unusedFunction]

^
net/sctp/ulpevent.c:974:0: style: The function 'sctp_ulpevent_get_notification_type' is never used. [unusedFunction]

^
net/sctp/input.c:572:0: style: The function 'sctp_v4_err' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1148:0: style: The function 'sctp_v6_add_protocol' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1160:0: style: The function 'sctp_v6_del_protocol' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1118:0: style: The function 'sctp_v6_pf_exit' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1109:0: style: The function 'sctp_v6_pf_init' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1139:0: style: The function 'sctp_v6_protosw_exit' is never used. [unusedFunction]

^
net/sctp/ipv6.c:1124:0: style: The function 'sctp_v6_protosw_init' is never used. [unusedFunction]

^
security/security.c:2487:0: style: The function 'security_audit_rule_free' is never used. [unusedFunction]

^
security/security.c:2477:0: style: The function 'security_audit_rule_init' is never used. [unusedFunction]

^
security/security.c:2482:0: style: The function 'security_audit_rule_known' is never used. [unusedFunction]

^
security/security.c:2492:0: style: The function 'security_audit_rule_match' is never used. [unusedFunction]

^
security/security.c:725:0: style: The function 'security_binder_set_context_mgr' is never used. [unusedFunction]

^
security/security.c:730:0: style: The function 'security_binder_transaction' is never used. [unusedFunction]

^
security/security.c:736:0: style: The function 'security_binder_transfer_binder' is never used. [unusedFunction]

^
security/security.c:742:0: style: The function 'security_binder_transfer_file' is never used. [unusedFunction]

^
security/security.c:2499:0: style: The function 'security_bpf' is never used. [unusedFunction]

^
security/security.c:2503:0: style: The function 'security_bpf_map' is never used. [unusedFunction]

^
security/security.c:2511:0: style: The function 'security_bpf_map_alloc' is never used. [unusedFunction]

^
security/security.c:2519:0: style: The function 'security_bpf_map_free' is never used. [unusedFunction]

^
security/security.c:2507:0: style: The function 'security_bpf_prog' is never used. [unusedFunction]

^
security/security.c:2515:0: style: The function 'security_bpf_prog_alloc' is never used. [unusedFunction]

^
security/security.c:2523:0: style: The function 'security_bpf_prog_free' is never used. [unusedFunction]

^
security/security.c:837:0: style: The function 'security_bprm_check' is never used. [unusedFunction]

^
security/security.c:852:0: style: The function 'security_bprm_committed_creds' is never used. [unusedFunction]

^
security/security.c:847:0: style: The function 'security_bprm_committing_creds' is never used. [unusedFunction]

^
security/security.c:827:0: style: The function 'security_bprm_creds_for_exec' is never used. [unusedFunction]

^
security/security.c:832:0: style: The function 'security_bprm_creds_from_file' is never used. [unusedFunction]

^
security/security.c:776:0: style: The function 'security_capable' is never used. [unusedFunction]

^
security/security.c:758:0: style: The function 'security_capget' is never used. [unusedFunction]

^
security/security.c:767:0: style: The function 'security_capset' is never used. [unusedFunction]

^
security/security.c:1602:0: style: The function 'security_cred_alloc_blank' is never used. [unusedFunction]

^
security/security.c:1454:0: style: The function 'security_file_alloc' is never used. [unusedFunction]

^
security/security.c:1550:0: style: The function 'security_file_fcntl' is never used. [unusedFunction]

^
security/security.c:1545:0: style: The function 'security_file_lock' is never used. [unusedFunction]

^
security/security.c:1571:0: style: The function 'security_file_open' is never used. [unusedFunction]

^
security/security.c:1443:0: style: The function 'security_file_permission' is never used. [unusedFunction]

^
security/security.c:1566:0: style: The function 'security_file_receive' is never used. [unusedFunction]

^
security/security.c:1560:0: style: The function 'security_file_send_sigiotask' is never used. [unusedFunction]

^
security/security.c:1555:0: style: The function 'security_file_set_fowner' is never used. [unusedFunction]

^
security/security.c:857:0: style: The function 'security_fs_context_dup' is never used. [unusedFunction]

^
security/security.c:862:0: style: The function 'security_fs_context_parse_param' is never used. [unusedFunction]

^
security/security.c:1977:0: style: The function 'security_getprocattr' is never used. [unusedFunction]

^
security/security.c:387:0: style: The function 'security_init' is never used. [unusedFunction]

^
security/security.c:970:0: style: The function 'security_inode_alloc' is never used. [unusedFunction]

^
security/security.c:1247:0: style: The function 'security_inode_follow_link' is never used. [unusedFunction]

^
security/security.c:1275:0: style: The function 'security_inode_getattr' is never used. [unusedFunction]

^
security/security.c:1405:0: style: The function 'security_inode_getsecid' is never used. [unusedFunction]

^
security/security.c:1360:0: style: The function 'security_inode_getsecurity' is never used. [unusedFunction]

^
security/security.c:1315:0: style: The function 'security_inode_getxattr' is never used. [unusedFunction]

^
security/security.c:1355:0: style: The function 'security_inode_killpriv' is never used. [unusedFunction]

^
security/security.c:1176:0: style: The function 'security_inode_link' is never used. [unusedFunction]

^
security/security.c:1322:0: style: The function 'security_inode_listxattr' is never used. [unusedFunction]

^
security/security.c:1214:0: style: The function 'security_inode_mknod' is never used. [unusedFunction]

^
security/security.c:1350:0: style: The function 'security_inode_need_killpriv' is never used. [unusedFunction]

^
security/security.c:1255:0: style: The function 'security_inode_permission' is never used. [unusedFunction]

^
security/security.c:1306:0: style: The function 'security_inode_post_setxattr' is never used. [unusedFunction]

^
security/security.c:1240:0: style: The function 'security_inode_readlink' is never used. [unusedFunction]

^
security/security.c:1329:0: style: The function 'security_inode_removexattr' is never used. [unusedFunction]

^
security/security.c:1221:0: style: The function 'security_inode_rename' is never used. [unusedFunction]

^
security/security.c:1207:0: style: The function 'security_inode_rmdir' is never used. [unusedFunction]

^
security/security.c:1378:0: style: The function 'security_inode_setsecurity' is never used. [unusedFunction]

^
security/security.c:1282:0: style: The function 'security_inode_setxattr' is never used. [unusedFunction]

^
security/security.c:1191:0: style: The function 'security_inode_symlink' is never used. [unusedFunction]

^
security/security.c:1184:0: style: The function 'security_inode_unlink' is never used. [unusedFunction]

^
security/security.c:1834:0: style: The function 'security_ipc_getsecid' is never used. [unusedFunction]

^
security/security.c:1829:0: style: The function 'security_ipc_permission' is never used. [unusedFunction]

^
security/security.c:1655:0: style: The function 'security_kernel_act_as' is never used. [unusedFunction]

^
security/security.c:1660:0: style: The function 'security_kernel_create_files_as' is never used. [unusedFunction]

^
security/security.c:1665:0: style: The function 'security_kernel_module_request' is never used. [unusedFunction]

^
security/security.c:1437:0: style: The function 'security_kernfs_init_security' is never used. [unusedFunction]

^
security/security.c:2450:0: style: The function 'security_key_alloc' is never used. [unusedFunction]

^
security/security.c:2456:0: style: The function 'security_key_free' is never used. [unusedFunction]

^
security/security.c:2467:0: style: The function 'security_key_getsecurity' is never used. [unusedFunction]

^
security/security.c:2461:0: style: The function 'security_key_permission' is never used. [unusedFunction]

^
security/security.c:959:0: style: The function 'security_move_mount' is never used. [unusedFunction]

^
security/security.c:1840:0: style: The function 'security_msg_msg_alloc' is never used. [unusedFunction]

^
security/security.c:1859:0: style: The function 'security_msg_queue_alloc' is never used. [unusedFunction]

^
security/security.c:1878:0: style: The function 'security_msg_queue_associate' is never used. [unusedFunction]

^
security/security.c:1883:0: style: The function 'security_msg_queue_msgctl' is never used. [unusedFunction]

^
security/security.c:1894:0: style: The function 'security_msg_queue_msgrcv' is never used. [unusedFunction]

^
security/security.c:1888:0: style: The function 'security_msg_queue_msgsnd' is never used. [unusedFunction]

^
security/security.c:1148:0: style: The function 'security_path_chmod' is never used. [unusedFunction]

^
security/security.c:1155:0: style: The function 'security_path_chown' is never used. [unusedFunction]

^
security/security.c:1162:0: style: The function 'security_path_chroot' is never used. [unusedFunction]

^
security/security.c:1113:0: style: The function 'security_path_link' is never used. [unusedFunction]

^
security/security.c:964:0: style: The function 'security_path_notify' is never used. [unusedFunction]

^
security/security.c:1090:0: style: The function 'security_path_rmdir' is never used. [unusedFunction]

^
security/security.c:1105:0: style: The function 'security_path_symlink' is never used. [unusedFunction]

^
security/security.c:1141:0: style: The function 'security_path_truncate' is never used. [unusedFunction]

^
security/security.c:2541:0: style: The function 'security_perf_event_alloc' is never used. [unusedFunction]

^
security/security.c:2546:0: style: The function 'security_perf_event_free' is never used. [unusedFunction]

^
security/security.c:2536:0: style: The function 'security_perf_event_open' is never used. [unusedFunction]

^
security/security.c:2551:0: style: The function 'security_perf_event_read' is never used. [unusedFunction]

^
security/security.c:2556:0: style: The function 'security_perf_event_write' is never used. [unusedFunction]

^
security/security.c:2071:0: style: The function 'security_post_notification' is never used. [unusedFunction]

^
security/security.c:1630:0: style: The function 'security_prepare_creds' is never used. [unusedFunction]

^
security/security.c:748:0: style: The function 'security_ptrace_access_check' is never used. [unusedFunction]

^
security/security.c:753:0: style: The function 'security_ptrace_traceme' is never used. [unusedFunction]

^
security/security.c:789:0: style: The function 'security_quota_on' is never used. [unusedFunction]

^
security/security.c:784:0: style: The function 'security_quotactl' is never used. [unusedFunction]

^
security/security.c:867:0: style: The function 'security_sb_alloc' is never used. [unusedFunction]

^
security/security.c:872:0: style: The function 'security_sb_free' is never used. [unusedFunction]

^
security/security.c:899:0: style: The function 'security_sb_kern_mount' is never used. [unusedFunction]

^
security/security.c:914:0: style: The function 'security_sb_mount' is never used. [unusedFunction]

^
security/security.c:925:0: style: The function 'security_sb_pivotroot' is never used. [unusedFunction]

^
security/security.c:904:0: style: The function 'security_sb_show_options' is never used. [unusedFunction]

^
security/security.c:909:0: style: The function 'security_sb_statfs' is never used. [unusedFunction]

^
security/security.c:920:0: style: The function 'security_sb_umount' is never used. [unusedFunction]

^
security/security.c:1934:0: style: The function 'security_sem_alloc' is never used. [unusedFunction]

^
security/security.c:1953:0: style: The function 'security_sem_associate' is never used. [unusedFunction]

^
security/security.c:1958:0: style: The function 'security_sem_semctl' is never used. [unusedFunction]

^
security/security.c:1963:0: style: The function 'security_sem_semop' is never used. [unusedFunction]

^
security/security.c:1990:0: style: The function 'security_setprocattr' is never used. [unusedFunction]

^
security/security.c:799:0: style: The function 'security_settime64' is never used. [unusedFunction]

^
security/security.c:1900:0: style: The function 'security_shm_alloc' is never used. [unusedFunction]

^
security/security.c:1919:0: style: The function 'security_shm_associate' is never used. [unusedFunction]

^
security/security.c:1929:0: style: The function 'security_shm_shmat' is never used. [unusedFunction]

^
security/security.c:1924:0: style: The function 'security_shm_shmctl' is never used. [unusedFunction]

^
security/security.c:2194:0: style: The function 'security_sk_alloc' is never used. [unusedFunction]

^
security/security.c:2199:0: style: The function 'security_sk_free' is never used. [unusedFunction]

^
security/security.c:2180:0: style: The function 'security_socket_getpeersec_stream' is never used. [unusedFunction]

^
security/security.c:794:0: style: The function 'security_syslog' is never used. [unusedFunction]

^
security/security.c:1582:0: style: The function 'security_task_alloc' is never used. [unusedFunction]

^
security/security.c:1730:0: style: The function 'security_task_fix_setgid' is never used. [unusedFunction]

^
security/security.c:1724:0: style: The function 'security_task_fix_setuid' is never used. [unusedFunction]

^
security/security.c:1768:0: style: The function 'security_task_getioprio' is never used. [unusedFunction]

^
security/security.c:1741:0: style: The function 'security_task_getpgid' is never used. [unusedFunction]

^
security/security.c:1790:0: style: The function 'security_task_getscheduler' is never used. [unusedFunction]

^
security/security.c:1746:0: style: The function 'security_task_getsid' is never used. [unusedFunction]

^
security/security.c:1800:0: style: The function 'security_task_kill' is never used. [unusedFunction]

^
security/security.c:1806:0: style: The function 'security_task_prctl' is never used. [unusedFunction]

^
security/security.c:1773:0: style: The function 'security_task_prlimit' is never used. [unusedFunction]

^
security/security.c:1763:0: style: The function 'security_task_setioprio' is never used. [unusedFunction]

^
security/security.c:1758:0: style: The function 'security_task_setnice' is never used. [unusedFunction]

^
security/security.c:1736:0: style: The function 'security_task_setpgid' is never used. [unusedFunction]

^
security/security.c:1779:0: style: The function 'security_task_setrlimit' is never used. [unusedFunction]

^
security/security.c:1785:0: style: The function 'security_task_setscheduler' is never used. [unusedFunction]

^
security/security.c:1824:0: style: The function 'security_task_to_inode' is never used. [unusedFunction]

^
security/security.c:1643:0: style: The function 'security_transfer_creds' is never used. [unusedFunction]

^
security/security.c:2080:0: style: The function 'security_watch_key' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/ships.cpp:39:0: style: The function 'setLongestShipSize' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/seaview.cpp:251:0: style: The function 'setStats' is never used. [unusedFunction]

^
memory/page_alloc.c:7773:0: style: The function 'set_dma_reserve' is never used. [unusedFunction]

^
memory/vmalloc.c:1328:0: style: The function 'set_iounmap_nonlazy' is never used. [unusedFunction]

^
memory/percpu.c:3127:0: style: The function 'setup_per_cpu_areas' is never used. [unusedFunction]

^
memory/page_alloc.c:6432:0: style: The function 'setup_per_cpu_pageset' is never used. [unusedFunction]

^
memory/shmem.c:375:0: style: The function 'shmem_charge' is never used. [unusedFunction]

^
memory/shmem.c:4134:0: style: The function 'shmem_init' is never used. [unusedFunction]

^
memory/shmem.c:4150:0: style: The function 'shmem_lock' is never used. [unusedFunction]

^
memory/shmem.c:1490:0: style: The function 'shmem_show_mpol' is never used. [unusedFunction]

^
memory/shmem.c:812:0: style: The function 'shmem_swap_usage' is never used. [unusedFunction]

^
memory/shmem.c:4155:0: style: The function 'shmem_unlock_mapping' is never used. [unusedFunction]

^
memory/vmscan.c:4010:0: style: The function 'shrink_all_memory' is never used. [unusedFunction]

^
memory/swapfile.c:3411:0: style: The function 'si_swapinfo' is never used. [unusedFunction]

^
desktop tools/games/knavalbattle/src/chatwidget.cpp:109:0: style: The function 'sizeHint' is never used. [unusedFunction]

^
memory/slab.c:4047:0: style: The function 'slabinfo_show_stats' is never used. [unusedFunction]

^
memory/slab.c:4089:0: style: The function 'slabinfo_write' is never used. [unusedFunction]

^
net/ipv4/netfilter/nf_nat_snmp_basic_main.c:105:0: style: The function 'snmp_helper' is never used. [unusedFunction]

^
net/ipv4/netfilter/nf_nat_snmp_basic_main.c:95:0: style: The function 'snmp_version' is never used. [unusedFunction]

^
net/socket.c:3036:0: style: The function 'sock_is_registered' is never used. [unusedFunction]

^
net/rfkill/core.c:726:0: style: The function 'soft_show' is never used. [unusedFunction]

^
net/rfkill/core.c:734:0: style: The function 'soft_store' is never used. [unusedFunction]

^
memory/sparse.c:575:0: style: The function 'sparse_init' is never used. [unusedFunction]

^
memory/ksm.c:3094:0: style: The function 'stable_node_chains_show' is never used. [unusedFunction]

^
memory/ksm.c:3087:0: style: The function 'stable_node_dups_show' is never used. [unusedFunction]

^
memory/backing-dev.c:201:0: style: The function 'stable_pages_required_show' is never used. [unusedFunction]

^
net/rfkill/core.c:779:0: style: The function 'state_show' is never used. [unusedFunction]

^
net/rfkill/core.c:787:0: style: The function 'state_store' is never used. [unusedFunction]

^
command lines/bash/support/man2html.c:190:0: style: The function 'strduplicate' is never used. [unusedFunction]

^
command lines/bash/support/man2html.c:148:0: style: The function 'strgrow' is never used. [unusedFunction]

^
command lines/bash/support/man2html.c:210:0: style: The function 'strmaxcat' is never used. [unusedFunction]

^
memory/maccess.c:170:0: style: The function 'strncpy_from_kernel_nofault' is never used. [unusedFunction]

^
memory/maccess.c:268:0: style: The function 'strncpy_from_user_nofault' is never used. [unusedFunction]

^
memory/maccess.c:309:0: style: The function 'strnlen_user_nofault' is never used. [unusedFunction]

^
memory/hugetlb.c:2905:0: style: The function 'surplus_hugepages_show' is never used. [unusedFunction]

^
net/sunrpc/svc_xprt.c:119:0: style: The function 'svc_print_xprts' is never used. [unusedFunction]

^
memory/swap_cgroup.c:97:0: style: The function 'swap_cgroup_cmpxchg' is never used. [unusedFunction]

^
memory/swap_cgroup.c:126:0: style: The function 'swap_cgroup_record' is never used. [unusedFunction]

^
memory/swapfile.c:1802:0: style: The function 'swap_type_of' is never used. [unusedFunction]

^
memory/swapfile.c:1851:0: style: The function 'swapdev_block' is never used. [unusedFunction]

^
memory/swapfile.c:1538:0: style: The function 'swp_swapcount' is never used. [unusedFunction]

^
memory/compaction.c:2666:0: style: The function 'sysctl_compaction_handler' is never used. [unusedFunction]

^
memory/slub.c:5654:0: style: The function 'sysfs_slab_release' is never used. [unusedFunction]

^
memory/slub.c:5648:0: style: The function 'sysfs_slab_unlink' is never used. [unusedFunction]

^
net/dsa/master.c:274:0: style: The function 'tagging_show' is never used. [unusedFunction]

^
net/ipv4/tcp_bpf.c:604:0: style: The function 'tcp_bpf_get_proto' is never used. [unusedFunction]

^
net/ipv4/tcp_output.c:141:0: style: The function 'tcp_cwnd_restart' is never used. [unusedFunction]

^
net/ipv4/tcp.c:3773:0: style: The function 'tcp_get_timestamping_opt_stats' is never used. [unusedFunction]

^
net/ipv4/tcp_ulp.c:103:0: style: The function 'tcp_update_ulp' is never used. [unusedFunction]

^
net/ipv4/tcp_ipv4.c:1637:0: style: The function 'tcp_v4_get_syncookie' is never used. [unusedFunction]

^
net/ipv6/tcp_ipv6.c:1155:0: style: The function 'tcp_v6_get_syncookie' is never used. [unusedFunction]

^
command lines/bash/examples/loadables/template.c:48:0: style: The function 'template_builtin_load' is never used. [unusedFunction]

^
command lines/bash/examples/loadables/template.c:56:0: style: The function 'template_builtin_unload' is never used. [unusedFunction]

^
net/tipc/name_table.c:1145:0: style: The function 'tipc_dest_del' is never used. [unusedFunction]

^
net/tipc/name_table.c:1167:0: style: The function 'tipc_dest_list_len' is never used. [unusedFunction]

^
net/tipc/name_table.c:1157:0: style: The function 'tipc_dest_list_purge' is never used. [unusedFunction]

^
net/tipc/name_table.c:1129:0: style: The function 'tipc_dest_pop' is never used. [unusedFunction]

^
net/tipc/monitor.c:614:0: style: The function 'tipc_mon_create' is never used. [unusedFunction]

^
net/tipc/monitor.c:649:0: style: The function 'tipc_mon_delete' is never used. [unusedFunction]

^
net/tipc/monitor.c:566:0: style: The function 'tipc_mon_get_state' is never used. [unusedFunction]

^
net/tipc/monitor.c:411:0: style: The function 'tipc_mon_peer_down' is never used. [unusedFunction]

^
net/tipc/monitor.c:392:0: style: The function 'tipc_mon_peer_up' is never used. [unusedFunction]

^
net/tipc/monitor.c:533:0: style: The function 'tipc_mon_prep' is never used. [unusedFunction]

^
net/tipc/monitor.c:450:0: style: The function 'tipc_mon_rcv' is never used. [unusedFunction]

^
net/tipc/monitor.c:322:0: style: The function 'tipc_mon_remove_peer' is never used. [unusedFunction]

^
net/tipc/msg.c:213:0: style: The function 'tipc_msg_append' is never used. [unusedFunction]

^
net/tipc/msg.c:587:0: style: The function 'tipc_msg_extract' is never used. [unusedFunction]

^
net/tipc/msg.c:318:0: style: The function 'tipc_msg_fragment' is never used. [unusedFunction]

^
net/tipc/msg.c:706:0: style: The function 'tipc_msg_lookup_dest' is never used. [unusedFunction]

^
net/tipc/msg.c:803:0: style: The function 'tipc_msg_pskb_copy' is never used. [unusedFunction]

^
net/tipc/msg.c:766:0: style: The function 'tipc_msg_reassemble' is never used. [unusedFunction]

^
net/tipc/msg.c:683:0: style: The function 'tipc_msg_skb_clone' is never used. [unusedFunction]

^
net/tipc/msg.c:526:0: style: The function 'tipc_msg_try_bundle' is never used. [unusedFunction]

^
net/tipc/name_distr.c:198:0: style: The function 'tipc_named_node_up' is never used. [unusedFunction]

^
net/tipc/name_distr.c:370:0: style: The function 'tipc_named_rcv' is never used. [unusedFunction]

^
net/tipc/name_table.c:695:0: style: The function 'tipc_nametbl_build_group' is never used. [unusedFunction]

^
net/tipc/name_table.c:851:0: style: The function 'tipc_nametbl_init' is never used. [unusedFunction]

^
net/tipc/name_table.c:601:0: style: The function 'tipc_nametbl_lookup' is never used. [unusedFunction]

^
net/tipc/name_table.c:670:0: style: The function 'tipc_nametbl_lookup_dst_nodes' is never used. [unusedFunction]

^
net/tipc/name_table.c:642:0: style: The function 'tipc_nametbl_mc_lookup' is never used. [unusedFunction]

^
net/tipc/name_table.c:894:0: style: The function 'tipc_nametbl_stop' is never used. [unusedFunction]

^
net/tipc/name_table.c:760:0: style: The function 'tipc_nametbl_withdraw' is never used. [unusedFunction]

^
net/tipc/net.c:139:0: style: The function 'tipc_net_finalize_work' is never used. [unusedFunction]

^
net/tipc/net.c:156:0: style: The function 'tipc_net_stop' is never used. [unusedFunction]

^
net/tipc/netlink_compat.c:1359:0: style: The function 'tipc_netlink_compat_start' is never used. [unusedFunction]

^
net/tipc/netlink_compat.c:1372:0: style: The function 'tipc_netlink_compat_stop' is never used. [unusedFunction]

^
net/tipc/netlink.c:299:0: style: The function 'tipc_netlink_start' is never used. [unusedFunction]

^
net/tipc/netlink.c:311:0: style: The function 'tipc_netlink_stop' is never used. [unusedFunction]

^
net/tipc/monitor.c:764:0: style: The function 'tipc_nl_add_monitor_peer' is never used. [unusedFunction]

^
net/tipc/monitor.c:703:0: style: The function 'tipc_nl_monitor_get_threshold' is never used. [unusedFunction]

^
net/tipc/monitor.c:691:0: style: The function 'tipc_nl_monitor_set_threshold' is never used. [unusedFunction]

^
net/tipc/name_distr.c:265:0: style: The function 'tipc_publ_notify' is never used. [unusedFunction]

^
net/tipc/net.c:147:0: style: The function 'tipc_sched_net_finalize' is never used. [unusedFunction]

^
net/tipc/msg.c:852:0: style: The function 'tipc_skb_reject' is never used. [unusedFunction]

^
net/tipc/topsrv.c:707:0: style: The function 'tipc_topsrv_exit_net' is never used. [unusedFunction]

^
net/tipc/topsrv.c:702:0: style: The function 'tipc_topsrv_init_net' is never used. [unusedFunction]

^
net/tipc/topsrv.c:559:0: style: The function 'tipc_topsrv_kern_subscr' is never used. [unusedFunction]

^
net/tipc/topsrv.c:586:0: style: The function 'tipc_topsrv_kern_unsubscr' is never used. [unusedFunction]

^
net/tipc/udp_media.c:533:0: style: The function 'tipc_udp_nl_add_bearer_data' is never used. [unusedFunction]

^
net/tipc/udp_media.c:615:0: style: The function 'tipc_udp_nl_bearer_add' is never used. [unusedFunction]

^
memory/mmu_gather.c:207:0: style: The function 'tlb_remove_table' is never used. [unusedFunction]

^
memory/mmap_lock.c:194:0: style: The function 'trace_mmap_lock_reg' is never used. [unusedFunction]

^
memory/mmap_lock.c:199:0: style: The function 'trace_mmap_lock_unreg' is never used. [unusedFunction]

^
memory/huge_memory.c:65:0: style: The function 'transparent_hugepage_enabled' is never used. [unusedFunction]

^
memory/gup.c:81:0: style: The function 'try_grab_compound_head' is never used. [unusedFunction]

^
memory/memory_hotplug.c:985:0: style: The function 'try_online_node' is never used. [unusedFunction]

^
net/rfkill/core.c:690:0: style: The function 'type_show' is never used. [unusedFunction]

^
net/ipv4/udp_bpf.c:44:0: style: The function 'udp_bpf_get_proto' is never used. [unusedFunction]

^
memory/vmalloc.c:2034:0: style: The function 'unmap_kernel_range' is never used. [unusedFunction]

^
memory/vmalloc.c:2317:0: style: The function 'vfree_atomic' is never used. [unusedFunction]

^
memory/memory.c:650:0: style: The function 'vm_normal_page_pmd' is never used. [unusedFunction]

^
memory/interval_tree.c:28:0: style: The function 'vma_interval_tree_insert_after' is never used. [unusedFunction]

^
memory/mmap.c:3518:0: style: The function 'vma_is_special_mapping' is never used. [unusedFunction]

^
memory/util.c:307:0: style: The function 'vma_is_stack_for_current' is never used. [unusedFunction]

^
memory/mempolicy.c:1823:0: style: The function 'vma_policy_mof' is never used. [unusedFunction]

^
memory/vmalloc.c:1984:0: style: The function 'vmalloc_init' is never used. [unusedFunction]

^
memory/vmalloc.c:491:0: style: The function 'vmalloc_nr_pages' is never used. [unusedFunction]

^
memory/memremap.c:441:0: style: The function 'vmem_altmap_free' is never used. [unusedFunction]

^
memory/sparse-vmemmap.c:219:0: style: The function 'vmemmap_populate_basepages' is never used. [unusedFunction]

^
memory/nommu.c:203:0: style: The function 'vread' is never used. [unusedFunction]

^
memory/nommu.c:213:0: style: The function 'vwrite' is never used. [unusedFunction]

^
memory/pagewalk.c:461:0: style: The function 'walk_page_vma' is never used. [unusedFunction]

^
memory/page_alloc.c:8061:0: style: The function 'watermark_scale_factor_sysctl_handler' is never used. [unusedFunction]

^
memory/backing-dev.c:661:0: style: The function 'wb_blkcg_offline' is never used. [unusedFunction]

^
memory/backing-dev.c:577:0: style: The function 'wb_get_create' is never used. [unusedFunction]

^
memory/page-writeback.c:1941:0: style: The function 'wb_over_bg_thresh' is never used. [unusedFunction]

^
memory/page-writeback.c:1389:0: style: The function 'wb_update_bandwidth' is never used. [unusedFunction]

^
memory/backing-dev.c:264:0: style: The function 'wb_wakeup_delayed' is never used. [unusedFunction]

^
net/wireless/wext-proc.c:139:0: style: The function 'wext_proc_exit' is never used. [unusedFunction]

^
net/wireless/wext-proc.c:129:0: style: The function 'wext_proc_init' is never used. [unusedFunction]

^
memory/memory.c:2828:0: style: The function 'wp_page_copy' is never used. [unusedFunction]

^
memory/memory.c:3015:0: style: The function 'wp_pfn_shared' is never used. [unusedFunction]

^
net/ieee802154/core.c:84:0: style: The function 'wpan_phy_idx_to_wpan_phy' is never used. [unusedFunction]

^
command lines/bash/builtins/mkbuiltins.c:1352:0: style: The function 'write_dummy_declarations' is never used. [unusedFunction]

^
net/ipv6/xfrm6_input.c:77:0: style: The function 'xfrm6_udp_encap_rcv' is never used. [unusedFunction]

^
net/xfrm/xfrm_device.c:340:0: style: The function 'xfrm_dev_backlog' is never used. [unusedFunction]

^
net/sunrpc/xprtmultipath.c:492:0: style: The function 'xprt_iter_get_xprt' is never used. [unusedFunction]

^
net/xdp/xsk.c:249:0: style: The function 'xsk_generic_rcv' is never used. [unusedFunction]

^
memory/zsmalloc.c:586:0: style: The function 'zs_stats_size_show' is never used. [unusedFunction]

^
memory/zswap.c:1400:0: style: The function 'zswap_debugfs_exit' is never used. [unusedFunction]

^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

